{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/browserify/lib/_empty.js","node_modules/decimal.js/decimal.js","node_modules/path-browserify/index.js","node_modules/process/browser.js","src/index.ts","src/localization.ts","src/utils.ts"],"names":[],"mappings":"AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5tJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"timecount.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","","/*! decimal.js v10.0.1 https://github.com/MikeMcl/decimal.js/LICENCE */\r\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*\r\n   *  decimal.js v10.0.1\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { name: '[object Decimal]' };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * Math.pow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = Math.pow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(Math.pow(5, -k));\r\n\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with different signs.\r\n      // Return NaN if both are Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or 0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is Infinity or x is 0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is Infinity.\r\n      // Return x if both are Infinity with the same sign.\r\n      // Return NaN if both are Infinity with different signs.\r\n      // Return y if x is finite and y is Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '1e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, Infinity or 0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.\r\n        ? NaN\r\n\r\n        // Return Infinity if either is Infinity.\r\n        // Return 0 if either is 0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, 0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either Infinity, NaN or 0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n  // Add aliases to match BigDecimal method names.\r\n  // P.add = P.plus;\r\n  P.subtract = P.minus;\r\n  P.multiply = P.times;\r\n  P.divide = P.div;\r\n  P.remainder = P.mod;\r\n  P.compareTo = P.cmp;\r\n  P.negate = P.neg;\r\n   */\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, y,\r\n      len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = Math.pow(4, -k).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? Math.pow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    // Max k before Math.pow precision loss is 22\r\n    x = x.times(Math.pow(5, -k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(0, -0)               = pi\r\n   * atan2(0, +0)               = 0\r\n   * atan2(0, -x)               = pi for x > 0\r\n   * atan2(0, x)                = 0 for x > 0\r\n   * atan2(-y, 0)               = -pi/2 for y > 0\r\n   * atan2(y, 0)                = pi/2 for y > 0\r\n   * atan2(y, -Infinity)        = pi for finite y > 0\r\n   * atan2(y, +Infinity)        = 0 for finite y > 0\r\n   * atan2(Infinity, x)         = pi/2 for finite x\r\n   * atan2(Infinity, -Infinity) = 3*pi/4\r\n   * atan2(Infinity, +Infinity) = pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is Infinity or y is 0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is Infinity or x is 0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (v instanceof Decimal) {\r\n        x.s = v.s;\r\n        x.e = v.e;\r\n        x.d = (v = v.d) ? v.slice() : v;\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n          x.e = e;\r\n          x.d = [v];\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if (v.charCodeAt(0) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! ****************************************************************************\r\nCopyright (c) 2017-2018 Pedro Jos Batista\r\nMIT License\r\n\r\nSee the LICENSE file for more information.\r\n***************************************************************************** */\r\n/** [[include:index.md]] */ /** */\r\nimport { Decimal } from \"decimal.js\";\r\nimport { Locale } from \"./localization\";\r\nimport * as localization from \"./localization\";\r\nimport * as utils from \"./utils\";\r\n\r\n// Allow sub-modules to be accessed directly via the main module\r\nexport { localization };\r\nexport { utils };\r\n\r\n// One hundred significant digits seem to be enough to handle more extreme time units\r\nDecimal.set({ precision: 100 });\r\n\r\n//#region Non-exported Functions\r\n\r\nfunction filterEmpty(target: any[]) {\r\n    return target.filter(value => {\r\n        return typeof(value) !== \"undefined\" && value !== \"\";\r\n    });\r\n}\r\n\r\n// Merges the immediate properties of all given objects\r\nfunction merge<T extends object>(... objects: Array<T | undefined>) {\r\n\r\n    let merged = {} as T;\r\n\r\n    for (const object of objects) {\r\n        merged = Object.assign(merged, object || {});\r\n    }\r\n\r\n    return merged;\r\n}\r\n\r\n// Replaces the last occurrence of a string, within a string\r\n// Thanks to https://stackoverflow.com/a/5497365\r\nfunction replaceLast(str: string, search: string, replacement: string) {\r\n    const index = str.lastIndexOf(search);\r\n\r\n    if (index === -1) {\r\n        return str;\r\n    }\r\n\r\n    return str.substr(0, index) + replacement + str.substr(index + 1);\r\n}\r\n\r\n// Gets a named time unit object from a time unit parameter, using the TIME_UNITS database\r\nfunction timeUnitFromSource(parameter: TimeUnitSource | string) {\r\n\r\n    const assign = (name: string, timeUnit: any): NamedTimeUnit => Object.assign({ name }, timeUnit);\r\n\r\n    // tslint:disable:curly\r\n    if (typeof(parameter) === \"object\") {\r\n\r\n        // Return condition 1: The object already is named\r\n        if (parameter.hasOwnProperty(\"name\")) {\r\n            return parameter as NamedTimeUnit;\r\n        }\r\n\r\n        // Return condition 2: Find the corresponding object and name it\r\n        for (const timeUnitName in TimeUnits) if (TimeUnits.hasOwnProperty(timeUnitName)) {\r\n            if (TimeUnits[timeUnitName as keyof TimeUnitDatabase] === parameter) {\r\n                return assign(timeUnitName, (TimeUnits as any)[timeUnitName]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (typeof(parameter) === \"string\") {\r\n\r\n        // Return condition 3: Unit name matches object name exactly (TS will enforce this, but JS won't)\r\n        if (TimeUnits.hasOwnProperty(parameter)) {\r\n            return assign(parameter, (TimeUnits as any)[parameter]);\r\n        }\r\n\r\n        const target = parameter.toLowerCase();\r\n\r\n        // Return condition 4: Unit name is a case variation or plural\r\n        for (const timeUnitName in TimeUnits) if (TimeUnits.hasOwnProperty(timeUnitName)) {\r\n            const customPlural = TimeUnits[timeUnitName as keyof TimeUnitDatabase].customPlural;\r\n\r\n            // Sub-conditions (if target is equal to any of these, we found a variation)\r\n            const condition1 = timeUnitName.toLowerCase();\r\n            const condition2 = condition1 + \"s\";\r\n            const condition3 = timeUnitName.replace(/([a-z])([A-Z])/g, \"$1 $2\").toLowerCase();\r\n            const condition4 = typeof(customPlural) === \"string\"\r\n                ? customPlural.toLowerCase()\r\n                : condition3 + \"s\";\r\n\r\n            if (target === condition1 || target === condition2 || target === condition3 || target === condition4) {\r\n                return assign(timeUnitName, (TimeUnits as any)[timeUnitName]);\r\n            }\r\n        }\r\n    }\r\n    // tslint:enable:curly\r\n\r\n    // No condition met, unit is invalid\r\n    throw new Error(\"Invalid time unit\");\r\n}\r\n\r\n//#endregion\r\n\r\n//#region Non-exported Variables\r\n\r\nconst defaultSettings: TimeWriterSettings = {\r\n    decimalSeparator: \".\",\r\n    hideTimeUnit: false,\r\n    hideZeroSegments: true,\r\n    numericNotation: \"decimal\",\r\n    roundingMode: 4,\r\n    segmentSeparator: \", \",\r\n    significantDigits: 10,\r\n    symbolApproximately: \"\",\r\n    symbolInfinite: \"\",\r\n    symbolNaN: \"NaN\",\r\n    termApproximately: \"approximately\",\r\n    termInfinite: \"infinite\",\r\n    termNaN: \"invalid number of\",\r\n    timeUnitSeparator: \" \",\r\n    verbose: false,\r\n};\r\n\r\n// Gets the decimal separator from a locale string\r\nconst localeDecimalSeparator = (() => {\r\n    const value = 1.1;\r\n    const separator = value.toLocaleString().substring(1, 2);\r\n    return separator;\r\n})();\r\n\r\n// List of roman numerals from greater to lesser\r\nconst romanNumerals: Array<[number, string]> = [\r\n    [1000, \"M\"],  [900, \"CM\"], [500, \"D\"], [400, \"CD\"],\r\n    [100, \"C\"],   [90, \"XC\"],  [50, \"L\"],  [40, \"XL\"],\r\n    [10, \"X\"],    [9, \"IX\"],   [5, \"V\"],   [4, \"IV\"], [1, \"I\"],\r\n];\r\n\r\nconst romanNumeralsBig: Array<[number, string]> = [\r\n    [1000000, `M`], [900000, `CM`], [500000, `D`], [400000, `CD`],\r\n    [100000, `C`],  [90000, `XC`],  [50000, `L`],  [40000, `XL`],\r\n    [10000, `X`],   [9000, `IX`],   [5000, `V`],   [4000, `IV`], [1000, `I`],\r\n].concat(romanNumerals.slice(1)) as any;\r\n\r\n// List of roman fractions in no specific order\r\nconst romanFractions: Array<[number, string]> = [\r\n    [1 / 12, \"\"],  [2 / 12, \":\"],  [3 / 12, \"\"],  [4 / 12, \"::\"],   [5 / 12, \"::\"],   [6 / 12, \"S\"],\r\n    [7 / 12, \"S\"], [8 / 12, \"S:\"], [9 / 12, \"S\"], [10 / 12, \"S::\"], [11 / 12, \"S::\"],\r\n    [1 / 36, \"\"], [1 / 48, \"\"], [1 / 72, \"\"], [1 / 288, \"\"],\r\n];\r\n\r\n//#endregion\r\n\r\n//#region Exported Functions\r\n\r\n/**\r\n * Writes a numeric value using numerals from the _Ancient Rome_.\r\n *\r\n * @param value\r\n *   A number or [big decimal](https://mikemcl.github.io/decimal.js) to be converted to roman.\r\n * @param fractions\r\n *   Whether to include [common fractions](https://en.wikipedia.org/wiki/Roman_numerals#Fractions) or not.\r\n * @return\r\n *   A string with the roman representation of the given number.\r\n */\r\nexport function writeRoman(value: number | Decimal, fractions: boolean = false) {\r\n\r\n    if (typeof(value) === \"number\") {\r\n        value = new Decimal(value);\r\n    }\r\n\r\n    const fixedValue = value.trunc();\r\n    const numerals = value.comparedTo(5000) > 0 ? romanNumeralsBig : romanNumerals;\r\n    let amountLeft = fixedValue;\r\n    let result = \"\";\r\n\r\n    while (amountLeft.comparedTo(0) > 0) {\r\n        // The order of romanNumerals is important here: they are written from large to lesser\r\n        for (const entry of numerals) {\r\n\r\n            // So, if value is 1111, this accounts for M (1000) first, then C (100), then X (10), then I (1)\r\n            if (amountLeft.comparedTo(entry[0]) >= 0) {\r\n                amountLeft = amountLeft.minus(entry[0]);\r\n                result += entry[1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (fractions && value.comparedTo(fixedValue) > 0) {\r\n        result += writeRomanFractions(value.minus(fixedValue));\r\n    }\r\n\r\n    return result.length > 0 ? result : \"nulla\";\r\n}\r\n\r\n/**\r\n * Writes the fraction part of a numeric value using common fractions from the _Ancient Rome_.\r\n *\r\n * @param value\r\n *   A number that will have its decimal part extracted and written in roman.\r\n * @return\r\n *   A string with the roman representation of the given fraction.\r\n */\r\nexport function writeRomanFractions(value: number | Decimal) {\r\n\r\n    if (typeof(value) === \"number\") {\r\n        value = new Decimal(value);\r\n    }\r\n\r\n    value = value.minus(value.trunc());\r\n\r\n    if (value.comparedTo(0) === 0) {\r\n        return \"\";\r\n    }\r\n\r\n    let smallestDifference = new Decimal(1);\r\n    let smallestIndex = -1;\r\n\r\n    // Not much to explain: compares all romanFractions with the given fraction and returns the one with the\r\n    // smallest difference (only faster if the difference is exactly zero)\r\n\r\n    for (let i = 0; i < romanFractions.length; i += 1) {\r\n        const romanFraction = romanFractions[i];\r\n        const difference = value.minus(romanFraction[0]).abs();\r\n\r\n        if (difference.comparedTo(0) === 0) {\r\n            return romanFraction[1];\r\n        }\r\n\r\n        if (difference.comparedTo(smallestDifference) < 0) {\r\n            smallestDifference = difference;\r\n            smallestIndex = i;\r\n        }\r\n    }\r\n\r\n    return romanFractions[smallestIndex][1];\r\n}\r\n\r\n//#endregion\r\n\r\n//#region Exported Constants\r\n\r\n/**\r\n * Objects pertaining to this constant can be used as a parameter value for the\r\n * [countdown](../classes/_index_.timewriter.html#countdown) method of time writers.\r\n *\r\n * These constants contains groups of [time units](../classes/_index_.timeunitdatabase.html) that are related.\r\n */\r\nexport const TimeSegments = {\r\n\r\n    /** All base ten [SI](https://en.wikipedia.org/wiki/International_System_of_Units) time units. */\r\n    baseTen: [\"yottasecond\", \"zettasecond\", \"exasecond\", \"petasecond\", \"terasecond\", \"gigasecond\", \"megasecond\",\r\n        \"kilosecond\", \"second\", \"milisecond\", \"microsecond\", \"nanosecond\", \"picosecond\", \"femtosecond\", \"attosecond\",\r\n        \"zeptosecond\", \"yoctosecond\"],\r\n\r\n    /** All base two binary time units. */\r\n    binary: [\"yobisecond\", \"zebisecond\", \"exbisecond\", \"pebisecond\", \"tebisecond\", \"gibisecond\", \"mebisecond\",\r\n        \"kibisecond\", \"second\"],\r\n\r\n    /** Common time unit segmentation: year, month, day, hour, minute and second. */\r\n    common: [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"],\r\n\r\n    /** Extremes and the middle-point of timecount units: Planck time, nanosecond and yobisecond. */\r\n    extremes: [\"planckTime\", \"nanosecond\", \"yobisecond\"],\r\n\r\n    /** Contains all units of a [sidereal time](https://en.wikipedia.org/wiki/Sidereal_time). */\r\n    sidereal: [\"siderealYear\", \"siderealMonth\", \"siderealDay\", \"siderealHour\", \"siderealMinute\", \"siderealSecond\"],\r\n};\r\n\r\n/**\r\n * A database of [time units](../interfaces/_index_.timeunit.html), used to qualify and describe lengths of time.\r\n *\r\n * Each property of this object enumerates the linguistic and mathematical features of the time unit it represents.\r\n *\r\n * ---\r\n *\r\n * See [TimeUnitDatabase](../interfaces/_index_.timeunitdatabase.html) for more information about time units.\r\n */\r\nexport const TimeUnits: TimeUnitDatabase<TimeUnit> = {\r\n    anomalisticMonth: { factor: new Decimal(\"2.38071312e+15\"), approximated: true },\r\n    anomalisticYear: { factor: new Decimal(\"3.15584325504e+16\"), approximated: true },\r\n    attosecond: { factor: new Decimal(\"1e-9\"), symbol: \"as\" },\r\n    biennium: { factor: new Decimal(\"6.3113904e+16\"), customPlural: \"biennia\" },\r\n    century: { factor: new Decimal(\"3.1536e+18\"), customPlural: \"centuries\" },\r\n    cosmicYear: { factor: new Decimal(\"7.4898e+24\"), approximated: true },\r\n    day: { factor: new Decimal(\"8.64e+13\"), symbol: \"d\" },\r\n    decade: { factor: new Decimal(\"3.1556952e+17\") },\r\n    draconicMonth: { factor: new Decimal(\"2.351135808e+15\"), approximated: true },\r\n    draconicYear: { factor: new Decimal(\"2.994797455629e+16\"), approximated: true },\r\n    eclipticYear: { factor: new Decimal(\"2.994797455629e+16\"), approximated: true },\r\n    exasecond: { factor: new Decimal(\"1e+27\"), symbol: \"Es\" },\r\n    exbisecond: { factor: new Decimal(\"1.152921504606846976e+27\"), symbol: \"Eis\" },\r\n    femtosecond: { factor: new Decimal(\"1e-6\"), symbol: \"fs\" },\r\n    fortnight: { factor: new Decimal(\"1.2096e+15\") },\r\n    galacticYear: { factor: new Decimal(\"7.4898e+24\"), approximated: true },\r\n    gibisecond: { factor: new Decimal(\"1.073741824e+18\"), symbol: \"Gis\" },\r\n    gigasecond: { factor: new Decimal(\"1e+18\"), symbol: \"Gs\" },\r\n    gregorianYear: { factor: new Decimal(\"3.1556952e+16\"), readableName: \"Gregorian year\" },\r\n    hour: { factor: new Decimal(\"3.6e+12\"), symbol: \"h\" },\r\n    jiffy: { factor: new Decimal(\"3e-15\"), customPlural: \"jiffies\" },\r\n    julianYear: { factor: new Decimal(\"3.15576e+16\"), readableName: \"Julian year\" },\r\n    kibisecond: { factor: new Decimal(\"1.024e+12\"), symbol: \"Kis\" },\r\n    kilosecond: { factor: new Decimal(\"1e+12\"), symbol: \"Ks\" },\r\n    kiloyear: { factor: new Decimal(\"3.1536e+19\"), symbol: \"ky\" },\r\n    leapYear: { factor: new Decimal(\"3.16224e+16\") },\r\n    lustrum: { factor: new Decimal(\"1.5778476e+17\"), customPlural: \"lustra\" },\r\n    mebisecond: { factor: new Decimal(\"1.048576e+15\"), symbol: \"Mis\" },\r\n    megasecond: { factor: new Decimal(\"1e+15\"), symbol: \"Ms\" },\r\n    microsecond: { factor: new Decimal(\"1e+3\"), symbol: \"s\" },\r\n    milisecond: { factor: new Decimal(\"1e+6\"), symbol: \"ms\" },\r\n    millenium: { factor: new Decimal(\"3.1556952e+19\"), customPlural: \"millennia\" },\r\n    minute: { factor: new Decimal(\"6e+10\"), symbol: \"min\" },\r\n    month: { factor: new Decimal(\"2.628e+15\"), symbol: \"m\" },\r\n    nanosecond: { factor: new Decimal(\"1\"), symbol: \"ns\" },\r\n    nodicalMonth: { factor: new Decimal(\"2.351135808e+15\"), approximated: true },\r\n    nonLeapYear: { factor: new Decimal(\"3.1536e+16\"), readableName: \"non-leap year\" },\r\n    novennium: { factor: new Decimal(\"2.84012568e+17\"), customPlural: \"novennia\" },\r\n    octennium: { factor: new Decimal(\"2.52455616e+17\"), customPlural: \"octennia\" },\r\n    pebisecond: { factor: new Decimal(\"1.125899906842624e+24\"), symbol: \"Pis\" },\r\n    petasecond: { factor: new Decimal(\"1e+24\"), symbol: \"Ps\" },\r\n    picosecond: { factor: new Decimal(\"1e-3\"), symbol: \"ps\" },\r\n    planckTime: { factor: new Decimal(\"5.39056e-35\"), symbol: \"t\", readableName: \"Planck time\" },\r\n    quadrennium: { factor: new Decimal(\"1.26227808e+17\"), customPlural: \"quadrennia\" },\r\n    quindecennium: { factor: new Decimal(\"4.7335428e+17\"), customPlural: \"quindecennia\" },\r\n    quinquennium: { factor: new Decimal(\"1.5778476e+17\"), customPlural: \"quinquennia\" },\r\n    second: { factor: new Decimal(\"1e+9\"), symbol: \"s\" },\r\n    septennium: { factor: new Decimal(\"2.20752e+17\"), customPlural: \"septennia\" },\r\n    shake: { factor: new Decimal(\"10\") },\r\n    siderealDay: { factor: new Decimal(\"8.616409e+13\"), approximated: true },\r\n    siderealHour: { factor: new Decimal(\"3.590170416667e+12\"), approximated: true },\r\n    siderealMinute: { factor: new Decimal(\"5.983617361111e+10\"), approximated: true },\r\n    siderealMonth: { factor: new Decimal(\"2.360591424e+15\"), approximated: true },\r\n    siderealSecond: { factor: new Decimal(\"9.972695601852e+8\"), approximated: true },\r\n    siderealYear: { factor: new Decimal(\"3.155814954e+16\"), approximated: true },\r\n    solarDay: { factor: new Decimal(\"8.64e+13\") },\r\n    solarYear: { factor: new Decimal(\"3.155693e+16\"), approximated: true },\r\n    svedberg: { factor: new Decimal(\"1e-4\"), symbol: \"Sv\" },\r\n    synodicMonth: { factor: new Decimal(\"2.55144384e+15\"), approximated: true },\r\n    tebisecond: { factor: new Decimal(\"1.099511627776e+21\"), symbol: \"Tis\" },\r\n    terasecond: { factor: new Decimal(\"1e+21\"), symbol: \"Ts\" },\r\n    timeUnit: { factor: new Decimal(\"1.024e+6\"), symbol: \"TU\" },\r\n    tropicalYear: { factor: new Decimal(\"3.155693e+16\"), approximated: true },\r\n    week: { factor: new Decimal(\"6.048e+14\"), symbol: \"w\" },\r\n    year: { factor: new Decimal(\"3.1556952e+16\"), symbol: \"y\" },\r\n    yobisecond: { factor: new Decimal(\"1.208925819614629174706176e+33\"), symbol: \"Yis\" },\r\n    yoctosecond: { factor: new Decimal(\"1e-15\"), symbol: \"ys\" },\r\n    yottasecond: { factor: new Decimal(\"1e+33\"), symbol: \"Ys\" },\r\n    zebisecond: { factor: new Decimal(\"1.180591620717411303424e+30\"), symbol: \"Zis\" },\r\n    zeptosecond: { factor: new Decimal(\"1e-12\"), symbol: \"zs\" },\r\n    zettasecond: { factor: new Decimal(\"1e+30\"), symbol: \"Zs\" },\r\n};\r\n\r\n/**\r\n * Alias to [TimeUnits](#timeunits-1).\r\n *\r\n * @deprecated Since v1.1.0 - Incorrect naming, all exported constants are now capitalized (will be removed in v2).\r\n */\r\nexport const timeUnits = TimeUnits;\r\n\r\n//#endregion\r\n\r\n//#region Exported Types\r\n\r\n/**\r\n * This interface is a base time unit definition, consisting of linguistic-related properties pertaining to the time\r\n * unit being described.\r\n *\r\n * Mathematical properties are left out of this interface in order to allow better control over configurations (and\r\n * since time units have the same mathematical constants regardless of language).\r\n */\r\nexport interface BaseTimeUnit {\r\n\r\n    /**\r\n     * Defines a custom pluralized name for the time unit; it can be a string  used whenever the quantity of time is\r\n     * greater than one  or a function, able to retrieve different words according to a given quantity.\r\n     *\r\n     * By default, words are pluralized by adding an \"s\" to the end of their [readable name](#readablename).\r\n     */\r\n    customPlural?: string | NumericWriter;\r\n\r\n    /**\r\n     * Determines whether the time unit should be pluralized: by default, words are pluralized by adding an \"s\" to the\r\n     * end of their [readable name](#readablename), but this can be changed via [customPlural](#customplural).\r\n     *\r\n     * If set to false, this will prevent the time unit from ever being pluralized (unless this configuration is\r\n     * overwritten).\r\n     */\r\n    pluralize?: boolean;\r\n\r\n    /**\r\n     * Name of the time unit presented in a human readable format.\r\n     *\r\n     * For timecount's default language  English (US)  this is parsed from the name of the property that contains the\r\n     * time unit, taking advantage of its [medial capitals](https://en.wikipedia.org/wiki/Camel_case) to separate\r\n     * compound names (`galacticYear` parses as \"galactic year\").\r\n     *\r\n     * In some cases, however, a custom readable name is required even in English (US) (`planckTime`, for example, would\r\n     * not be correctly capitalized as \"Planck time\").\r\n     *\r\n     * ---\r\n     *\r\n     * If you wish to help timecount with a translation, plese consult\r\n     * [Contributing: Translating](https://github.com/pjbatista/timecount/blob/master/CONTRIBUTING.md#translating).\r\n     */\r\n    readableName?: string;\r\n\r\n    /** A symbol representing the time unit (e.g. \"s\" for seconds). */\r\n    symbol?: string;\r\n}\r\n\r\n/**\r\n * This interface is used internally in order to map the [time unit database](../modules/_index_.html#time_unit) using\r\n * its properties.\r\n */\r\nexport interface NamedTimeUnit extends TimeUnit {\r\n\r\n    /** This name is parsed from the name of the property that contains the time unit object. */\r\n    name: keyof TimeUnitDatabase;\r\n}\r\n\r\n/**\r\n * This interface represents a nanosecond-based time value.\r\n *\r\n * @deprecated Since v1.1.0 - Unnecessary interface (will be removed in v2).\r\n */\r\nexport interface NanosecondBasedTime {\r\n\r\n    /** Gets the numeric representation of the time length in nanoseconds. */\r\n    readonly nanoseconds: number;\r\n}\r\n\r\n/**\r\n * This type contains all values accepted when configuring\r\n * [numeric notations](../interfaces/_index_.typewritersettings#numericnotation).\r\n *\r\n * - **\"decimal\":** standard _HinduArabic numeral system_ using base ten;\r\n * - **\"roman\":** _Ancient Rome_ numeral system, ignoring fractions;\r\n * - **\"roman-fractions\":** _Ancient Rome_ numeral system, using\r\n *   [common fractions](https://en.wikipedia.org/wiki/Roman_numerals#Fractions);\r\n * - **\"scientific\":** Exponent notation; writes very small and very large numbers using powers of 10.\r\n */\r\nexport type NumericNotation = \"decimal\" | \"roman\" | \"roman-fractions\" | \"scientific\";\r\n\r\n/**\r\n * This type defines functions used by [time writers](../classes/_index_.timewriter.html) in order to express a numeric\r\n * value in the form of text.\r\n *\r\n * The first parameter is a native number and the second, optional, is a\r\n * [big decimal](https://www.npmjs.com/package/decimal.js).\r\n */\r\nexport type NumericWriter = (value: number, bigValue?: Decimal) => string;\r\n\r\n/**\r\n * This enumeration contains all [rounding modes](../interfaces/_index_.timewritersettings.html#roundingmode) available,\r\n * extracted from the [decimal.js documentation](https://mikemcl.github.io/decimal.js).\r\n */\r\nexport enum RoundingMode {\r\n\r\n    /** Rounds away from zero. */\r\n    RoundUp = 0,\r\n\r\n    /** Rounds towards zero. */\r\n    RoundDown,\r\n\r\n    /** Rounds towards _Infinity_. */\r\n    RoundCeil,\r\n\r\n    /** Rounds towards _-Infinity_. */\r\n    RoundFloor,\r\n\r\n    /** Rounds towards nearest neighbour; if equidistant, rounds away from zero. */\r\n    RoundHalfUp,\r\n\r\n    /** Rounds towards nearest neighbour; if equidistant, rounds towards zero. */\r\n    RoundHalfDown,\r\n\r\n    /** Rounds towards nearest neighbour; if equidistant, rounds towards even neighbour. */\r\n    RoundHalfEven,\r\n\r\n    /** Rounds towards nearest neighbour; if equidistant, rounds towards _Infinity_. */\r\n    RoundHalfCeil,\r\n\r\n    /** Rounds towards nearest neighbour; if equidistant, rounds towards _-Infinity_. */\r\n    RoundHalfFloor,\r\n}\r\n\r\n/**\r\n * Encapsulates a nanosecond-based time value.\r\n *\r\n * Instances of this class are capable of being converted [from](#from) and [to](#to) / [to big decimal](#toBig) other\r\n * [time units](../interfaces/_index_.timeunitdatabase.html) and also perform basic arithmetics.\r\n *\r\n * Times can also be [approximated](#isApproximated), and operations deriving from their use will also be approximated.\r\n * This doesn't affect the time object value in any way, but is used by [TimeWriter](_index_.timewriter.html) to\r\n * demonstrate approximations.\r\n *\r\n * All instances are _immutable_, thus not affected by methods (new instances are always created instead). Also, all\r\n * time values are necessarily positive (negative times are not a thing).\r\n */\r\nexport class Time {\r\n\r\n    private _approximated: boolean;\r\n    private _nanoseconds: Decimal;\r\n\r\n    /**\r\n     * Gets the [big decimal](https://www.npmjs.com/package/decimal.js) representation of the time length, in\r\n     * nanoseconds.\r\n     */\r\n    public get bigValue() { return this._nanoseconds; }\r\n\r\n    /**\r\n     * Gets whether the value of this is an approximation. This is determined at construction and it remains in all\r\n     * operations with that this time is involved.\r\n     */\r\n    public get isApproximated() { return this._approximated; }\r\n\r\n    /**\r\n     * Gets the numeric representation of the time length in nanoseconds.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `bigValue` and `value` (will be removed in v2).\r\n     */\r\n    public get nanoseconds() { return parseFloat(this._nanoseconds.toString()); }\r\n\r\n    /**\r\n     * Gets the numeric representation of the time length, in nanoseconds.\r\n     */\r\n    public get value() { return parseFloat(this._nanoseconds.toString()); }\r\n\r\n    /**\r\n     * Initializes a new instance of the [Time](_index_.time.html) class using the given time value parameter.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_.\r\n     * @param approximated\r\n     *   Whether the given is an approximation or not. The result of any arithmetic operations involving this time will\r\n     *   also be approximated.\r\n     * @throws Error\r\n     *   When the value is invalid.\r\n     */\r\n    public constructor(value: TimeValueSource, approximated?: boolean);\r\n\r\n    /**\r\n     * Initializes a new instance of the [Time](_index_.time.html) class using the given time value parameter.\r\n     *\r\n     * @param value\r\n     *   Another [Time](_index_.time.html) instance to be replicated.\r\n     * @throws Error\r\n     *   When the value is invalid.\r\n     */\r\n    public constructor(value: Time);\r\n\r\n    // Actual `constructor` implementation\r\n    public constructor(value: TimeValueSource | Time, approximated: boolean = false) {\r\n\r\n        if (value instanceof Time) {\r\n            approximated = value._approximated;\r\n            value = value._nanoseconds;\r\n        }\r\n\r\n        if (typeof(value) !== \"string\" && typeof(value) !== \"number\" && !(value instanceof Decimal)) {\r\n            throw new Error(`Invalid argument ${value}`);\r\n        }\r\n\r\n        if (!(value instanceof Decimal)) {\r\n            value = new Decimal(value);\r\n        }\r\n\r\n        this._approximated = approximated;\r\n        this._nanoseconds = value.abs();\r\n    }\r\n\r\n    /**\r\n     * Converts a time value, measuring it with the specified time unit, and creates a new\r\n     * [Time](../classes/_index_.time.html) instance with an equivalent length of time, but measured in nanoseconds.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion.\r\n     * @return\r\n     *   A nanosecond-based time obtained from the conversion of the given parameters.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public static from(value: TimeValueSource, timeUnit: TimeUnitSource): Time;\r\n\r\n    /**\r\n     * Converts a time value, measuring it with the specified time unit, and creates a new\r\n     * [Time](../classes/_index_.time.html) instance with an equivalent length of time, but measured in nanoseconds.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion. Accepts plurals and case variations.\r\n     * @return\r\n     *   A nanosecond-based time obtained from the conversion of the given parameters.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public static from(value: TimeValueSource, timeUnit: string | TimeUnit): Time;\r\n\r\n    // Actual `from` implementation\r\n    public static from(value: TimeValueSource, timeUnit: TimeUnitSource | string) {\r\n\r\n        if (typeof(value) !== \"string\" && typeof(value) !== \"number\" && !(value instanceof Decimal)) {\r\n            throw new Error(`Invalid argument ${value}`);\r\n        }\r\n\r\n        if (!(value instanceof Decimal)) {\r\n            value = new Decimal(value);\r\n        }\r\n\r\n        timeUnit = timeUnitFromSource(timeUnit);\r\n        return new Time(value.times(timeUnit.factor), timeUnit.approximated);\r\n    }\r\n\r\n    /**\r\n     * Adds the value of this time with the value of another time. If either are [approximations](#isApproximated), the\r\n     * result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be added to this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the values of both times added to each other.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public add(value: TimeValueSource | Time, timeUnit?: TimeUnitSource): Time;\r\n\r\n    /**\r\n     * Adds the value of this time with the value of another time. If either are [approximations](#isApproximated), the\r\n     * result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be added to this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided. Accepts plurals and case variations.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the values of both times added to each other.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public add(value: TimeValueSource | Time, timeUnit?: string | TimeUnit): Time;\r\n\r\n    // Actual `add` implementation\r\n    public add(value: TimeValueSource | Time, timeUnit?: TimeUnitSource) {\r\n\r\n        let approximated = false;\r\n\r\n        if (value instanceof Time) {\r\n            value = value._nanoseconds;\r\n        }\r\n\r\n        if (timeUnit) {\r\n            const converted = Time.from(value, timeUnit);\r\n            approximated = converted._approximated;\r\n            value = converted._nanoseconds;\r\n        }\r\n\r\n        return new Time(this._nanoseconds.add(value), approximated);\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a new time object that contains the value of this time, however with the approximated flag.\r\n     *\r\n     * @returns\r\n     *   Approximated time in relation to this time.\r\n     */\r\n    public approximate() {\r\n        return new Time(this._nanoseconds, true);\r\n    }\r\n\r\n    /**\r\n     * Divides the value of this time by the value of another time. If either are [approximations](#isApproximated), the\r\n     * result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to divide this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of this time divided by the value of the other time.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public divide(value: TimeValueSource | Time, timeUnit?: TimeUnitSource): Time;\r\n\r\n    /**\r\n     * Divides the value of this time by the value of another time. If either are [approximations](#isApproximated), the\r\n     * result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to divide this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided. Accepts plurals and case variations.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of this time divided by the value of the other time.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public divide(value: TimeValueSource | Time, timeUnit?: string | TimeUnit): Time;\r\n\r\n    // Actual `divide` implementation\r\n    public divide(value: TimeValueSource | Time, timeUnit?: TimeUnitSource) {\r\n\r\n        let approximated = false;\r\n\r\n        if (value instanceof Time) {\r\n            value = value._nanoseconds;\r\n        }\r\n\r\n        if (timeUnit) {\r\n            const converted = Time.from(value, timeUnit);\r\n            approximated = converted._approximated;\r\n            value = converted._nanoseconds;\r\n        }\r\n\r\n        return new Time(this._nanoseconds.dividedBy(value), approximated);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the value of this time with the value of another time. If either are\r\n     * [approximations](#isApproximated), the result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be multiplied by this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of both times multiplied by each other.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public multiply(value: TimeValueSource | Time, timeUnit?: TimeUnitSource): Time;\r\n\r\n    /**\r\n     * Multiplies the value of this time with the value of another time. If either are\r\n     * [approximations](#isApproximated), the result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be multiplied by this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided. Accepts plurals and case variations.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of both times multiplied by each other.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public multiply(value: TimeValueSource | Time, timeUnit?: string | TimeUnit): Time;\r\n\r\n    // Actual `multiply` implementation\r\n    public multiply(value: TimeValueSource | Time, timeUnit?: TimeUnitSource) {\r\n\r\n        let approximated = false;\r\n\r\n        if (value instanceof Time) {\r\n            value = value._nanoseconds;\r\n        }\r\n\r\n        if (timeUnit) {\r\n            const converted = Time.from(value, timeUnit);\r\n            approximated = converted._approximated;\r\n            value = converted._nanoseconds;\r\n        }\r\n\r\n        return new Time(this._nanoseconds.times(value), approximated);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the value of another time from the value of this time. If either are [approximations](#isApproximated),\r\n     * the result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be subtracted from this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of this time divided by the value of the other time.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public subtract(value: TimeValueSource | Time, timeUnit?: TimeUnitSource): Time;\r\n\r\n    /**\r\n     * Subtracts the value of another time from the value of this time. If either are [approximations](#isApproximated),\r\n     * the result will also be.\r\n     *\r\n     * @param value\r\n     *   A value representing the length of time, accepted as a _string_ that parses to a number (e.g. \"1000\" or\r\n     *   \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_ -or- another\r\n     *   [Time](_index_.time.html) instance used to be subtracted from this time.\r\n     * @param timeUnit\r\n     *   Time unit used as source for the conversion of `value`. This defaults to \"nanosecond\" and is ignored when a\r\n     *   [Time](_index_.time.html) object is provided. Accepts plurals and case variations.\r\n     * @return\r\n     *   A [Time](_index_.time.html) object with the value of this time divided by the value of the other time.\r\n     * @throws Error\r\n     *   When the value is invalid -or- the time unit is invalid.\r\n     */\r\n    public subtract(value: TimeValueSource | Time, timeUnit?: string | TimeUnit): Time;\r\n\r\n    // Actual `subtract` implementation\r\n    public subtract(value: TimeValueSource | Time, timeUnit?: TimeUnitSource)  {\r\n\r\n        let approximated = false;\r\n\r\n        if (value instanceof Time) {\r\n            value = value._nanoseconds;\r\n        }\r\n\r\n        if (timeUnit) {\r\n            const converted = Time.from(value, timeUnit);\r\n            approximated = converted._approximated;\r\n            value = converted._nanoseconds;\r\n        }\r\n\r\n        return new Time(this._nanoseconds.minus(value), approximated);\r\n    }\r\n\r\n    /**\r\n     * Converts the value of this nanosecond-based time into any other time unit.\r\n     *\r\n     * For the [big decimal](https://www.npmjs.com/package/decimal.js) representation, see [toBig](#tobig).\r\n     *\r\n     * @param timeUnit\r\n     *   Time unit used as target for the conversion.\r\n     * @return\r\n     *   Numeric representation of the converted time, measured using the given time unit.\r\n     */\r\n    public to(timeUnit: TimeUnitSource): number;\r\n\r\n    /**\r\n     * Converts the value of this nanosecond-based time into any other time unit.\r\n     *\r\n     * For the [big decimal](https://www.npmjs.com/package/decimal.js) representation, see [toBig](#tobig).\r\n     *\r\n     * @param timeUnit\r\n     *   Time unit used as target for the conversion. Accepts plurals and case variations.\r\n     * @return\r\n     *   Numeric representation of the converted time, measured using the given time unit.\r\n     */\r\n    public to(timeUnit: string | TimeUnit): number;\r\n\r\n    // Actual `to` implementation\r\n    public to(timeUnit: TimeUnitSource) {\r\n        return this.toBig(timeUnit).toNumber();\r\n    }\r\n\r\n    /**\r\n     * Converts the value of this nanosecond-based time into any other time unit, using\r\n     * [big decimals](https://www.npmjs.com/package/decimal.js).\r\n     *\r\n     * @param timeUnit\r\n     *   Time unit used as target for the conversion.\r\n     * @return\r\n     *   [Big decimal](https://www.npmjs.com/package/decimal.js) representation of the converted time, measured using\r\n     *   the   given time unit.\r\n     */\r\n    public toBig(timeUnit: TimeUnitSource): Decimal;\r\n\r\n    /**\r\n     * Converts the value of this nanosecond-based time into any other time unit, using\r\n     * [big decimals](https://www.npmjs.com/package/decimal.js).\r\n     *\r\n     * @param timeUnit\r\n     *   Time unit used as target for the conversion. Accepts plurals and care variations.\r\n     * @return\r\n     *   [Big decimal](https://www.npmjs.com/package/decimal.js) representation of the converted time, measured using\r\n     *   the   given time unit.\r\n     */\r\n    public toBig(timeUnit: string | TimeUnit): Decimal;\r\n\r\n    // Actual `toBig` implementation\r\n    public toBig(timeUnit: TimeUnitSource) {\r\n\r\n        timeUnit = timeUnitFromSource(timeUnit);\r\n        return this._nanoseconds.dividedBy(timeUnit.factor);\r\n    }\r\n\r\n    /**\r\n     * Gets a string representing the of value of this time, in nanoseconds.\r\n     *\r\n     * @return\r\n     *   Numeric representation of the time length plus the symbol \"ns\".\r\n     */\r\n    public toString() {\r\n        return `${this._approximated ? \"\" : \"\"}${this._nanoseconds.toString()} ns`;\r\n    }\r\n}\r\n\r\n/**\r\n * A time unit is any particular time interval, used as a standard way of measuring or expressing duration.\r\n *\r\n * Extending from its precursor, [BaseTimeUnit](_index_.basetimeunit.html), an object of this type contains both the\r\n * mathematical and linguistic properties of the time unit it describes.\r\n *\r\n * ---\r\n *\r\n * See [TimeUnitDatabase](_index_.timeunitdatabase.html) for more information about time units.\r\n */\r\nexport interface TimeUnit extends BaseTimeUnit {\r\n\r\n    /** Determines whether this time unit is an approximation. */\r\n    approximated?: boolean;\r\n\r\n    /** Multiplicative factor (coefficient) of this time unit in relation to a nanosecond. */\r\n    factor: Decimal;\r\n}\r\n\r\n/**\r\n * A centralized catalog of [time unit](_index_.timeunit.html) definitions.\r\n *\r\n * This interface is a collection of summaries extracted from the web, with information for the time units available in\r\n * timecount. It was created with the intent to encorage its users to explore and play with time conversions.\r\n *\r\n * @typeparam T\r\n *   This type parameter defines which kind of time unit interface its object is describing. It may be a\r\n *   [base time unit](_index_.basetimeunit.html) which contains only linguistic properties or a\r\n *   [time unit](_index_.timeunit.html) with approximation flag and nanosecond coefficients.\r\n */\r\nexport interface TimeUnitDatabase<T extends BaseTimeUnit = BaseTimeUnit> {\r\n\r\n    /**\r\n     * The Moon's orbit approximates an ellipse rather than a circle. However, the orientation (as well as the shape) of\r\n     * this orbit is not fixed. In particular, the position of the extreme points (the line of the apsides: **perigee**\r\n     * and **apogee**), rotates once (**apsidal precession**) in about 3,233 days (8.85 years). It takes the Moon longer\r\n     * to return to the same apsis because it has moved ahead during one revolution.\r\n     *\r\n     * This longer period is called the **anomalistic month** and has an average length of\r\n     * _27 days, 13 hours, 18 minutes, 33.2 seconds_ or `2380713120000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly anomalisticMonth: T;\r\n\r\n    /**\r\n     * The **anomalistic year** is the time taken for the Earth to complete one revolution with respect to its apsides.\r\n     * It is usually defined as the time between **perihelion** passages.\r\n     *\r\n     * Its average duration is _365 days, 6 hours, 13 minutes, 52.6 seconds_ or `31558432550400000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly anomalisticYear: T;\r\n\r\n    /**\r\n     * An **attosecond** is a SI unit of time equal to _0.000000000000000001 second_ or `0.000000001 nanosecond`.\r\n     *\r\n     * For context, an attosecond is to a second what a second is to about 31.71 billion years.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly attosecond: T;\r\n\r\n    /**\r\n     * A **biennium** (plural _biennia_) is a period of _2 years_ or `315360000000000000 nanoseconds`.\r\n     *\r\n     * The word is borrowed from the Latin _biennium_, from _bi-_ (occuring twice) + _annus_ (year).\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly biennium: T;\r\n\r\n    /**\r\n     * A **century** is a period of _100 years_ or `3153600000000000000 nanoseconds`.\r\n     *\r\n     * Centuries are numbered ordinally in English and many other languages. According to the strict construction of the\r\n     * Gregorian calendar, the 1 century began with 1 AD and ended with 100 AD, with the same pattern continuing\r\n     * onward.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly century: T;\r\n\r\n    /**\r\n     * Alias for a [galactic year](#galacticyear).\r\n     *\r\n     * It is equivalent, in average, to _237,5 million years_ or `7489800000000000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly cosmicYear: T;\r\n\r\n    /**\r\n     * A **day** is approximately the period of time during which the Earth completes one rotation with respect to the\r\n     * Sun (aka [solar day](#solarday)). It is commonly designated as a period of _24 hours_ or\r\n     * `86400000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly day: T;\r\n\r\n    /**\r\n     * A **decade** is a period of _10 years_ or `315360000000000000 nanoseconds`.\r\n     *\r\n     * The word is derived from the Ancient Greek:  (dekas), which means a group of ten.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly decade: T;\r\n\r\n    /**\r\n     * A **draconic month** or [nodical month](#nodicalmonth) is the average interval between two successive transits of\r\n     * the Moon through the same node. Because of the torque exerted by the Sun's gravity on the angular momentum of the\r\n     * EarthMoon system, the plane of the Moon's orbit gradually rotates westward, which means the nodes gradually\r\n     * rotate around Earth.\r\n     *\r\n     * As a result, the time it takes the Moon to return to the same node is shorter than a\r\n     * [sidereal month](#siderealmonth), with an average duration of _27 days, 5 hours, 5 minutes, 35.8 seconds_ or\r\n     * `2351135808000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly draconicMonth: T;\r\n\r\n    /**\r\n     * The **draconic year** or [ecliptic year](#eclipticyear) is the time taken for the Sun (as seen from the Earth) to\r\n     * complete one revolution with respect to the same lunar node.\r\n     *\r\n     * The average duration of the eclipse year is _346 days, 14 hours, 52 minutes, 54 seconds_ or\r\n     * `29947974556290000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly draconicYear: T;\r\n\r\n    /**\r\n     * Alias for a [draconic year](#draconicyear).\r\n     *\r\n     * It is equivalent, in average, to _346 days, 14 hours, 52 minutes, 54 seconds_ or `29947974556290000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly eclipticYear: T;\r\n\r\n    /**\r\n     * An **exasecond** is a SI unit of time equal to _1000000000000000000 seconds_ or\r\n     * `1000000000000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _exa_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly exasecond: T;\r\n\r\n    /**\r\n     * An **exasecond** is a SI unit of time equal to _1152921504606846976 seconds_ or\r\n     * `1152921504606846976000000000 nanoseconds`.\r\n     *\r\n     * The prefix _exbi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly exbisecond: T;\r\n\r\n    /**\r\n     * A **femtosecond** is a SI unit of time equal to _0.000000000000001 second_ or `0.000001 nanosecond`.\r\n     *\r\n     * For context, a femtosecond is to a second as a second is to about 31.71 million years.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly femtosecond: T;\r\n\r\n    /**\r\n     * A fortnight is a unit of time equal to _14 days_ or `1209600000000000 nanoseconds`.\r\n     *\r\n     * The word derives from the Old English: _fowertyne niht_, meaning fourteen nights.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly fortnight: T;\r\n\r\n    /**\r\n     * The **galactic year**, also known as [cosmic year](#cosmicyear), is the duration of time required for the Sun to\r\n     * orbit once around the center of the Milky Way Galaxy.\r\n     *\r\n     * Estimates of the length of one orbit range from 225 to 250 million terrestrial years, averaging _237,5 million\r\n     * years_ or `7489800000000000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly galacticYear: T;\r\n\r\n    /**\r\n     * Alias for a [year](#year).\r\n     *\r\n     * It is equivalent to _365 days, 5 hours, 49 minutes, 12 seconds_ or `31556952000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly gregorianYear: T;\r\n\r\n    /**\r\n     * A **gibisecond** is a SI unit of time equal to _1073741824 seconds_ or `1073741824000000000 nanoseconds`.\r\n     *\r\n     * The prefix _gibi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly gibisecond: T;\r\n\r\n    /**\r\n     * A **gigasecond** is a SI unit of time equal to 1000000000 seconds_ or `1000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _giga_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly gigasecond: T;\r\n\r\n    /**\r\n     * An **hour** is a unit of time conventionally reckoned as 124 of a day and scientifically reckoned inbetween\r\n     * 3599 and 3601 seconds, depending on special conditions.\r\n     *\r\n     * For practical purposes, an hour is _3600 seconds_ or `3600000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly hour: T;\r\n\r\n    /**\r\n     * A **jiffy** is the amount of time light takes to travel one _fermi_ (which is about the size of a nucleon) in a\r\n     * vacuum.\r\n     *\r\n     * It is equivalent to `0.000000000000003 nanosecond`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly jiffy: T;\r\n\r\n    /**\r\n     * In astronomy, a **Julian year** is a unit of measurement of time defined as exactly _365.25 days_ of\r\n     * _86400 seconds_ each, or `86400000000000 nanoseconds`.\r\n     *\r\n     * The _Julian calendar_ which has started on different days, at different times, in different countries is equal to\r\n     * either 365 or 366 days.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly julianYear: T;\r\n\r\n    /**\r\n     * A **kibisecond** is a SI unit of time equal to _1024 seconds_ or `1024000000000 nanoseconds`.\r\n     *\r\n     * The prefix _kibi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly kibisecond: T;\r\n\r\n    /**\r\n     * A **kilosecond** is a SI unit of time equal to _1000 seconds_ or `1000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _kilo_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly kilosecond: T;\r\n\r\n    /**\r\n     * Alias for a [millenium](#millenium).\r\n     *\r\n     * It is equivalent to _1000 years_ or `31536000000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly kiloyear: T;\r\n\r\n    /**\r\n     * A **leap year** (also known as an intercalary year or bissextile year) is a calendar year containing one\r\n     * additional day added to keep the calendar year synchronized with the _astronomical_ or _seasonal year_.\r\n     *\r\n     * Each leap year has _366 days_ or `31622400000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly leapYear: T;\r\n\r\n    /**\r\n     * Alias for a [draconic month](#draconicmonth).\r\n     *\r\n     * It is equivalent, in average, to _27 days, 5 hours, 5 minutes, 35.8 seconds_ or `2351135808000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly nodicalMonth: T;\r\n\r\n    /**\r\n     * A **non-leap year** occurs every three out of four years, the remaining one being a [leap year](#leapyear).\r\n     *\r\n     * Each non-leap year has _365 days_ or `31536000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly nonLeapYear: T;\r\n\r\n    /**\r\n     * A **lustrum** (plural _lustra_) was a term for a five-year period in Ancient Rome and is equivalent to a\r\n     * [quinquennium](#quinquennium), which is _5 years_ or `157680000000000000 nanoseconds`.\r\n     *\r\n     * The _lustration_ was originally a sacrifice for expiation and purification offered by one of the censors in the\r\n     * name of the Roman people at the close of the taking of the census. The sacrifice was often in the form of an\r\n     * animal sacrifice, known as a _suovetaurilia_.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly lustrum: T;\r\n\r\n    /**\r\n     * A **mebisecond** is a SI unit of time equal to _1048576 seconds_ or `1048576000000000 nanoseconds`.\r\n     *\r\n     * The prefix _mebi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly mebisecond: T;\r\n\r\n    /**\r\n     * A **megasecond** is a SI unit of time equal to _1000000 seconds_ or `1000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _mega_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly megasecond: T;\r\n\r\n    /**\r\n     * A **microsecond** is a SI unit of time equal to _0.000001 second_ or `1000 nanoseconds`.\r\n     *\r\n     * The prefix _micro_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly microsecond: T;\r\n\r\n    /**\r\n     * A **milisecond** is a SI unit of time equal to _0.001 second_ or `1000000 nanoseconds`.\r\n     *\r\n     * The prefix _mili_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly milisecond: T;\r\n\r\n    /**\r\n     * A **millennium** (plural _millennia_) is a period equal to _1000 years_ or `31536000000000000000 nanoseconds`,\r\n     * also known as [kiloyear](#kiloyear).\r\n     *\r\n     * Sometimes, it is used specifically for periods of a thousand years that begin at the starting point (initial\r\n     * reference point) of the calendar in consideration (typically the year \"1\"), or in later years that are whole\r\n     * number multiples of a thousand years after it.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly millenium: T;\r\n\r\n    /**\r\n     * A minute is equal to 160 (the first sexagesimal fraction) of an hour, _60 seconds_ or `60000000000 nanoseconds`.\r\n     *\r\n     * In the UTC time standard, a minute on rare occasions has 61 seconds, a consequence of _leap seconds_.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly minute: T;\r\n\r\n    /**\r\n     * A **month** is an unit of time used with calendars, which is approximately as long as a natural period related to\r\n     * the motion of the Moon.\r\n     *\r\n     * In Gregorian calendars, a month is in average _30.41666666667 days_ or `2628000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly month: T;\r\n\r\n    /**\r\n     * A **nanosecond** is a SI unit of time equal to _0.000000001 second_. This is the **standard unit** of timecount.\r\n     *\r\n     * The prefix _nano_ means 10. Time units of this granularity are commonly encountered in telecommunications,\r\n     * pulsed lasers, and related aspects of electronics.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly nanosecond: T;\r\n\r\n    /**\r\n     * A **novennium** (plural _novennia_) is a period equivalent to _9 years_ or `283824000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly novennium: T;\r\n\r\n    /**\r\n     * An **octennium** (plural _octennia_) is a period equivalent to _8 years_ or `252288000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly octennium: T;\r\n\r\n    /**\r\n     * A **pebisecond** is a SI unit of time equal to _1125899906842624 seconds_ or\r\n     * `1125899906842624000000000 nanoseconds`.\r\n     *\r\n     * The prefix _pebi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly pebisecond: T;\r\n\r\n    /**\r\n     * A **petasecond** is a SI unit of time equal to _1000000000000000 seconds_ or\r\n     * `1000000000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _peta_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly petasecond: T;\r\n\r\n    /**\r\n     * A **picosecond** is a SI unit of time equal to _0.000000000001 second_ or `0.001 nanosecond`.\r\n     *\r\n     * A picosecond is to one second as one second is to approximately 31,689 years.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly picosecond: T;\r\n\r\n    /**\r\n     * The **Planck time** is the unit of time in the system of natural units known as _Planck units_. A Planck unit is\r\n     * the time required for light to travel in a vacuum a distance of 1 _Planck length_.\r\n     *\r\n     * It is equivalent to _5.39056  10 second_ or `0.0000000000000000000000000000000000539056 nanosecond`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly planckTime: T;\r\n\r\n    /**\r\n     * A **quadrennium** (plural _quadrennia_) is a period of _4 years_ or `630720000000000000 nanoseconds`.\r\n     *\r\n     * It is most commonly used in reference to the four-year period between each Olympic Games. It is also used in\r\n     * reference to the four-year interval between [leap years](#leapyear).\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly quadrennium: T;\r\n\r\n    /**\r\n     * A **quindecennium** (plural _quindecennia_) is a period equivalent to _15 years_ or\r\n     * `473040000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly quindecennium: T;\r\n\r\n    /**\r\n     * A **quinquennium** (plural _quinquennia_) is a period equivalent to _5 years_, a [lustrum](#lustrum), or\r\n     * `157680000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly quinquennium: T;\r\n\r\n    /**\r\n     * The **second** is the SI base unit of time, commonly understood and historically defined as / of a day \r\n     * this factor derived from the division of the day first into 24 hours, then to 60 minutes and finally to 60\r\n     * seconds each.\r\n     *\r\n     * It is equivalent to `1000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly second: T;\r\n\r\n    /**\r\n     * A **septennium** (plural _septennia_) is a period equivalent to _7 years_ or `220752000000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly septennium: T;\r\n\r\n    /**\r\n     * A **shake** is an informal unit of time equal to `10 nanoseconds`.\r\n     *\r\n     * It has applications in _nuclear physics_, helping to conveniently express the timing of various events in a\r\n     * nuclear explosion.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly shake: T;\r\n\r\n    /**\r\n     * _Sidereal time_ is a timekeeping system that astronomers use to locate celestial objects. It is the angle,\r\n     * measured along the celestial equator, from the observer's meridian to the great circle that passes through the\r\n     * March equinox and both celestial poles, and is usually expressed in hours, minutes, and seconds.\r\n     *\r\n     * Using sidereal time, it is possible to easily point a telescope to the proper coordinates in the night sky.\r\n     *\r\n     * A **sidereal day** is approximately _23 hours, 56 minutes, 4.0905 seconds_ or `86164090000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealDay: T;\r\n\r\n    /**\r\n     * _Sidereal time_ is a timekeeping system that astronomers use to locate celestial objects. It is the angle,\r\n     * measured along the celestial equator, from the observer's meridian to the great circle that passes through the\r\n     * March equinox and both celestial poles, and is usually expressed in hours, minutes, and seconds.\r\n     *\r\n     * Using sidereal time, it is possible to easily point a telescope to the proper coordinates in the night sky.\r\n     *\r\n     * A **sidereal hour** is approximately _59 minutes, 50.17041666672 seconds_ or `3590170416667 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealHour: T;\r\n\r\n    /**\r\n     * _Sidereal time_ is a timekeeping system that astronomers use to locate celestial objects. It is the angle,\r\n     * measured along the celestial equator, from the observer's meridian to the great circle that passes through the\r\n     * March equinox and both celestial poles, and is usually expressed in hours, minutes, and seconds.\r\n     *\r\n     * Using sidereal time, it is possible to easily point a telescope to the proper coordinates in the night sky.\r\n     *\r\n     * A **sidereal minute** is approximately _59.983617361111 seconds_ or `599836173611.11 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealMinute: T;\r\n\r\n    /**\r\n     * The period of the Moon's orbit as defined with respect to the celestial sphere of apparently fixed stars\r\n     * (nowadays the _International Celestial Reference Frame_) is known as a **sidereal month** because it is the time\r\n     * it takes the Moon to return to a similar position among the stars.\r\n     *\r\n     * It is approximately _27 days, 7 hours, 43 minutes, 11.6 seconds_ or `2360591424000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealMonth: T;\r\n\r\n    /**\r\n     * _Sidereal time_ is a timekeeping system that astronomers use to locate celestial objects. It is the angle,\r\n     * measured along the celestial equator, from the observer's meridian to the great circle that passes through the\r\n     * March equinox and both celestial poles, and is usually expressed in hours, minutes, and seconds.\r\n     *\r\n     * Using sidereal time, it is possible to easily point a telescope to the proper coordinates in the night sky.\r\n     *\r\n     * A **sidereal second** is approximately _0.9972695601852 second_ or `997269560.1852 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealSecond: T;\r\n\r\n    /**\r\n     * A **sidereal year** is the time taken by the Earth to orbit the Sun once with respect to the fixed stars. Hence\r\n     * it is also the time taken for the Sun to return to the same position with respect to the fixed stars after\r\n     * apparently travelling once around the ecliptic.\r\n     *\r\n     * It is approximately _365 days, 6 hours, 9 minutes, 9.504 seconds_ or `31558149540000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly siderealYear: T;\r\n\r\n    /**\r\n     * Alias for a [day](#day).\r\n     *\r\n     * It is equivalent, in average, to _86400 seconds_ or `86400000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly solarDay: T;\r\n\r\n    /**\r\n     * Alias for a [tropical year](#tropicalyear).\r\n     *\r\n     * It is equivalent, in average, to _31556930 seconds_ or `31556930000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly solarYear: T;\r\n\r\n    /**\r\n     * The **Svedberg** is a time unit used for sedimentation rates (usually of proteins).\r\n     *\r\n     * It is defined as _100 femtoseconds_ or `0.0001 nanosecond`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly svedberg: T;\r\n\r\n    /**\r\n     * The **synodic month** is the average period of the Moon's orbit with respect to the line joining the Sun and\r\n     * Earth. It is is used to calculate eclipse cycles.\r\n     *\r\n     * Its long-term average duration is _29 days, 12 hours, 44 minutes, 2.8016 seconds_ or\r\n     * `2551443840000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly synodicMonth: T;\r\n\r\n    /**\r\n     * A **tebisecond** is a SI unit of time equal to 1099511627776 seconds_ or `1099511627776000000000 nanoseconds`.\r\n     *\r\n     * The prefix _tebi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly tebisecond: T;\r\n\r\n    /**\r\n     * A **terasecond** is a SI unit of time equal to 1000000000000 seconds_ or `1000000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _tera_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly terasecond: T;\r\n\r\n    /**\r\n     * A **time unit** (TU) is an unit of time defined as _1024 microseconds_ or `1024000 nanoseconds`.\r\n     *\r\n     * The unit allows for maintaining intervals that are easy to implement in hardware that has a 1 MHz clock. One Time\r\n     * Unit is equal to one millionth of a [kibisecond](#kibisecond).\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly timeUnit: T;\r\n\r\n    /**\r\n     * A **tropical year** (also known as a [solar year](#solaryear)) is the time that the Sun takes to return to the\r\n     * same position in the cycle of seasons, as seen from Earth; for example, the time from vernal equinox to vernal\r\n     * equinox, or from summer solstice to summer solstice.\r\n     *\r\n     * It is approximetaly _365 days, 5 hours, 48 minutes, 43.488 seconds_ or `31556930000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly tropicalYear: T;\r\n\r\n    /**\r\n     * A **week** is a time unit equal to _7 days_ or `604800000000000 nanoseconds`.\r\n     *\r\n     * It is the standard time period used for cycles of rest days in most parts of the world, mostly alongside \r\n     * although not strictly part of  the Gregorian calendar.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly week: T;\r\n\r\n    /**\r\n     * For the Gregorian calendar, the average length of the calendar year (the mean year) across the complete leap\r\n     * cycle of 400 years is _365 days, 5 hours, 49 minutes, 12 seconds_ (365.2425 days) or\r\n     * `31556952000000000 nanoseconds`.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly year: T;\r\n\r\n    /**\r\n     * A **yobisecond** is a SI unit of time equal to _1208925819614629174706176 seconds_ or\r\n     * `1208925819614629174706176000000000 nanoseconds`.\r\n     *\r\n     * The prefix _yobi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly yobisecond: T;\r\n\r\n    /**\r\n     * A **yoctosecond** is a SI unit of time equal to _0.000000000000000000000001 second_ or\r\n     * `0.0000000000000001 nanosecond`.\r\n     *\r\n     * The prefix _yocto_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly yoctosecond: T;\r\n\r\n    /**\r\n     * A **yottasecond** is a SI unit of time equal to _1000000000000000000000000 seconds_ or\r\n     * `1000000000000000000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _yotta_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly yottasecond: T;\r\n\r\n    /**\r\n     * A **zebisecond** is a SI unit of time equal to _1180591620717411303424 seconds_ or\r\n     * `1180591620717411303424000000000 nanoseconds`.\r\n     *\r\n     * The prefix _zebi_ means 2.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly zebisecond: T;\r\n\r\n    /**\r\n     * A **zeptosecond** is a SI unit of time equal to _0.000000000000000000001 second_ or\r\n     * `0.000000000000000000000000000001 nanosecond`.\r\n     *\r\n     * The prefix _zepto_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly zeptosecond: T;\r\n\r\n    /**\r\n     * A **zeptosecond** is a SI unit of time equal to _1000000000000000000000 seconds_ or\r\n     * `1000000000000000000000000000000 nanoseconds`.\r\n     *\r\n     * The prefix _zetta_ means 10.\r\n     *\r\n     * ---\r\n     *\r\n     * [Back to top](#)\r\n     */\r\n    readonly zettasecond: T;\r\n}\r\n\r\n/**\r\n * A union type, used by parameters that accept either the name of a time unit or a\r\n * [time unit object](../interfaces/_index_.timeunit.html).\r\n *\r\n * @deprecated Since v1.1.0 - In favor of `TimeUnitSource` (will be removed in v2).\r\n */\r\nexport type TimeUnitParameter = keyof TimeUnitDatabase | TimeUnit;\r\n\r\n/**\r\n * A union type, used by parameters that accept either the name of a time unit or a\r\n * [time unit object](../interfaces/_index_.timeunit.html).\r\n *\r\n * The accepted names are the properties defined by [TimeUnitDatabase](../interfaces/_index_.timeunitdatabase.html), but\r\n * case-insensitive and plural variations are also valid (even though TypeScript would not allow it).\r\n */\r\nexport type TimeUnitSource = keyof TimeUnitDatabase | TimeUnit;\r\n\r\n/**\r\n * This type is a union of all accepted types that can be used to represent a time value: a _string_ that parses to a\r\n * number (e.g. \"1000\" or \"1e-10\"), a [big decimal](https://www.npmjs.com/package/decimal.js) or a _number_.\r\n */\r\nexport type TimeValueSource = string | number | Decimal;\r\n\r\n/**\r\n * Time writers are objects used to synthesize time values into strings, i.e. write times using different lexical and\r\n * numerical configurations. **[Write](#write)** is used to express a single time value, using a single time unit;\r\n * **[countdown](#countdown)** is used to classify time values by segmenting them into parts with different time units.\r\n *\r\n * These configurations are loaded in the following order:\r\n * - Defaults  hardcoded for English (US);\r\n * - Options from the current [Locale](_localization_.locale.html);\r\n * - Options from the instance [settings](#settings);\r\n * - Options given as a parameter to a method.\r\n *\r\n * ---\r\n *\r\n * [[include:examples/timewriter.md]]\r\n */\r\nexport class TimeWriter {\r\n\r\n    private _shouldApproximate = true;\r\n\r\n    /**\r\n     * Initializes a new instance of the [TimeWriter](#) class optionally using the given configurations.\r\n     *\r\n     * @param settings\r\n     *   Configurations pertaining to this instance, overriding those of the\r\n     *   [locale](_localization_.locale.html#writerOptions). May be overriden via parameter of [write](#write) or\r\n     *   [countdown](#countdown).\r\n     */\r\n    public constructor(public settings: TimeWriterSettings = {}) { }\r\n\r\n    //#region Countdown Method\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * This \"overload\" will always use [TIME_SEGMENTS_COMMON](../modules/_index_.html#time_segments_common) as source\r\n     * for its time unit conversions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `countdown`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param args\r\n     *   Accepts any number of time units or array of time units (if repetitions are given, they will be singled out).\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, ... args: Array<TimeUnitSource | TimeUnitSource[]>): string;\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param args\r\n     *   Accepts any number of time units or array of time units (if repetitions are given, they will be singled out).\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, ... args: Array<string | TimeUnit | string[]>): string;\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `countdown`. It does not change the object in any way whatsoever.\r\n     * @param args\r\n     *   Accepts any number of time units or array of time units (if repetitions are given, they will be singled out).\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, options?: TimeWriterSettings,\r\n        ... args: Array<string | TimeUnit | string[]>): string;\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `countdown`. It does not change the object in any way whatsoever.\r\n     * @param args\r\n     *   Accepts any number of time units or array of time units (if repetitions are given, they will be singled out).\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, options?: TimeWriterSettings,\r\n        ... args: Array<TimeUnitSource | TimeUnitSource[]>): string;\r\n\r\n    /**\r\n     * Writes a time length segmented into multiple units using a [Time](_index_.time.html) object and, optionally,\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * This will produce explanations of time lengths much easier to understand than arbitrary fractions.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `countdown`. It does not change the object in any way whatsoever.\r\n     * @param args\r\n     *   Accepts any number of time units or array of time units (if repetitions are given, they will be singled out).\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time through the use of multiple units of time.\r\n     */\r\n    public countdown(time: Time, options?: TimeWriterSettings | TimeUnitSource,\r\n        ... args: Array<string | TimeUnit | string[]>): string;\r\n\r\n    // Actual `countdown` implementation\r\n    public countdown(time: Time,\r\n        options: TimeWriterSettings | TimeUnitSource | TimeUnitSource[] | string | string[] = {},\r\n        ... args: Array<TimeUnitSource | TimeUnitSource[] | string | string[]>) {\r\n\r\n        const timeUnitNames: string[] = [];\r\n        const timeUnitObjects: NamedTimeUnit[] = [];\r\n\r\n        if (typeof(options) === \"string\" || options.hasOwnProperty(\"factor\")) {\r\n            args = [options as TimeUnitSource].concat(args as TimeUnitSource[]);\r\n            options = {};\r\n        }\r\n\r\n        if (options instanceof Array) {\r\n            args = (options as any).concat(args);\r\n            options = {};\r\n        }\r\n\r\n        // If no time units were given, use the \"common\" constant\r\n        if (args.length === 0) {\r\n            args = TimeSegments.common;\r\n        }\r\n\r\n        // Selects all arrays passed as argument\r\n        const arrayArgs = args.filter(e => e instanceof Array);\r\n        const filtered = args.filter(e => !(e instanceof Array));\r\n\r\n        // Replaces arrays by their elements on args\r\n        arrayArgs.forEach(array => { filtered.push.apply(filtered, array); });\r\n        args = filtered;\r\n\r\n        for (const argument of args) {\r\n            const timeUnit = timeUnitFromSource(argument as TimeUnitSource);\r\n\r\n            // Skipping repeated units\r\n            if (timeUnitNames.indexOf(timeUnit.name) > -1) {\r\n                continue;\r\n            }\r\n\r\n            timeUnitNames.push(timeUnit.name);\r\n            timeUnitObjects.push(timeUnit);\r\n        }\r\n\r\n        options = this._combineOptions(options as TimeWriterSettings);\r\n        return this._countdownTime(time, timeUnitObjects, options);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region Write Method\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, configurations that may override\r\n     * those of the [Locale](_localization_.locale.html) and the instance, for the duration of the method.\r\n     *\r\n     * This will use the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) (which falls\r\n     * back to \"nanoseconds\") as both input (when time is numeric) and output time unit.\r\n     *\r\n     * @param time\r\n     *   A numeric representation of a time value -or- an encapsulated nanosecond-based time.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(time: TimeValueSource | Time, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(time: Time, toTimeUnit?: TimeUnitSource, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration of the method.\r\n     *\r\n     * @param time\r\n     *   An encapsulated nanosecond-based time.\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\". Accepts plurals and case variations.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(time: Time, toTimeUnit?: string | TimeUnit, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param timeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, timeUnit?: TimeUnitSource, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param timeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, timeUnit?: string | TimeUnit, options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param fromTimeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, fromTimeUnit?: TimeUnitSource, toTimeUnit?: TimeUnitSource,\r\n        options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param fromTimeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\". Accepts plurals and case variations.\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, fromTimeUnit?: string | TimeUnit, toTimeUnit?: TimeUnitSource,\r\n        options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param fromTimeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\".\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\". Accepts plurals and case variations.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, fromTimeUnit?: TimeUnitSource, toTimeUnit?: string | TimeUnit,\r\n        options?: TimeWriterSettings): string;\r\n\r\n    /**\r\n     * Writes a time value using a [Time](_index_.time.html) object and, optionally, a time unit to transform it and\r\n     * configurations that may override those of the [Locale](_localization_.locale.html) and the instance, for the\r\n     * duration the method.\r\n     *\r\n     * @param timeValue\r\n     *   A numeric representation of a time value.\r\n     * @param fromTimeUnit\r\n     *   Time unit from which the given time value will be converted. If this parameter is not passed, it fallbacks to\r\n     *   the [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\". Accepts plurals and case variations.\r\n     * @param toTimeUnit\r\n     *   Time unit to which the given time will be converted. If this parameter is not passed, it fallbacks to the\r\n     *   [default time unit](../interfaces/_index_.timewritersettings.html#defaulttimeunit) and ultimately to\r\n     *   \"nanoseconds\". Accepts plurals and case variations.\r\n     * @param options\r\n     *   When given, these configurations will override the those of the [Locale](_localization_.locale.html) and the\r\n     *   instance, for this specific `write`. It does not change the object in any way whatsoever.\r\n     * @return\r\n     *   A string containing a synthetic representation of the given time.\r\n     */\r\n    public write(timeValue: TimeValueSource, fromTimeUnit?: string | TimeUnit, toTimeUnit?: string | TimeUnit,\r\n        options?: TimeWriterSettings): string;\r\n\r\n    // Actual `write` implementation\r\n    public write(time: TimeValueSource | Time, fromTimeUnit?: TimeUnitSource | TimeWriterSettings | string,\r\n        toTimeUnit?: TimeUnitSource | TimeWriterSettings | string, options?: TimeWriterSettings) {\r\n\r\n        const isOptions = (object: any) => typeof(object) === \"object\" && !object.hasOwnProperty(\"factor\");\r\n\r\n        if (!options && isOptions(fromTimeUnit)) {\r\n            options = fromTimeUnit as TimeWriterSettings;\r\n            fromTimeUnit = toTimeUnit;\r\n            toTimeUnit = undefined;\r\n        }\r\n\r\n        if (!options && isOptions(toTimeUnit)) {\r\n            options = toTimeUnit as TimeWriterSettings;\r\n            toTimeUnit = undefined;\r\n        }\r\n\r\n        options = this._combineOptions(options);\r\n\r\n        fromTimeUnit = (fromTimeUnit || options.defaultTimeUnit || \"nanosecond\") as TimeUnitSource;\r\n        toTimeUnit = (toTimeUnit || fromTimeUnit) as TimeUnitSource;\r\n\r\n        if (!(time instanceof Time)) {\r\n            time = Time.from(time, fromTimeUnit);\r\n        }\r\n\r\n        return this._writeTime(time, options, toTimeUnit);\r\n    }\r\n    //#endregion\r\n\r\n    // Gets the options overriden in the correct order\r\n    private _combineOptions(options: TimeWriterSettings | undefined) {\r\n\r\n        options = merge(defaultSettings, Locale.settings.writerOptions, this.settings, options);\r\n\r\n        // Deprecated properties will be removed on next major release, but for now, parse them\r\n\r\n        options.decimalPlaces = typeof(options.decimalPlaces) === \"number\"\r\n            ? options.decimalPlaces\r\n            : options.fractionDigits;\r\n\r\n        if (options.timeUnitSeparator === defaultSettings.timeUnitSeparator && options.spaceTimeUnit === false) {\r\n            options.timeUnitSeparator = \"\";\r\n        }\r\n\r\n        if (options.terms) {\r\n            options.termApproximately = options.termApproximately || options.terms.approximately;\r\n            options.termInfinite = options.termInfinite || options.terms.infinite;\r\n            options.termNaN = options.termNaN || options.terms.nan;\r\n        }\r\n\r\n        return options;\r\n    }\r\n\r\n    // Count and writes times unit-by-unit\r\n    private _countdownTime(time: Time, timeUnitList: NamedTimeUnit[], options: TimeWriterSettings) {\r\n\r\n        let value: Decimal = new Decimal(0);\r\n        let integer: Decimal = new Decimal(0);\r\n        let fraction: Decimal = new Decimal(0);\r\n\r\n        const update = (total: Decimal) => { value = total, integer = value.trunc(), fraction = value.minus(integer); };\r\n\r\n        // Sorts the time units from largest factor to smallest\r\n        timeUnitList.sort((a, b) => b.factor.comparedTo(a.factor));\r\n\r\n        // Sets the value to the representation of the first time unit\r\n        update(time.toBig(timeUnitList[0]));\r\n\r\n        const result: string[] = [];\r\n\r\n        for (let i = 1; i < timeUnitList.length; i += 1) {\r\n            const previousTimeUnit = timeUnitList[i - 1];\r\n\r\n            if ((integer.comparedTo(0) !== 0 || options.hideZeroSegments === false) &&\r\n                (!integer.isNaN() || result.length === 0)) {\r\n\r\n                const parsedTime = time.isApproximated || previousTimeUnit.approximated\r\n                    ? Time.from(integer, previousTimeUnit).approximate()\r\n                    : Time.from(integer, previousTimeUnit);\r\n\r\n                // Adding the current segment\r\n                result.push(this.write(parsedTime, previousTimeUnit, options));\r\n\r\n                // Preventing `write` from writting the approximation symbol / name\r\n                if (parsedTime.isApproximated || previousTimeUnit.approximated) {\r\n                    this._shouldApproximate = false;\r\n                }\r\n            }\r\n\r\n            update(Time.from(fraction, previousTimeUnit).toBig(timeUnitList[i]));\r\n        }\r\n\r\n        const timeUnit = timeUnitList[timeUnitList.length - 1];\r\n\r\n        if ((value.comparedTo(0) !== 0 || options.hideZeroSegments === false) &&\r\n            (!value.isNaN() || result.length === 0)) {\r\n\r\n            if (timeUnit.factor.equals(\"5.39056e-35\")) {\r\n                // Planck time is teoretically indivisible\r\n                result.push(this.write(value.round(), timeUnit, options));\r\n            } else {\r\n                // Adds the last segment in its entirety (no integer-only)\r\n                result.push(this.write(value, timeUnit, options));\r\n            }\r\n        }\r\n\r\n        this._shouldApproximate = true;\r\n        return result.join(options.segmentSeparator || \"\");\r\n    }\r\n\r\n    // Parses numeric options and returns the numeric string\r\n    private _writeNumber(value: Decimal, options: TimeWriterSettings) {\r\n\r\n        if (value.isNaN()) {\r\n            return (options.verbose ? options.termNaN : options.symbolNaN) || \"\";\r\n        }\r\n\r\n        if (!value.isFinite()) {\r\n            return (options.verbose ? options.termInfinite : options.symbolInfinite) || \"\";\r\n        }\r\n\r\n        if (options.numericNotation === \"roman\") {\r\n            return writeRoman(value);\r\n        }\r\n\r\n        if (options.numericNotation === \"roman-fractions\") {\r\n            return writeRoman(value, true);\r\n        }\r\n\r\n        const parameters = [options.decimalPlaces, options.roundingMode];\r\n        let stringValue: string;\r\n\r\n        if (options.significantDigits) {\r\n            const offset = value.trunc().precision(true);\r\n            value = value.toSignificantDigits(options.significantDigits + offset, options.roundingMode as any);\r\n        }\r\n\r\n        if (options.numericNotation === \"scientific\") {\r\n            stringValue = value.toExponential.apply(value, parameters);\r\n        } else {\r\n            stringValue = value.toFixed.apply(value, parameters);\r\n        }\r\n\r\n        // Parsing the thousands separator only for decimals and values >= 1000\r\n        if (options.numericNotation === \"decimal\" && options.thousandsSeparator && value.comparedTo(1000) >= 0) {\r\n            const parts = stringValue.split(localeDecimalSeparator);\r\n            parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, options.thousandsSeparator);\r\n\r\n            if (parts.length === 2) {\r\n                stringValue = parts.join(localeDecimalSeparator);\r\n            } else {\r\n                stringValue = parts[0];\r\n            }\r\n        }\r\n\r\n        if (typeof(options.decimalSeparator) === \"string\" && options.decimalSeparator !== localeDecimalSeparator) {\r\n            stringValue = replaceLast(stringValue, localeDecimalSeparator, options.decimalSeparator);\r\n        }\r\n\r\n        return stringValue;\r\n    }\r\n\r\n    // Parses time-related options and return the time string\r\n    private _writeTime(time: Time, options: TimeWriterSettings, targetTimeUnit: string | TimeUnit) {\r\n\r\n        const namedTimeUnit = timeUnitFromSource(targetTimeUnit || options.defaultTimeUnit || \"nanosecond\");\r\n        const translation = Locale.settings.timeUnits ? Locale.settings.timeUnits[namedTimeUnit.name] : {};\r\n        const value = time.toBig(targetTimeUnit);\r\n\r\n        const timeUnit = merge(namedTimeUnit, translation) as NamedTimeUnit;\r\n        const result: string[] = [];\r\n\r\n        // Part 1: approximation term/symbol\r\n        if (this._shouldApproximate && (time.isApproximated || namedTimeUnit.approximated)) {\r\n            const approximately = !!options.verbose\r\n                ? options.termApproximately ? options.termApproximately + \" \" : \"\"\r\n                : options.symbolApproximately;\r\n\r\n            result.push(approximately || \"\");\r\n        }\r\n\r\n        // Part 2: number\r\n        if (!options.numericWriter) {\r\n            result.push(this._writeNumber(value, options));\r\n        } else {\r\n            result.push(options.numericWriter(value.toNumber(), value));\r\n        }\r\n\r\n        // Part 3: separator\r\n        if (!options.hideTimeUnit) {\r\n            result.push(options.timeUnitSeparator || \"\");\r\n\r\n        // Part 4: time unit\r\n        } else {\r\n            return filterEmpty(result).join(\"\");\r\n        }\r\n\r\n        const pluralize = timeUnit.pluralize !== false && (!value.isFinite() || value.comparedTo(1) > 0);\r\n        result.push(this._writeTimeUnit(value, timeUnit, options, pluralize));\r\n        return filterEmpty(result).join(\"\");\r\n    }\r\n\r\n    // Parses time unit-related options and returns the time unit string\r\n    private _writeTimeUnit(value: Decimal, timeUnit: NamedTimeUnit, options: TimeWriterSettings, plural: boolean) {\r\n        const result: string[] = [];\r\n\r\n        if (!options.verbose && timeUnit.symbol) {\r\n            result.push(timeUnit.symbol);\r\n            return filterEmpty(result).join(\"\");\r\n        }\r\n\r\n        let timeUnitName = timeUnit.readableName;\r\n\r\n        if (plural && typeof(timeUnit.customPlural) === \"function\") {\r\n            timeUnitName = timeUnit.customPlural(value.toNumber(), value);\r\n        }\r\n\r\n        if (plural && typeof(timeUnit.customPlural) === \"string\") {\r\n            timeUnitName = timeUnit.customPlural;\r\n        }\r\n\r\n        if (typeof(timeUnitName) === \"undefined\") {\r\n            timeUnitName = timeUnit.name.replace(/([a-z])([A-Z])/g, \"$1 $2\").toLowerCase();\r\n        }\r\n\r\n        if (plural && !timeUnit.customPlural) {\r\n            timeUnitName += \"s\";\r\n        }\r\n\r\n        result.push(timeUnitName);\r\n        return filterEmpty(result).join(\"\");\r\n    }\r\n}\r\n\r\n/**\r\n * Objects of this type are used to configure the behavior of [time writers](../classes/_index_.timewriter.html).\r\n *\r\n * Using these objects it is possible to change the lexical and numerical output to fit many different scenarios. See\r\n * the documentation for each property for more information.\r\n */\r\nexport interface TimeWriterSettings {\r\n\r\n    /**\r\n     * Numer of decimal places resulting from time conversions. Used in conjunction with [roundingMode] to write numeric\r\n     * values\r\n     *\r\n     * Default: `undefined`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/decimalPlaces.md]]\r\n     */\r\n    decimalPlaces?: number;\r\n\r\n    /**\r\n     * String used as decimal separator, specially useful when translating to languages and regions where the \"dot\"\r\n     * notation is not standard.\r\n     *\r\n     * If not set, time writers will first try to parse the decimal separator for the locale of the machine where the\r\n     * script is running and will ultimately fallback to `\".\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/decimalSeparator.md]]\r\n     */\r\n    decimalSeparator?: string;\r\n\r\n    /**\r\n     * Specifies the default unit to convert to when writing time values.\r\n     *\r\n     * Default is [nanosecond](_index_.timeunitdatabase.html#nanosecond).\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/defaultTimeUnit.md]]\r\n     */\r\n    defaultTimeUnit?: TimeUnitSource;\r\n\r\n    /**\r\n     * **This property is no longer supported!** When given, this will be used as the fixed number of decimal digits.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `significantDigits` (will be removed in v2).\r\n     */\r\n    fractionDigits?: number;\r\n\r\n    /**\r\n     * When this property is set to true, it will prevent the time writer from writting any form of time unit, be it\r\n     * plural, symbol or verbose. It will also prevent the output of the [time unit separator](#timeunitseparator).\r\n     *\r\n     * Default is `false`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/hideTimeUnit.md]]\r\n     */\r\n    hideTimeUnit?: boolean;\r\n\r\n    /**\r\n     * Whether to hide [countdown](../classes/_index.timewriter.html#countdown) segments with a value of 0 (zero).\r\n     *\r\n     * Default is `true`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/hideZeroSegments.md]]\r\n     */\r\n    hideZeroSegments?: boolean;\r\n\r\n    /**\r\n     * Numeric notation used to write time values. Accepted values are:\r\n     * - **\"decimal\":** standard _HinduArabic numeral system_ using base ten;\r\n     * - **\"roman\":** _Ancient Rome_ numeral system, ignoring fractions;\r\n     * - **\"roman-fractions\":** _Ancient Rome_ numeral system, using\r\n     *   [common fractions](https://en.wikipedia.org/wiki/Roman_numerals#Fractions);\r\n     * - **\"scientific\":** Exponent notation; writes very small and very large numbers using powers of 10.\r\n     *\r\n     * Default is `\"decimal\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/numericNotation.md]]\r\n     */\r\n    numericNotation?: NumericNotation;\r\n\r\n    /**\r\n     * This can be set to a function that will replace all other forms of numeric writting, ignoring the\r\n     * [numeric notation](#numericnotation) and other mathematical properties.\r\n     *\r\n     * This function may receive two parameters: a number and an optional\r\n     * [big decimal](https://www.npmjs.com/package/decimal.js).\r\n     *\r\n     * Default is `undefined`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/numericWriter.md]]\r\n     */\r\n    numericWriter?: NumericWriter;\r\n\r\n    /**\r\n     * Numeric [rounding mode](../enums/_index_.roundingmode.html) used by the writer.\r\n     *\r\n     * Default is `RoundingMode.RoundHalfUp` or `4`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/roundingMode.md]]\r\n     */\r\n    roundingMode?: RoundingMode;\r\n\r\n    /**\r\n     * A string used to separate [countdown](../classes/_index.timewriter.html#countdown) segments.\r\n     *\r\n     * Default is `\", \"` (comma and space).\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/segmentSeparator.md]]\r\n     */\r\n    segmentSeparator?: string;\r\n\r\n    /**\r\n     * **This property is no longer supported!** Whether to separate the numeric value from the time unit.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `timeUnitSeparator` (will be removed in v2).\r\n     */\r\n    spaceTimeUnit?: boolean;\r\n\r\n    /**\r\n     * Number of significant digits of the decimal part of numeric values, intended to minimize the quantity of written\r\n     * numbers for very large conversions.\r\n     *\r\n     * It will enforce a precision of the specified magnitude, but only for the decimal part of the number, unlike\r\n     * [decimal.js precision](https://mikemcl.github.io/decimal.js/#sd). It doesn't apply to leading zeros.\r\n     *\r\n     * Default: `10`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/significantDigits.md]]\r\n     */\r\n    significantDigits?: number;\r\n\r\n    /**\r\n     * When writting time values or units which based on approximations, this symbol will be added before the number to\r\n     * demonstrate the approximation, when [verbose](#verbose) is disabled. Otherwise, its [term](#termapproximately) is\r\n     * used instead.\r\n     *\r\n     * Default: `\"\"` (_almost equal to_ symbol).\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/symbolApproximately.md]]\r\n     */\r\n    symbolApproximately?: string;\r\n\r\n    /**\r\n     * When writting time values that represent an _Infinity_, this symbol will be used to express it, when\r\n     * [verbose](#verbose) is disabled. Otherwise, its [term](#terminfinite) is used instead.\r\n     *\r\n     * Default: `\"\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/symbolInfinite.md]]\r\n     */\r\n    symbolInfinite?: string;\r\n\r\n    /**\r\n     * When writting time values that represent a _NaN_ (not a number), this symbol will be used to express it, when\r\n     * [verbose](#verbose) is disabled. Otherwise, its [term](#termnan) is used instead.\r\n     *\r\n     * Default: `\"NaN\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/symbolNaN.md]]\r\n     */\r\n    symbolNaN?: string;\r\n\r\n    /**\r\n     * When writting time values or units which based on approximations, this string will be added before the number to\r\n     * demonstrate the approximation, when [verbose](#verbose) is enabled. Otherwise, its [symbol](#symbolapproximately)\r\n     * is used instead.\r\n     *\r\n     * Default for English (US): `\"approximately\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/termApproximately.md]]\r\n     */\r\n    termApproximately?: string;\r\n\r\n    /**\r\n     * When writting time values that represent an _Infinity_, this string will be used to express it, when\r\n     * [verbose](#verbose) is enabled. Otherwise, its [symbol](#symbolinfinite) is used instead.\r\n     *\r\n     * Default for English (US): `\"infinite\"`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/termInfinite.md]]\r\n     */\r\n    termInfinite?: string;\r\n\r\n    /**\r\n     * When writting time values that represent a _NaN_ (not a number), this string will be used to express it, when\r\n     * [verbose](#verbose) is enabled. Otherwise, its [symbol](#symbolnan) is used instead.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/termNaN.md]]\r\n     */\r\n    termNaN?: string;\r\n\r\n    /**\r\n     * **This property is no longer supported!** This was used to define a few special numeric terms.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `verbose` (will be removed in v2).\r\n     */\r\n    terms?: {\r\n        approximately?: string;\r\n        infinite?: string;\r\n        nan?: string;\r\n    };\r\n\r\n    /**\r\n     * A string used as the thousands separator when using decimal [numeric notations](#numericnotation).\r\n     *\r\n     * Default is `undefined`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/thousandsSeparator.md]]\r\n     */\r\n    thousandsSeparator?: string;\r\n\r\n    /**\r\n     * A string that separates the numeric value from the time unit.\r\n     *\r\n     * Default is `\" \"` (space).\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/timeUnitSeparator.md]]\r\n     */\r\n    timeUnitSeparator?: string;\r\n\r\n    /**\r\n     * Whether to write more sentences to describe a time value instead of using symbols. Setting this to true enforce\r\n     * descriptive text for time units\r\n     *\r\n     * All time units without a symbol are already written in verbose mode.\r\n     *\r\n     * Default is `false`.\r\n     *\r\n     * ---\r\n     *\r\n     * [[include:examples/timewritersettings/verbose.md]]\r\n     */\r\n    verbose?: boolean;\r\n\r\n    /**\r\n     * **This property is no longer supported!** Whether or not to write down the full unit readable name, instead of\r\n     * its symbol.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `verbose` (will be removed in v2).\r\n     */\r\n    verboseTimeUnit?: boolean;\r\n}\r\n\r\n//#endregion\r\n","/*! ****************************************************************************\r\nCopyright (c) 2017-2018 Pedro Jos Batista\r\nMIT License\r\n\r\nSee the LICENSE file for more information.\r\n***************************************************************************** */\r\n/** [[include:localization.md]] */ /** */\r\nimport fs = require(\"fs\");\r\nimport path = require(\"path\");\r\nimport { BaseTimeUnit, TimeUnitDatabase, TimeWriterSettings } from \".\";\r\n\r\n/**\r\n * This interface describes objects with properties belonging to the specified type parameter `T`.\r\n *\r\n * @typeparam T\r\n *   Type of element stored by the object (string by default).\r\n */\r\nexport interface Dictionary<T = string> {\r\n    [propertyName: string]: T;\r\n}\r\n\r\n/**\r\n * This class manages the internationalization of the module, altering the results synthesized by\r\n * [time writers](_index_.timewriter.html).\r\n *\r\n * Translations are stored in files located at `src/locales`. These files contain the transcription for time units and\r\n * linguistic configurations.\r\n *\r\n * ---\r\n *\r\n * See [Contributing: Translating](https://github.com/pjbatista/timecount/blob/master/CONTRIBUTING.md#translating) if\r\n * you wish to contribute with a new translation for timecount.\r\n */\r\nexport class Locale {\r\n\r\n    private static _availableFiles: Dictionary;\r\n    private static _availableIdentifiers: string[];\r\n    private static _availableLanguages: Dictionary;\r\n    private static _currentIdentifier = \"en-us\";\r\n    private static _settings: LocaleSettings = {};\r\n\r\n    /**\r\n     * Gets the current locale identifier.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `get` (will be removed in v2).\r\n     */\r\n    public static get currentIdentifier() { return Locale._currentIdentifier; }\r\n\r\n    /** Gets the configuration for the current locale which represents the translation file currently loaded. */\r\n    public static get settings() { return Locale._settings; }\r\n\r\n    /**\r\n     * Gets the current locale identifier (e.g.: \"fr\" represents French  the international translation for the language\r\n     * as a whole; \"fr-ca\" is French (Canada)  represents a localized variation of the French language meant for\r\n     * Canada).\r\n     *\r\n     * The default is \"en-us\", which represents English (United States), a language built into the module (doesn't\r\n     * require any translation file).\r\n     */\r\n    public static get() { return Locale._currentIdentifier; }\r\n\r\n    /**\r\n     * Gets whether the given locale identifier is available to `timecount`.\r\n     *\r\n     * @param localeIdentifier\r\n     *   A language / region locale specifier (e.g. \"en-au\", \"pt-br\").\r\n     * @return\r\n     *   True if a valid locale was provided; false otherwise.\r\n     */\r\n    public static isAvailable(localeIdentifier: string) {\r\n\r\n        if (!Locale._availableIdentifiers) {\r\n            Locale._initialize();\r\n        }\r\n\r\n        localeIdentifier = localeIdentifier.toLocaleLowerCase();\r\n\r\n        return Locale.listAvailable().indexOf(localeIdentifier) > -1;\r\n    }\r\n\r\n    /**\r\n     * Gets a list with all locale identifiers available to timecount.\r\n     *\r\n     * @return\r\n     *   An array with all available locale identifiers.\r\n     */\r\n    public static listAvailable() {\r\n\r\n        if (!Locale._availableIdentifiers) {\r\n            Locale._initialize();\r\n        }\r\n\r\n        const languages = Object.keys(this._availableLanguages);\r\n        return Locale._availableIdentifiers.concat([\"en\", \"en-us\"], languages).sort();\r\n    }\r\n\r\n    /**\r\n     * Sets the current timecount language using the specified locale identifier (e.g.: \"pt\" represents Portuguese  the\r\n     * international translation for the language as a whole; \"pt-br\" is Portuguese (Brazilian)  represents a localized\r\n     * variation of the Portuguese language meant for Brazil).\r\n     *\r\n     * @param localeIdentifier\r\n     *   A string with a 2 letter language identifier (\"en\", \"es\", \"pt\", etc.) -or- a 5 letter language + region\r\n     *   identifier (\"en-ca\", \"pt-ao\"). This parameter is case-insensitive. If empty, it will reset the locale to \"en\".\r\n     * @throws Error\r\n     *   When the locale identifier is invalid.\r\n     */\r\n    public static set(localeIdentifier: string = \"en\") {\r\n\r\n        localeIdentifier = localeIdentifier.toLocaleLowerCase();\r\n\r\n        // English (US) is hardcoded; no translation file required\r\n        if (localeIdentifier === \"en\" || localeIdentifier === \"en-us\") {\r\n            Locale._currentIdentifier = \"en-us\";\r\n            Locale._settings = {};\r\n            return;\r\n        }\r\n\r\n        // isAvailable already calls _initialize\r\n        if (!Locale.isAvailable(localeIdentifier)) {\r\n            throw new Error(\"Invalid locale identifier\");\r\n        }\r\n\r\n        if (localeIdentifier.length === 2 && Locale._availableLanguages.hasOwnProperty(localeIdentifier)) {\r\n            localeIdentifier = Locale._availableLanguages[localeIdentifier];\r\n        }\r\n\r\n        const pathToLocaleFile = Locale._availableFiles[localeIdentifier];\r\n\r\n        Locale._currentIdentifier = localeIdentifier;\r\n        const settings: LocaleSettings = require(`./locales/${pathToLocaleFile}`).default;\r\n        Locale._settings = settings;\r\n\r\n        // Parsing deprecated properties\r\n        settings.defaultTimeUnit = settings.defaultTimeUnit || settings.defaultOptions;\r\n\r\n        if (!settings.timeUnits) {\r\n            return;\r\n        }\r\n\r\n        // tslint:disable-next-line:curly\r\n        for (const timeUnitName in settings.timeUnits) if (settings.timeUnits.hasOwnProperty(timeUnitName)) {\r\n\r\n            // Fixes the plurals when translating: nulls are not parsed like undefineds\r\n            const timeUnit = settings.timeUnits[timeUnitName as keyof TimeUnitDatabase];\r\n            timeUnit.customPlural = timeUnit.customPlural || null as any;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private static _initialize() {\r\n        const availableFiles: Dictionary = {};\r\n        const availableIdentifiers: string[] = [];\r\n        const availableLanguages: Dictionary = {};\r\n\r\n        const localeFiles = fs.readdirSync(path.join(__dirname, \"locales\"));\r\n\r\n        for (const localeFile of localeFiles) {\r\n            const localeIdentifier = localeFile.toLocaleLowerCase();\r\n\r\n            // Splits the file path into 3 groups: path, language and region (which is optional)\r\n            const localeParser = /^([a-z]{2})-?(|[a-z]{2})\\.ts/.exec(localeIdentifier);\r\n\r\n            if (localeParser === null) {\r\n                continue;\r\n            }\r\n\r\n            // Separating regionless languages and regionalizations\r\n            const language = localeParser[1];\r\n            const region = localeParser[2];\r\n            const identifier = `${language}-${region.length === 2 ? region : \"\"}`;\r\n\r\n            if (!availableLanguages.hasOwnProperty(language)) {\r\n                availableLanguages[language] = identifier;\r\n            }\r\n\r\n            availableIdentifiers.push(identifier);\r\n            availableFiles[identifier] = localeFile;\r\n        }\r\n\r\n        Locale._availableFiles = availableFiles;\r\n        Locale._availableIdentifiers = availableIdentifiers;\r\n        Locale._availableLanguages = availableLanguages;\r\n    }\r\n\r\n    private constructor() { throw new Error(\"Cannot initialize static class Locale\"); }\r\n}\r\n\r\n/**\r\n * Objects of this class represent the configurations of translation files.\r\n *\r\n * After a translation has been [set](../classes/_localization_.locale.html#set), these configurations will be available\r\n * at [Locale.settings](../classes/_localization_.locale.html#settings) to be used by interested objects (such as\r\n * [time writers](../classes/_index_.timewriter.html)).\r\n */\r\nexport interface LocaleSettings {\r\n\r\n    /**\r\n     * These options allow for default linguistic configuration for the time units of the locale.\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `defaultTimeUnit` (will be removed in v2).\r\n     */\r\n    defaultOptions?: BaseTimeUnit;\r\n\r\n    /**\r\n     * An object able to override the default linguistic parsing of time units.\r\n     *\r\n     * It may be used to set a [custom plural function](_index_.basetimeunit.html#customplural) or prevent time units\r\n     * from being [pluralized](_index_.basetimeunit.html#pluralize) by default.\r\n     */\r\n    defaultTimeUnit?: BaseTimeUnit;\r\n\r\n    /**\r\n     * Database of time unit translations.\r\n     *\r\n     * Gives the ability to set [readable names](_index_.basetimeunit.html#readablename) and\r\n     * [plurals](_index_.basetimeunit.html#customplural) of translations.\r\n     */\r\n    timeUnits?: TimeUnitDatabase<BaseTimeUnit>;\r\n\r\n    /**\r\n     * Configurations assigned to [time writers](../classes/_index_.timewriter.html).\r\n     *\r\n     * Contains linguistic and mathematical properties applied to all\r\n     * [countdown](../classes/_index_.timewriter.html#countdown) and [write](../classes/_index_.timewriter.html#write)\r\n     * calls (unless overriden by the object or method).\r\n     */\r\n    writerOptions?: TimeWriterSettings;\r\n}\r\n\r\n/**\r\n * This interface extends from [BaseTimeUnit](_index_.basetimeunit.html) with the only difference being that it enforces\r\n * its [readable name](#readablename) to be not-optional, in order to better characterize a parsed time unit object.\r\n *\r\n * @deprecated Since v1.1.0 - Unnecessary interface (will be removed in v2).\r\n */\r\nexport interface LocalizedTimeUnit extends BaseTimeUnit {\r\n\r\n    /** This version of the property is not optional. */\r\n    readonly readableName: string;\r\n}\r\n","/*! ****************************************************************************\r\nCopyright (c) 2017-2018 Pedro Jos Batista\r\nMIT License\r\n\r\nSee the LICENSE file for more information.\r\n***************************************************************************** */\r\n/** [[include:utils.md]] */ /** */\r\nimport { Decimal } from \"decimal.js\";\r\nimport { Time } from \".\";\r\n\r\n/**\r\n * Gets the number of nanoseconds that represent the current time according to `process`.\r\n *\r\n * @return\r\n *   [Big decimal](https://www.npmjs.com/package/decimal.js) representation of the current time, in nanoseconds.\r\n */\r\nexport function getProcessTime() {\r\n    const preciseTime = process.hrtime();\r\n    return (new Decimal(preciseTime[0])).times(\"1e+9\").add(preciseTime[1]);\r\n}\r\n\r\n/**\r\n * Counts the duration of runtime operations.\r\n *\r\n * An instance of [BasicTimer](#) is able to count the duration between its [start](#start) and [stop](#stop).\r\n * Every start-stop cycle resets the object to its default state.\r\n *\r\n * See [Timer](_utils_.timer.html) if you need pausing and [StopWatch](_utils_.stopwatch.html) for time segmentation\r\n * (laps).\r\n *\r\n * ---\r\n *\r\n * [[include:examples/basictimer.md]]\r\n */\r\nexport class BasicTimer {\r\n\r\n    /** Protected field with the time value representing the moment the timer started. */\r\n    protected _startTime?: Decimal;\r\n\r\n    /** Gets the time elapsed since the start of the timer until _now_. */\r\n    public get elapsedTime() {\r\n        return this.getElapsedTime();\r\n    }\r\n\r\n    /** Gets whether the timer is currently running (it was [started](#start) and not yet [stopped](#stop)). */\r\n    public get isRunning() { return !!this._startTime; }\r\n\r\n    /**\r\n     * A protected property useful when overriding the timers it changes the output of\r\n     * [timer errors](_utils_.timererror.html) in order to represent the specified name.\r\n     */\r\n    protected get timerErrorType() { return \"timer\"; }\r\n\r\n    /**\r\n     * Initializes a new instance of the [BasicTimer](#) class, optionally auto-starting it.\r\n     *\r\n     * @param autoStart\r\n     *   Determines whether the timer will immediately start; default is false.\r\n     */\r\n    public constructor(autoStart: boolean = false) {\r\n\r\n        if (autoStart) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Begins to count time, setting the [start time](#starttime) to a value equivalent to _now_.\r\n     *\r\n     * @return\r\n     *   Time that represents _now_ (or better yet, the moment the timer has started).\r\n     * @throws TimerError\r\n     *   When the timer is already running.\r\n     */\r\n    public start() {\r\n\r\n        if (this._startTime) {\r\n            throw TimerError.timerAlreadyStarted(this.timerErrorType);\r\n        }\r\n\r\n        this._startTime = getProcessTime();\r\n        return this._startTime as Decimal;\r\n    }\r\n\r\n    /**\r\n     * Ends the time counting, returning the total elapsed time and resetting the object to its default state.\r\n     *\r\n     * @return\r\n     *   A time with the total amount of nanoseconds spent between [start](#start) and _now_.\r\n     * @throws TimerError\r\n     *   When the timer has not yet started.\r\n     */\r\n    public stop() {\r\n\r\n        if (!this._startTime) {\r\n            throw TimerError.timerNotStarted(this.timerErrorType);\r\n        }\r\n\r\n        const resultTime = new Time(getProcessTime().minus(this._startTime));\r\n        this._startTime = undefined;\r\n\r\n        return resultTime;\r\n    }\r\n\r\n    /**\r\n     * Protected alias to [elapsedTime](#elapsedtime).\r\n     */\r\n    protected getElapsedTime() {\r\n\r\n        if (!this._startTime) {\r\n            return new Time(0);\r\n        }\r\n\r\n        return new Time(getProcessTime().minus(this._startTime));\r\n    }\r\n\r\n    /**\r\n     * Protected alias to [isRunning](#isRunning).\r\n     */\r\n    protected getIsRunning() {\r\n        return !!this._startTime;\r\n    }\r\n}\r\n\r\n/**\r\n * This type of function is used by [stopwatches](../classes/_utils_.stopwatch.html) to return additional information\r\n * to the callers of [stop](../classes/_utils_.stopwatch.html#stop)\r\n */\r\nexport type StopWatchDetail = (partialTimes: Time[], error: number) => void;\r\n\r\n/**\r\n * Counts the duration of runtime operations, with pausing capabilities.\r\n *\r\n * An instance of [Timer](#) is able to count the duration between its [start](#start) and [stop](#stop), as well as\r\n * [pausing](#pause), which temporarily stops the time counting. Every start-stop cycle resets the object to its\r\n * default state.\r\n *\r\n * See [BasicTimer](_utils_.basictimer.html) for a simpler timer implentation (less overhead) and\r\n * [StopWatch](_utils_.stopwatch.html) for time segmentation.\r\n *\r\n * ---\r\n *\r\n * [[include:examples/timer.md]]\r\n */\r\nexport class Timer extends BasicTimer {\r\n\r\n    /** Protected field with the time value representing the moment the pausing started. */\r\n    protected _pauseStartTime?: Decimal;\r\n\r\n    /** Protected field with the time value representing the sum of all previous pause times. */\r\n    protected _pauseTimeSum = new Decimal(0);\r\n\r\n    /** Gets the time elapsed since the timer was [paused](#pause). */\r\n    public get elapsedPauseTime() {\r\n\r\n        if (!this._pauseStartTime) {\r\n            return new Time(0);\r\n        }\r\n\r\n        return new Time(getProcessTime().minus(this._pauseStartTime));\r\n    }\r\n\r\n    /** Gets the total amount of time the object spent [paused](#pause) during the current start-stop cycle. */\r\n    public get totalPauseTime() {\r\n        return this.elapsedPauseTime.add(this._pauseTimeSum);\r\n    }\r\n\r\n    /**\r\n     * Gets the time elapsed since the start of the timer until _now_.\r\n     *\r\n     * The value of this time will remain unchanged when the timer is [paused](#stop).\r\n     */\r\n    public get elapsedTime() {\r\n\r\n        if (!this._startTime) {\r\n            return new Time(0);\r\n        }\r\n\r\n        const totalElapsedTime = super.getElapsedTime();\r\n\r\n        if (!this._pauseStartTime) {\r\n            return totalElapsedTime.subtract(this._pauseTimeSum);\r\n        }\r\n\r\n        // If paused, calculate the difference between the elapsed time and the paused time\r\n        return totalElapsedTime\r\n            .add(this._startTime)\r\n            .subtract(this._pauseStartTime)\r\n            .subtract(this._pauseTimeSum);\r\n    }\r\n\r\n    /** Gets whether the timer is paused. */\r\n    public get isPaused() { return !!this._pauseStartTime; }\r\n\r\n    /**\r\n     * Gets whether the timer is currently running (it was [started](#start) and not yet [stopped](#stop)).\r\n     *\r\n     * This property is **not influenced by [pauses](#pause)**, i.e. it will return true even when paused.\r\n     */\r\n    public get isRunning() { return super.getIsRunning(); }\r\n\r\n    /**\r\n     * Prevents the object from counting the time until it is [resumed](#resume).\r\n     *\r\n     * Both the [elapsed time](#elapsedtime) and the time resulting from [stop](#stop) won't change during the pause,\r\n     * but [pausedTime](#pausedtime) and [totalPauseTime](#totalpausedtime) will.\r\n     *\r\n     * @throws TimerError\r\n     *   When the timer has not yet started -or- it is already paused.\r\n     */\r\n    public pause() {\r\n\r\n        if (!this.isRunning) {\r\n            throw TimerError.timerNotStarted(this.timerErrorType);\r\n        }\r\n\r\n        if (this._pauseStartTime) {\r\n            throw TimerError.timerAlreadyPaused(this.timerErrorType);\r\n        }\r\n\r\n        this._pauseStartTime = getProcessTime();\r\n        return this._pauseStartTime;\r\n    }\r\n\r\n    /**\r\n     * Resumes the time counting, recovering the object from a [paused](#pause) state.\r\n     *\r\n     * @return\r\n     *   The amount of time the timer spent paused.\r\n     * @throws TimerError\r\n     *   When the timer has not yet started -or- it is not paused.\r\n     */\r\n    public resume() {\r\n\r\n        if (!this.isRunning) {\r\n            throw TimerError.timerNotStarted(this.timerErrorType);\r\n        }\r\n\r\n        if (!this._pauseStartTime) {\r\n            throw TimerError.timerNotPaused(this.timerErrorType);\r\n        }\r\n\r\n        const pausedTime = this.elapsedPauseTime;\r\n        this._pauseStartTime = undefined;\r\n        this._pauseTimeSum = this._pauseTimeSum.add(pausedTime.bigValue);\r\n\r\n        return new Time(pausedTime);\r\n    }\r\n\r\n    /**\r\n     * Ends the time counting, returning the total elapsed time and resetting the object to its default state.\r\n     *\r\n     * If the timer is [paused](#pause), there **is no need** to [resume](#resume) before calling this method.\r\n     *\r\n     * @return\r\n     *   A time with the total amount of nanoseconds spent between [start](#start) and _now_.\r\n     * @throws TimerError\r\n     *   When the timer has not yet started.\r\n     */\r\n    public stop() {\r\n\r\n        const totalTime = super.stop();\r\n\r\n        if (this._pauseStartTime) {\r\n            this.resume();\r\n        }\r\n\r\n        const totalPauseTime = this._pauseTimeSum;\r\n        this._pauseTimeSum = new Decimal(0);\r\n\r\n        return totalTime.subtract(totalPauseTime);\r\n    }\r\n}\r\n\r\n/**\r\n * Counts the duration of runtime operations, with pausing capabilities and time segmentation  which are arbitry\r\n * divisions of time.\r\n *\r\n * An instance of [StopWatch](#) is able to count the duration between its [start](#start) and [stop](#stop),\r\n * [pausing](#pause), which temporarily stops the time counting, and [create laps](#endlap), which splits the\r\n * stopwatch . Every start-stop cycle resets the object to its default state.\r\n *\r\n * See [BasicTimer](_utils_.basictimer.html) and [Timer](_utils_.timer.html) for simpler timer implentations (less\r\n * overhead).\r\n *\r\n * ---\r\n *\r\n * [[include:examples/stopwatch.md]]\r\n */\r\nexport class StopWatch extends Timer {\r\n\r\n    /** Protected field with the array of partial lap time values. */\r\n    protected _lapPartialTimes: Decimal[] = [];\r\n\r\n    /** Protected field with the time value representing the moment the lap started. */\r\n    protected _lapStartTime?: Decimal;\r\n\r\n    /** Gets the time elapsed since the start of the current lap until _now_. */\r\n    public get currentLapElapsedTime() {\r\n\r\n        if (!this._lapStartTime) {\r\n            return new Time(0);\r\n        }\r\n\r\n        return new Time(getProcessTime().minus(this._lapStartTime).minus(this._pauseStartTime || 0));\r\n    }\r\n\r\n    /**\r\n     * Gets the time representing the moment the current lap started.\r\n     *\r\n     * @deprecated Since v1.1.0 - Unnecessary property (will be removed in v2).\r\n     */\r\n    public get currentLapStartTime() { return new Time(this._lapStartTime || 0); }\r\n\r\n    /** Gets the number of laps currently stored at the stopwatch. */\r\n    public get lapCount() { return this.partialTimes.length + 1; }\r\n\r\n    /**\r\n     * Gets an array with time partials of the laps of the stopwatch, excluding the [current](#currentlapelapsedtime).\r\n     *\r\n     * @deprecated Since v1.1.0 - In favor of `partialTimes` (will be removed in v2).\r\n     */\r\n    public get lapPartials() { return this._lapPartialTimes.map(value => new Time(value)); }\r\n\r\n    /**\r\n     * Gets an array with time partials of the laps of the stopwatch, including the [current](#currentlapelapsedtime).\r\n     * The sum of these times is equivalent to the total elapsed time of the stopwatch.\r\n     */\r\n    public get partialTimes() {\r\n        const partialTimes = this._lapPartialTimes.map(value => new Time(value));\r\n\r\n        if (this._lapStartTime) {\r\n            return partialTimes.concat(this.currentLapElapsedTime);\r\n        }\r\n\r\n        return partialTimes;\r\n    }\r\n\r\n    /** Gets the name used on stopwatch errors. */\r\n    protected get timerErrorType() { return \"stopwatch\"; }\r\n\r\n    /** Alias to [endLap](#endlap). */\r\n    public createTimeSegment() { return this.endLap(); }\r\n\r\n    /**\r\n     * Finishes the current lap and starts a new one. This will add a new entry to [partial times](#partialtimes) and\r\n     * start counting time for the new lap.\r\n     *\r\n     * **Note:** The first lap **always** start in parallel with the stopwatch.\r\n     *\r\n     * @return\r\n     *   The partial time of the finished lap (elapsed time from the start of the lap until _now_).\r\n     * @throws TimerError\r\n     *   When the stopwatch has not yet started.\r\n     */\r\n    public endLap() {\r\n\r\n        if (!this._lapStartTime) {\r\n            throw TimerError.timerNotStarted(this.timerErrorType);\r\n        }\r\n\r\n        const now = getProcessTime();\r\n        let total = now.minus(this._lapStartTime);\r\n\r\n        // Adjust the pause start relative to the beginning of the new lap\r\n        if (this._pauseStartTime) {\r\n            const pauseTime = now.minus(this._pauseStartTime);\r\n            this._pauseTimeSum = this._pauseTimeSum.add(pauseTime);\r\n            this._pauseStartTime = now;\r\n\r\n            total = total.minus(pauseTime);\r\n        }\r\n\r\n        this._lapStartTime = now;\r\n        this._lapPartialTimes.push(total);\r\n        return new Time(total);\r\n    }\r\n\r\n    /**\r\n     * Begins to count time, setting the [start time](#starttime) to a value equivalent to _now_. This also starts the\r\n     * first lap of the stopwatch.\r\n     *\r\n     * @return\r\n     *   Time that represents _now_ (or better yet, the moment the stopwatch has started).\r\n     * @throws TimerError\r\n     *   When the stopwatch is already running.\r\n     */\r\n    public start() {\r\n        this._lapStartTime = super.start();\r\n        return this._lapStartTime;\r\n    }\r\n\r\n    /**\r\n     * Ends the time counting, returning the total elapsed time (sum of all lap partials) and resetting the object to\r\n     * its default state. This will automatically end the last created lap!\r\n     *\r\n     * If the stopwatch is [paused](#pause), there **is no need** to [resume](#resume) before calling this method.\r\n     *\r\n     * @param detail\r\n     *   A closure that can be used to retrieve additional data about the stopwatch. This information would otherwise be\r\n     *   lost after the method is completed.\r\n     * @return\r\n     *   A time with the total amount of nanoseconds spent between [start](#start) and _now_.\r\n     * @throws TimerError\r\n     *   When the stopwatch has not yet started.\r\n     */\r\n    public stop(detail?: StopWatchDetail) {\r\n        const partials = this.partialTimes;\r\n        const totalTime = super.stop();\r\n\r\n        this._lapPartialTimes = [];\r\n        this._lapStartTime = undefined;\r\n\r\n        if (!detail) {\r\n            return totalTime;\r\n        }\r\n\r\n        let sum = new Decimal(0);\r\n        partials.forEach(partial => sum = sum.add(partial.bigValue));\r\n\r\n        // The error is calculated by the absolute difference between the stop value and the sum of partial times\r\n        detail(partials, sum.minus(totalTime.bigValue).abs().toNumber());\r\n\r\n        return totalTime;\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents errors that occur during the operation of [basic timers](../classes/_index_.basictimer.html),\r\n * [timers](../classes/_index_.timer.html) and [stopwatches](../classes/_index_.stopwatch.html).\r\n *\r\n * It has static methods able to create [TimerError](#) instances with generic error messages.\r\n */\r\nexport class TimerError extends Error {\r\n\r\n    /** Creates and returns a new [TimerError](#) instance for when the timer is already paused. */\r\n    public static timerAlreadyPaused(type: string = \"timer\") {\r\n        return new TimerError(`The ${type} is already paused`);\r\n    }\r\n\r\n    /** Creates and returns a new [TimerError](#) instance for when the timer has already started. */\r\n    public static timerAlreadyStarted(type: string = \"timer\") {\r\n        return new TimerError(`The ${type} has already started`);\r\n    }\r\n\r\n    /** Creates and returns a new [TimerError](#) instance for when the timer is not paused. */\r\n    public static timerNotPaused(type: string = \"timer\") {\r\n        return new TimerError(`The ${type} is not paused`);\r\n    }\r\n\r\n    /** Creates and returns a new [TimerError](#) instance for when the timer has not yet started. */\r\n    public static timerNotStarted(type: string = \"timer\") {\r\n        return new TimerError(`The ${type} has not yet started`);\r\n    }\r\n\r\n    /** Gets a string representation of the [TimerError](#) class, used by the built-in `Object.prototype.toString`. */\r\n    public get [Symbol.toStringTag]() { return \"TimerError\"; }\r\n}\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwic3JjL2luZGV4LnRzIiwic3JjL2xvY2FsaXphdGlvbi50cyIsInNyYy91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzV0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4TEE7Ozs7O2dGQUtnRjtBQUNoRiwyQkFBMkIsQ0FBQyxNQUFNO0FBQ2xDLHlDQUFxQztBQUNyQywrQ0FBd0M7QUFDeEMsNkNBQStDO0FBSXRDLG9DQUFZO0FBSHJCLCtCQUFpQztBQUl4QixzQkFBSztBQUVkLHFGQUFxRjtBQUNyRixvQkFBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBRWhDLGdDQUFnQztBQUVoQyxxQkFBcUIsTUFBYTtJQUM5QixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBQSxLQUFLO1FBQ3RCLE9BQU8sT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFdBQVcsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDO0lBQ3pELENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQUVELHVEQUF1RDtBQUN2RDtJQUFpQyxpQkFBaUM7U0FBakMsVUFBaUMsRUFBakMscUJBQWlDLEVBQWpDLElBQWlDO1FBQWpDLDRCQUFpQzs7SUFFOUQsSUFBSSxNQUFNLEdBQUcsRUFBTyxDQUFDO0lBRXJCLEtBQXFCLFVBQU8sRUFBUCxtQkFBTyxFQUFQLHFCQUFPLEVBQVAsSUFBTyxFQUFFO1FBQXpCLElBQU0sTUFBTSxnQkFBQTtRQUNiLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7S0FDaEQ7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDO0FBRUQsNERBQTREO0FBQzVELGdEQUFnRDtBQUNoRCxxQkFBcUIsR0FBVyxFQUFFLE1BQWMsRUFBRSxXQUFtQjtJQUNqRSxJQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXRDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ2QsT0FBTyxHQUFHLENBQUM7S0FDZDtJQUVELE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsV0FBVyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLENBQUM7QUFFRCwwRkFBMEY7QUFDMUYsNEJBQTRCLFNBQWtDO0lBRTFELElBQU0sTUFBTSxHQUFHLFVBQUMsSUFBWSxFQUFFLFFBQWEsSUFBb0IsT0FBQSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxNQUFBLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBakMsQ0FBaUMsQ0FBQztJQUVqRyx1QkFBdUI7SUFDdkIsSUFBSSxPQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssUUFBUSxFQUFFO1FBRWhDLGtEQUFrRDtRQUNsRCxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDbEMsT0FBTyxTQUEwQixDQUFDO1NBQ3JDO1FBRUQsZ0VBQWdFO1FBQ2hFLEtBQUssSUFBTSxZQUFZLElBQUksaUJBQVM7WUFBRSxJQUFJLGlCQUFTLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUM5RSxJQUFJLGlCQUFTLENBQUMsWUFBc0MsQ0FBQyxLQUFLLFNBQVMsRUFBRTtvQkFDakUsT0FBTyxNQUFNLENBQUMsWUFBWSxFQUFHLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7aUJBQ2pFO2FBQ0o7S0FDSjtJQUVELElBQUksT0FBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUVoQyxpR0FBaUc7UUFDakcsSUFBSSxpQkFBUyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNyQyxPQUFPLE1BQU0sQ0FBQyxTQUFTLEVBQUcsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUMzRDtRQUVELElBQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUV2Qyw4REFBOEQ7UUFDOUQsS0FBSyxJQUFNLFlBQVksSUFBSSxpQkFBUztZQUFFLElBQUksaUJBQVMsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQzlFLElBQU0sWUFBWSxHQUFHLGlCQUFTLENBQUMsWUFBc0MsQ0FBQyxDQUFDLFlBQVksQ0FBQztnQkFFcEYsNEVBQTRFO2dCQUM1RSxJQUFNLFVBQVUsR0FBRyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQzlDLElBQU0sVUFBVSxHQUFHLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ3BDLElBQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ2xGLElBQU0sVUFBVSxHQUFHLE9BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxRQUFRO29CQUNoRCxDQUFDLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRTtvQkFDNUIsQ0FBQyxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBRXZCLElBQUksTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLEtBQUssVUFBVSxJQUFJLE1BQU0sS0FBSyxVQUFVLElBQUksTUFBTSxLQUFLLFVBQVUsRUFBRTtvQkFDbEcsT0FBTyxNQUFNLENBQUMsWUFBWSxFQUFHLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7aUJBQ2pFO2FBQ0o7S0FDSjtJQUNELHNCQUFzQjtJQUV0QixvQ0FBb0M7SUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxZQUFZO0FBRVosZ0NBQWdDO0FBRWhDLElBQU0sZUFBZSxHQUF1QjtJQUN4QyxnQkFBZ0IsRUFBRSxHQUFHO0lBQ3JCLFlBQVksRUFBRSxLQUFLO0lBQ25CLGdCQUFnQixFQUFFLElBQUk7SUFDdEIsZUFBZSxFQUFFLFNBQVM7SUFDMUIsWUFBWSxFQUFFLENBQUM7SUFDZixnQkFBZ0IsRUFBRSxJQUFJO0lBQ3RCLGlCQUFpQixFQUFFLEVBQUU7SUFDckIsbUJBQW1CLEVBQUUsR0FBRztJQUN4QixjQUFjLEVBQUUsR0FBRztJQUNuQixTQUFTLEVBQUUsS0FBSztJQUNoQixpQkFBaUIsRUFBRSxlQUFlO0lBQ2xDLFlBQVksRUFBRSxVQUFVO0lBQ3hCLE9BQU8sRUFBRSxtQkFBbUI7SUFDNUIsaUJBQWlCLEVBQUUsR0FBRztJQUN0QixPQUFPLEVBQUUsS0FBSztDQUNqQixDQUFDO0FBRUYsa0RBQWtEO0FBQ2xELElBQU0sc0JBQXNCLEdBQUcsQ0FBQztJQUM1QixJQUFNLEtBQUssR0FBRyxHQUFHLENBQUM7SUFDbEIsSUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDekQsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLGdEQUFnRDtBQUNoRCxJQUFNLGFBQWEsR0FBNEI7SUFDM0MsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDO0lBQ2xELENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQztJQUNqRCxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBSSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7Q0FDN0QsQ0FBQztBQUVGLElBQU0sZ0JBQWdCLEdBQTRCO0lBQzlDLENBQUMsT0FBTyxFQUFFLFNBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLGdCQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxTQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxnQkFBTSxDQUFDO0lBQ25FLENBQUMsTUFBTSxFQUFFLFNBQUksQ0FBQyxFQUFHLENBQUMsS0FBSyxFQUFFLGdCQUFNLENBQUMsRUFBRyxDQUFDLEtBQUssRUFBRSxTQUFJLENBQUMsRUFBRyxDQUFDLEtBQUssRUFBRSxnQkFBTSxDQUFDO0lBQ2xFLENBQUMsS0FBSyxFQUFFLFNBQUksQ0FBQyxFQUFJLENBQUMsSUFBSSxFQUFFLGdCQUFNLENBQUMsRUFBSSxDQUFDLElBQUksRUFBRSxTQUFJLENBQUMsRUFBSSxDQUFDLElBQUksRUFBRSxnQkFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsU0FBSSxDQUFDO0NBQ2xGLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQVEsQ0FBQztBQUV4QywrQ0FBK0M7QUFDL0MsSUFBTSxjQUFjLEdBQTRCO0lBQzVDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLEdBQUcsQ0FBQztJQUNsRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLE1BQU0sQ0FBQztJQUNuRixDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDO0NBQy9ELENBQUM7QUFFRixZQUFZO0FBRVosNEJBQTRCO0FBRTVCOzs7Ozs7Ozs7R0FTRztBQUNILG9CQUEyQixLQUF1QixFQUFFLFNBQTBCO0lBQTFCLDBCQUFBLEVBQUEsaUJBQTBCO0lBRTFFLElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUM1QixLQUFLLEdBQUcsSUFBSSxvQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzlCO0lBRUQsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2pDLElBQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDO0lBQy9FLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUM1QixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFFaEIsT0FBTyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNqQyxzRkFBc0Y7UUFDdEYsS0FBb0IsVUFBUSxFQUFSLHFCQUFRLEVBQVIsc0JBQVEsRUFBUixJQUFRLEVBQUU7WUFBekIsSUFBTSxLQUFLLGlCQUFBO1lBRVosZ0dBQWdHO1lBQ2hHLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3RDLFVBQVUsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixNQUFNO2FBQ1Q7U0FDSjtLQUNKO0lBRUQsSUFBSSxTQUFTLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDL0MsTUFBTSxJQUFJLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztLQUMxRDtJQUVELE9BQU8sTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQ2hELENBQUM7QUE3QkQsZ0NBNkJDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILDZCQUFvQyxLQUF1QjtJQUV2RCxJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDNUIsS0FBSyxHQUFHLElBQUksb0JBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM5QjtJQUVELEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBRW5DLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDM0IsT0FBTyxFQUFFLENBQUM7S0FDYjtJQUVELElBQUksa0JBQWtCLEdBQUcsSUFBSSxvQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRXZCLHdHQUF3RztJQUN4RyxzRUFBc0U7SUFFdEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMvQyxJQUFNLGFBQWEsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEMsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV2RCxJQUFJLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzNCO1FBRUQsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQy9DLGtCQUFrQixHQUFHLFVBQVUsQ0FBQztZQUNoQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO0tBQ0o7SUFFRCxPQUFPLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBakNELGtEQWlDQztBQUVELFlBQVk7QUFFWiw0QkFBNEI7QUFFNUI7Ozs7O0dBS0c7QUFDVSxRQUFBLFlBQVksR0FBRztJQUV4QixpR0FBaUc7SUFDakcsT0FBTyxFQUFFLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWTtRQUN2RyxZQUFZLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsWUFBWTtRQUM1RyxhQUFhLEVBQUUsYUFBYSxDQUFDO0lBRWpDLHNDQUFzQztJQUN0QyxNQUFNLEVBQUUsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZO1FBQ3JHLFlBQVksRUFBRSxRQUFRLENBQUM7SUFFM0IsZ0ZBQWdGO0lBQ2hGLE1BQU0sRUFBRSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDO0lBRTVELGdHQUFnRztJQUNoRyxRQUFRLEVBQUUsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQztJQUVwRCw0RkFBNEY7SUFDNUYsUUFBUSxFQUFFLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDO0NBQ2pILENBQUM7QUFFRjs7Ozs7Ozs7R0FRRztBQUNVLFFBQUEsU0FBUyxHQUErQjtJQUNqRCxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFO0lBQy9FLGVBQWUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsbUJBQW1CLENBQUMsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFO0lBQ2pGLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUN6RCxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGVBQWUsQ0FBQyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUU7SUFDM0UsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxZQUFZLENBQUMsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFO0lBQ3pFLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUNyRSxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7SUFDckQsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxlQUFlLENBQUMsRUFBRTtJQUNoRCxhQUFhLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUM3RSxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUMvRSxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUMvRSxTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDekQsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDOUUsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzFELFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7SUFDaEQsWUFBWSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxZQUFZLENBQUMsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFO0lBQ3ZFLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsaUJBQWlCLENBQUMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0lBQ3JFLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUMxRCxhQUFhLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGVBQWUsQ0FBQyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRTtJQUN2RixJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7SUFDckQsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFO0lBQ2hFLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsYUFBYSxDQUFDLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRTtJQUMvRSxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDL0QsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzFELFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUM3RCxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0lBQ2hELE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsZUFBZSxDQUFDLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRTtJQUN6RSxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDbEUsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzFELFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUMxRCxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDekQsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxlQUFlLENBQUMsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFO0lBQzlFLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUN2RCxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7SUFDeEQsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQ3RELFlBQVksRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsaUJBQWlCLENBQUMsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFO0lBQzVFLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsWUFBWSxFQUFFLGVBQWUsRUFBRTtJQUNqRixTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRTtJQUM5RSxTQUFTLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRTtJQUM5RSxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLHVCQUF1QixDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUMzRSxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDMUQsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQ3pELFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsYUFBYSxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFO0lBQzdGLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFO0lBQ2xGLGFBQWEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsZUFBZSxDQUFDLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRTtJQUNyRixZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGVBQWUsQ0FBQyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUU7SUFDbkYsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO0lBQ3BELFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsYUFBYSxDQUFDLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRTtJQUM3RSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ3BDLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsY0FBYyxDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUN4RSxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUMvRSxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLG9CQUFvQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUNqRixhQUFhLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUM3RSxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLG1CQUFtQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUNoRixZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUM1RSxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQzdDLFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsY0FBYyxDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRTtJQUN0RSxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDdkQsWUFBWSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUU7SUFDM0UsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDeEUsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzFELFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsVUFBVSxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUMzRCxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUU7SUFDekUsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO0lBQ3ZELElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsZUFBZSxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtJQUMzRCxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLGdDQUFnQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUNwRixXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDM0QsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksb0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQzNELFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsNkJBQTZCLENBQUMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0lBQ2pGLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLG9CQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtJQUMzRCxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxvQkFBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Q0FDOUQsQ0FBQztBQUVGOzs7O0dBSUc7QUFDVSxRQUFBLFNBQVMsR0FBRyxpQkFBUyxDQUFDO0FBK0ZuQzs7O0dBR0c7QUFDSCxJQUFZLFlBNEJYO0FBNUJELFdBQVksWUFBWTtJQUVwQiw2QkFBNkI7SUFDN0IscURBQVcsQ0FBQTtJQUVYLDJCQUEyQjtJQUMzQix5REFBUyxDQUFBO0lBRVQsaUNBQWlDO0lBQ2pDLHlEQUFTLENBQUE7SUFFVCxrQ0FBa0M7SUFDbEMsMkRBQVUsQ0FBQTtJQUVWLCtFQUErRTtJQUMvRSw2REFBVyxDQUFBO0lBRVgsNkVBQTZFO0lBQzdFLGlFQUFhLENBQUE7SUFFYix1RkFBdUY7SUFDdkYsaUVBQWEsQ0FBQTtJQUViLG1GQUFtRjtJQUNuRixpRUFBYSxDQUFBO0lBRWIsb0ZBQW9GO0lBQ3BGLG1FQUFjLENBQUE7QUFDbEIsQ0FBQyxFQTVCVyxZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQTRCdkI7QUFFRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSDtJQXFESSxzQ0FBc0M7SUFDdEMsY0FBbUIsS0FBNkIsRUFBRSxZQUE2QjtRQUE3Qiw2QkFBQSxFQUFBLG9CQUE2QjtRQUUzRSxJQUFJLEtBQUssWUFBWSxJQUFJLEVBQUU7WUFDdkIsWUFBWSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUM7WUFDbkMsS0FBSyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUM7U0FDOUI7UUFFRCxJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLG9CQUFPLENBQUMsRUFBRTtZQUN6RixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFvQixLQUFPLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksQ0FBQyxDQUFDLEtBQUssWUFBWSxvQkFBTyxDQUFDLEVBQUU7WUFDN0IsS0FBSyxHQUFHLElBQUksb0JBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUE5REQsc0JBQVcsMEJBQVE7UUFKbkI7OztXQUdHO2FBQ0gsY0FBd0IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFNbkQsc0JBQVcsZ0NBQWM7UUFKekI7OztXQUdHO2FBQ0gsY0FBOEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFPMUQsc0JBQVcsNkJBQVc7UUFMdEI7Ozs7V0FJRzthQUNILGNBQTJCLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBSzdFLHNCQUFXLHVCQUFLO1FBSGhCOztXQUVHO2FBQ0gsY0FBcUIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUE4RXZFLCtCQUErQjtJQUNqQixTQUFJLEdBQWxCLFVBQW1CLEtBQXNCLEVBQUUsUUFBaUM7UUFFeEUsSUFBSSxPQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxDQUFDLEtBQUssWUFBWSxvQkFBTyxDQUFDLEVBQUU7WUFDekYsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBb0IsS0FBTyxDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsQ0FBQyxLQUFLLFlBQVksb0JBQU8sQ0FBQyxFQUFFO1lBQzdCLEtBQUssR0FBRyxJQUFJLG9CQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDOUI7UUFFRCxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDeEMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQXNDRCw4QkFBOEI7SUFDdkIsa0JBQUcsR0FBVixVQUFXLEtBQTZCLEVBQUUsUUFBeUI7UUFFL0QsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBRXpCLElBQUksS0FBSyxZQUFZLElBQUksRUFBRTtZQUN2QixLQUFLLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQztTQUM5QjtRQUVELElBQUksUUFBUSxFQUFFO1lBQ1YsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDN0MsWUFBWSxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUM7WUFDdkMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLDBCQUFXLEdBQWxCO1FBQ0ksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFzQ0QsaUNBQWlDO0lBQzFCLHFCQUFNLEdBQWIsVUFBYyxLQUE2QixFQUFFLFFBQXlCO1FBRWxFLElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQztRQUV6QixJQUFJLEtBQUssWUFBWSxJQUFJLEVBQUU7WUFDdkIsS0FBSyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUM7U0FDOUI7UUFFRCxJQUFJLFFBQVEsRUFBRTtZQUNWLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzdDLFlBQVksR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDO1lBQ3ZDLEtBQUssR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBc0NELG1DQUFtQztJQUM1Qix1QkFBUSxHQUFmLFVBQWdCLEtBQTZCLEVBQUUsUUFBeUI7UUFFcEUsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBRXpCLElBQUksS0FBSyxZQUFZLElBQUksRUFBRTtZQUN2QixLQUFLLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQztTQUM5QjtRQUVELElBQUksUUFBUSxFQUFFO1lBQ1YsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDN0MsWUFBWSxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUM7WUFDdkMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFzQ0QsbUNBQW1DO0lBQzVCLHVCQUFRLEdBQWYsVUFBZ0IsS0FBNkIsRUFBRSxRQUF5QjtRQUVwRSxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7UUFFekIsSUFBSSxLQUFLLFlBQVksSUFBSSxFQUFFO1lBQ3ZCLEtBQUssR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxRQUFRLEVBQUU7WUFDVixJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztZQUM3QyxZQUFZLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQztZQUN2QyxLQUFLLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQztTQUNsQztRQUVELE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQTBCRCw2QkFBNkI7SUFDdEIsaUJBQUUsR0FBVCxVQUFVLFFBQXdCO1FBQzlCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBMEJELGdDQUFnQztJQUN6QixvQkFBSyxHQUFaLFVBQWEsUUFBd0I7UUFFakMsUUFBUSxHQUFHLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLHVCQUFRLEdBQWY7UUFDSSxPQUFPLE1BQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsUUFBSyxDQUFDO0lBQ2hGLENBQUM7SUFDTCxXQUFDO0FBQUQsQ0EvWkEsQUErWkMsSUFBQTtBQS9aWSxvQkFBSTtBQW95Q2pCOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0g7SUFJSTs7Ozs7OztPQU9HO0lBQ0gsb0JBQTBCLFFBQWlDO1FBQWpDLHlCQUFBLEVBQUEsYUFBaUM7UUFBakMsYUFBUSxHQUFSLFFBQVEsQ0FBeUI7UUFWbkQsdUJBQWtCLEdBQUcsSUFBSSxDQUFDO0lBVTZCLENBQUM7SUFvSGhFLG9DQUFvQztJQUM3Qiw4QkFBUyxHQUFoQixVQUFpQixJQUFVLEVBQ3ZCLE9BQXdGO1FBQXhGLHdCQUFBLEVBQUEsWUFBd0Y7UUFDeEYsY0FBc0U7YUFBdEUsVUFBc0UsRUFBdEUscUJBQXNFLEVBQXRFLElBQXNFO1lBQXRFLDZCQUFzRTs7UUFFdEUsSUFBTSxhQUFhLEdBQWEsRUFBRSxDQUFDO1FBQ25DLElBQU0sZUFBZSxHQUFvQixFQUFFLENBQUM7UUFFNUMsSUFBSSxPQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDbEUsSUFBSSxHQUFHLENBQUMsT0FBeUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUF3QixDQUFDLENBQUM7WUFDcEUsT0FBTyxHQUFHLEVBQUUsQ0FBQztTQUNoQjtRQUVELElBQUksT0FBTyxZQUFZLEtBQUssRUFBRTtZQUMxQixJQUFJLEdBQUksT0FBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1NBQ2hCO1FBRUQseURBQXlEO1FBQ3pELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbkIsSUFBSSxHQUFHLG9CQUFZLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsd0NBQXdDO1FBQ3hDLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLFlBQVksS0FBSyxFQUFsQixDQUFrQixDQUFDLENBQUM7UUFDdkQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxDQUFDLFlBQVksS0FBSyxDQUFDLEVBQXJCLENBQXFCLENBQUMsQ0FBQztRQUV6RCw0Q0FBNEM7UUFDNUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUssSUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLEdBQUcsUUFBUSxDQUFDO1FBRWhCLEtBQXVCLFVBQUksRUFBSixhQUFJLEVBQUosa0JBQUksRUFBSixJQUFJLEVBQUU7WUFBeEIsSUFBTSxRQUFRLGFBQUE7WUFDZixJQUFNLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxRQUEwQixDQUFDLENBQUM7WUFFaEUsMEJBQTBCO1lBQzFCLElBQUksYUFBYSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0JBQzNDLFNBQVM7YUFDWjtZQUVELGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDbEM7UUFFRCxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUE2QixDQUFDLENBQUM7UUFDOUQsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQW1NRCxnQ0FBZ0M7SUFDekIsMEJBQUssR0FBWixVQUFhLElBQTRCLEVBQUUsWUFBMkQsRUFDbEcsVUFBeUQsRUFBRSxPQUE0QjtRQUV2RixJQUFNLFNBQVMsR0FBRyxVQUFDLE1BQVcsSUFBSyxPQUFBLE9BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUEvRCxDQUErRCxDQUFDO1FBRW5HLElBQUksQ0FBQyxPQUFPLElBQUksU0FBUyxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ3JDLE9BQU8sR0FBRyxZQUFrQyxDQUFDO1lBQzdDLFlBQVksR0FBRyxVQUFVLENBQUM7WUFDMUIsVUFBVSxHQUFHLFNBQVMsQ0FBQztTQUMxQjtRQUVELElBQUksQ0FBQyxPQUFPLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sR0FBRyxVQUFnQyxDQUFDO1lBQzNDLFVBQVUsR0FBRyxTQUFTLENBQUM7U0FDMUI7UUFFRCxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV4QyxZQUFZLEdBQUcsQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDLGVBQWUsSUFBSSxZQUFZLENBQW1CLENBQUM7UUFDM0YsVUFBVSxHQUFHLENBQUMsVUFBVSxJQUFJLFlBQVksQ0FBbUIsQ0FBQztRQUU1RCxJQUFJLENBQUMsQ0FBQyxJQUFJLFlBQVksSUFBSSxDQUFDLEVBQUU7WUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUNELFlBQVk7SUFFWixrREFBa0Q7SUFDMUMsb0NBQWUsR0FBdkIsVUFBd0IsT0FBdUM7UUFFM0QsT0FBTyxHQUFHLEtBQUssQ0FBQyxlQUFlLEVBQUUscUJBQU0sQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFeEYsdUZBQXVGO1FBRXZGLE9BQU8sQ0FBQyxhQUFhLEdBQUcsT0FBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxRQUFRO1lBQzlELENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYTtZQUN2QixDQUFDLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQztRQUU3QixJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxlQUFlLENBQUMsaUJBQWlCLElBQUksT0FBTyxDQUFDLGFBQWEsS0FBSyxLQUFLLEVBQUU7WUFDcEcsT0FBTyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztTQUNsQztRQUVELElBQUksT0FBTyxDQUFDLEtBQUssRUFBRTtZQUNmLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsaUJBQWlCLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7WUFDckYsT0FBTyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1lBQ3RFLE9BQU8sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztTQUMxRDtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRCxzQ0FBc0M7SUFDOUIsbUNBQWMsR0FBdEIsVUFBdUIsSUFBVSxFQUFFLFlBQTZCLEVBQUUsT0FBMkI7UUFFekYsSUFBSSxLQUFLLEdBQVksSUFBSSxvQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLElBQUksT0FBTyxHQUFZLElBQUksb0JBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLFFBQVEsR0FBWSxJQUFJLG9CQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdkMsSUFBTSxNQUFNLEdBQUcsVUFBQyxLQUFjLElBQU8sS0FBSyxHQUFHLEtBQUssRUFBRSxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWhILHVEQUF1RDtRQUN2RCxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBN0IsQ0FBNkIsQ0FBQyxDQUFDO1FBRTNELDhEQUE4RDtRQUM5RCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBDLElBQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztRQUU1QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzdDLElBQU0sZ0JBQWdCLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUU3QyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLGdCQUFnQixLQUFLLEtBQUssQ0FBQztnQkFDbkUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUUzQyxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsY0FBYyxJQUFJLGdCQUFnQixDQUFDLFlBQVk7b0JBQ25FLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLFdBQVcsRUFBRTtvQkFDcEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7Z0JBRTNDLDZCQUE2QjtnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUUvRCxtRUFBbUU7Z0JBQ25FLElBQUksVUFBVSxDQUFDLGNBQWMsSUFBSSxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU7b0JBQzVELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7aUJBQ25DO2FBQ0o7WUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4RTtRQUVELElBQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXZELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsZ0JBQWdCLEtBQUssS0FBSyxDQUFDO1lBQ2pFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsRUFBRTtZQUV6QyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUN2QywwQ0FBMEM7Z0JBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7YUFDN0Q7aUJBQU07Z0JBQ0gsMERBQTBEO2dCQUMxRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQ3JEO1NBQ0o7UUFFRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO1FBQy9CLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLElBQUksRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELHdEQUF3RDtJQUNoRCxpQ0FBWSxHQUFwQixVQUFxQixLQUFjLEVBQUUsT0FBMkI7UUFFNUQsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUN4RTtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbkIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDbEY7UUFFRCxJQUFJLE9BQU8sQ0FBQyxlQUFlLEtBQUssT0FBTyxFQUFFO1lBQ3JDLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVCO1FBRUQsSUFBSSxPQUFPLENBQUMsZUFBZSxLQUFLLGlCQUFpQixFQUFFO1lBQy9DLE9BQU8sVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNsQztRQUVELElBQU0sVUFBVSxHQUFHLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDakUsSUFBSSxXQUFtQixDQUFDO1FBRXhCLElBQUksT0FBTyxDQUFDLGlCQUFpQixFQUFFO1lBQzNCLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDN0MsS0FBSyxHQUFHLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEdBQUcsTUFBTSxFQUFFLE9BQU8sQ0FBQyxZQUFtQixDQUFDLENBQUM7U0FDdEc7UUFFRCxJQUFJLE9BQU8sQ0FBQyxlQUFlLEtBQUssWUFBWSxFQUFFO1lBQzFDLFdBQVcsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDOUQ7YUFBTTtZQUNILFdBQVcsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDeEQ7UUFFRCx1RUFBdUU7UUFDdkUsSUFBSSxPQUFPLENBQUMsZUFBZSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsa0JBQWtCLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEcsSUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBRWpGLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3BCLFdBQVcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7YUFDcEQ7aUJBQU07Z0JBQ0gsV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQjtTQUNKO1FBRUQsSUFBSSxPQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsS0FBSyxzQkFBc0IsRUFBRTtZQUN0RyxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUM1RjtRQUVELE9BQU8sV0FBVyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCx5REFBeUQ7SUFDakQsK0JBQVUsR0FBbEIsVUFBbUIsSUFBVSxFQUFFLE9BQTJCLEVBQUUsY0FBaUM7UUFFekYsSUFBTSxhQUFhLEdBQUcsa0JBQWtCLENBQUMsY0FBYyxJQUFJLE9BQU8sQ0FBQyxlQUFlLElBQUksWUFBWSxDQUFDLENBQUM7UUFDcEcsSUFBTSxXQUFXLEdBQUcscUJBQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxxQkFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDbkcsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV6QyxJQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBa0IsQ0FBQztRQUNwRSxJQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFFNUIsb0NBQW9DO1FBQ3BDLElBQUksSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsSUFBSSxhQUFhLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDaEYsSUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPO2dCQUNuQyxDQUFDLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNsRSxDQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDO1lBRWxDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFO1lBQ3hCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUNsRDthQUFNO1lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQy9EO1FBRUQsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO1lBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBRWpELG9CQUFvQjtTQUNuQjthQUFNO1lBQ0gsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2pHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsb0VBQW9FO0lBQzVELG1DQUFjLEdBQXRCLFVBQXVCLEtBQWMsRUFBRSxRQUF1QixFQUFFLE9BQTJCLEVBQUUsTUFBZTtRQUN4RyxJQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFFNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUNyQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3QixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDdkM7UUFFRCxJQUFJLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO1FBRXpDLElBQUksTUFBTSxJQUFJLE9BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEtBQUssVUFBVSxFQUFFO1lBQ3hELFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNqRTtRQUVELElBQUksTUFBTSxJQUFJLE9BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEtBQUssUUFBUSxFQUFFO1lBQ3RELFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxPQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssV0FBVyxFQUFFO1lBQ3RDLFlBQVksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNsRjtRQUVELElBQUksTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTtZQUNsQyxZQUFZLElBQUksR0FBRyxDQUFDO1NBQ3ZCO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUMxQixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUNMLGlCQUFDO0FBQUQsQ0F6bEJBLEFBeWxCQyxJQUFBO0FBemxCWSxnQ0FBVTtBQWczQnZCLFlBQVk7Ozs7O0FDenBGWjs7Ozs7Z0ZBS2dGO0FBQ2hGLGtDQUFrQyxDQUFDLE1BQU07QUFDekMsdUJBQTBCO0FBQzFCLDJCQUE4QjtBQWE5Qjs7Ozs7Ozs7Ozs7R0FXRztBQUNIO0lBeUpJO1FBQXdCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztJQUFDLENBQUM7SUE1SW5GLHNCQUFrQiwyQkFBaUI7UUFMbkM7Ozs7V0FJRzthQUNILGNBQXdDLE9BQU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFHM0Usc0JBQWtCLGtCQUFRO1FBRDFCLDRHQUE0RzthQUM1RyxjQUErQixPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUV6RDs7Ozs7OztPQU9HO0lBQ1csVUFBRyxHQUFqQixjQUFzQixPQUFPLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFFekQ7Ozs7Ozs7T0FPRztJQUNXLGtCQUFXLEdBQXpCLFVBQTBCLGdCQUF3QjtRQUU5QyxJQUFJLENBQUMsTUFBTSxDQUFDLHFCQUFxQixFQUFFO1lBQy9CLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN4QjtRQUVELGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFeEQsT0FBTyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ1csb0JBQWEsR0FBM0I7UUFFSSxJQUFJLENBQUMsTUFBTSxDQUFDLHFCQUFxQixFQUFFO1lBQy9CLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN4QjtRQUVELElBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEQsT0FBTyxNQUFNLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2xGLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ1csVUFBRyxHQUFqQixVQUFrQixnQkFBK0I7UUFBL0IsaUNBQUEsRUFBQSx1QkFBK0I7UUFFN0MsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUV4RCwwREFBMEQ7UUFDMUQsSUFBSSxnQkFBZ0IsS0FBSyxJQUFJLElBQUksZ0JBQWdCLEtBQUssT0FBTyxFQUFFO1lBQzNELE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxPQUFPLENBQUM7WUFDcEMsTUFBTSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDdEIsT0FBTztTQUNWO1FBRUQsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUM5RixnQkFBZ0IsR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUNuRTtRQUVELElBQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRWxFLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxnQkFBZ0IsQ0FBQztRQUM3QyxJQUFNLFFBQVEsR0FBbUIsT0FBTyxDQUFDLGVBQWEsZ0JBQWtCLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDbEYsTUFBTSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFFNUIsZ0NBQWdDO1FBQ2hDLFFBQVEsQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDLGVBQWUsSUFBSSxRQUFRLENBQUMsY0FBYyxDQUFDO1FBRS9FLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFO1lBQ3JCLE9BQU87U0FDVjtRQUVELGlDQUFpQztRQUNqQyxLQUFLLElBQU0sWUFBWSxJQUFJLFFBQVEsQ0FBQyxTQUFTO1lBQUUsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFFaEcsMkVBQTJFO2dCQUMzRSxJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFlBQXNDLENBQUMsQ0FBQztnQkFDNUUsUUFBUSxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxJQUFJLElBQVcsQ0FBQzthQUNoRTtRQUVELE9BQU87SUFDWCxDQUFDO0lBRWMsa0JBQVcsR0FBMUI7UUFDSSxJQUFNLGNBQWMsR0FBZSxFQUFFLENBQUM7UUFDdEMsSUFBTSxvQkFBb0IsR0FBYSxFQUFFLENBQUM7UUFDMUMsSUFBTSxrQkFBa0IsR0FBZSxFQUFFLENBQUM7UUFFMUMsSUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRXBFLEtBQXlCLFVBQVcsRUFBWCwyQkFBVyxFQUFYLHlCQUFXLEVBQVgsSUFBVyxFQUFFO1lBQWpDLElBQU0sVUFBVSxvQkFBQTtZQUNqQixJQUFNLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBRXhELG9GQUFvRjtZQUNwRixJQUFNLFlBQVksR0FBRyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUUzRSxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7Z0JBQ3ZCLFNBQVM7YUFDWjtZQUVELHVEQUF1RDtZQUN2RCxJQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakMsSUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQU0sVUFBVSxHQUFNLFFBQVEsVUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUUsQ0FBQztZQUV0RSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUM5QyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUM7YUFDN0M7WUFFRCxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztTQUMzQztRQUVELE1BQU0sQ0FBQyxlQUFlLEdBQUcsY0FBYyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxxQkFBcUIsR0FBRyxvQkFBb0IsQ0FBQztRQUNwRCxNQUFNLENBQUMsbUJBQW1CLEdBQUcsa0JBQWtCLENBQUM7SUFDcEQsQ0FBQztJQWxKYyx5QkFBa0IsR0FBRyxPQUFPLENBQUM7SUFDN0IsZ0JBQVMsR0FBbUIsRUFBRSxDQUFDO0lBb0psRCxhQUFDO0NBMUpELEFBMEpDLElBQUE7QUExSlksd0JBQU07Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNuQjs7Ozs7Z0ZBS2dGO0FBQ2hGLDJCQUEyQixDQUFDLE1BQU07QUFDbEMseUNBQXFDO0FBQ3JDLHNCQUF5QjtBQUV6Qjs7Ozs7R0FLRztBQUNIO0lBQ0ksSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3JDLE9BQU8sQ0FBQyxJQUFJLG9CQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNFLENBQUM7QUFIRCx3Q0FHQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNIO0lBbUJJOzs7OztPQUtHO0lBQ0gsb0JBQW1CLFNBQTBCO1FBQTFCLDBCQUFBLEVBQUEsaUJBQTBCO1FBRXpDLElBQUksU0FBUyxFQUFFO1lBQ1gsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQztJQXhCRCxzQkFBVyxtQ0FBVztRQUR0QixzRUFBc0U7YUFDdEU7WUFDSSxPQUFPLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNqQyxDQUFDOzs7T0FBQTtJQUdELHNCQUFXLGlDQUFTO1FBRHBCLDJHQUEyRzthQUMzRyxjQUF5QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFNcEQsc0JBQWMsc0NBQWM7UUFKNUI7OztXQUdHO2FBQ0gsY0FBaUMsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQWVsRDs7Ozs7OztPQU9HO0lBQ0ksMEJBQUssR0FBWjtRQUVJLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixNQUFNLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDN0Q7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLGNBQWMsRUFBRSxDQUFDO1FBQ25DLE9BQU8sSUFBSSxDQUFDLFVBQXFCLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSx5QkFBSSxHQUFYO1FBRUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbEIsTUFBTSxVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQU0sVUFBVSxHQUFHLElBQUksT0FBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztRQUU1QixPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7SUFDTyxtQ0FBYyxHQUF4QjtRQUVJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2xCLE9BQU8sSUFBSSxPQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFFRCxPQUFPLElBQUksT0FBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7O09BRUc7SUFDTyxpQ0FBWSxHQUF0QjtRQUNJLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDN0IsQ0FBQztJQUNMLGlCQUFDO0FBQUQsQ0F4RkEsQUF3RkMsSUFBQTtBQXhGWSxnQ0FBVTtBQWdHdkI7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNIO0lBQTJCLHlCQUFVO0lBQXJDO1FBQUEscUVBZ0lDO1FBM0hHLDRGQUE0RjtRQUNsRixtQkFBYSxHQUFHLElBQUksb0JBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUEwSDdDLENBQUM7SUF2SEcsc0JBQVcsbUNBQWdCO1FBRDNCLGtFQUFrRTthQUNsRTtZQUVJLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO2dCQUN2QixPQUFPLElBQUksT0FBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RCO1lBRUQsT0FBTyxJQUFJLE9BQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDbEUsQ0FBQzs7O09BQUE7SUFHRCxzQkFBVyxpQ0FBYztRQUR6QiwyR0FBMkc7YUFDM0c7WUFDSSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pELENBQUM7OztPQUFBO0lBT0Qsc0JBQVcsOEJBQVc7UUFMdEI7Ozs7V0FJRzthQUNIO1lBRUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2xCLE9BQU8sSUFBSSxPQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdEI7WUFFRCxJQUFNLGdCQUFnQixHQUFHLGlCQUFNLGNBQWMsV0FBRSxDQUFDO1lBRWhELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO2dCQUN2QixPQUFPLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDeEQ7WUFFRCxtRkFBbUY7WUFDbkYsT0FBTyxnQkFBZ0I7aUJBQ2xCLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUNwQixRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztpQkFDOUIsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN0QyxDQUFDOzs7T0FBQTtJQUdELHNCQUFXLDJCQUFRO1FBRG5CLHdDQUF3QzthQUN4QyxjQUF3QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFPeEQsc0JBQVcsNEJBQVM7UUFMcEI7Ozs7V0FJRzthQUNILGNBQXlCLE9BQU8saUJBQU0sWUFBWSxXQUFFLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUV2RDs7Ozs7Ozs7T0FRRztJQUNJLHFCQUFLLEdBQVo7UUFFSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNqQixNQUFNLFVBQVUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3pEO1FBRUQsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3RCLE1BQU0sVUFBVSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM1RDtRQUVELElBQUksQ0FBQyxlQUFlLEdBQUcsY0FBYyxFQUFFLENBQUM7UUFDeEMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksc0JBQU0sR0FBYjtRQUVJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2pCLE1BQU0sVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDekQ7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN2QixNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3hEO1FBRUQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBQ3pDLElBQUksQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWpFLE9BQU8sSUFBSSxPQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLG9CQUFJLEdBQVg7UUFFSSxJQUFNLFNBQVMsR0FBRyxpQkFBTSxJQUFJLFdBQUUsQ0FBQztRQUUvQixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2pCO1FBRUQsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUMxQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksb0JBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwQyxPQUFPLFNBQVMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUNMLFlBQUM7QUFBRCxDQWhJQSxBQWdJQyxDQWhJMEIsVUFBVSxHQWdJcEM7QUFoSVksc0JBQUs7QUFrSWxCOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0g7SUFBK0IsNkJBQUs7SUFBcEM7UUFBQSxxRUF3SUM7UUF0SUcsaUVBQWlFO1FBQ3ZELHNCQUFnQixHQUFjLEVBQUUsQ0FBQzs7SUFxSS9DLENBQUM7SUEvSEcsc0JBQVcsNENBQXFCO1FBRGhDLDRFQUE0RTthQUM1RTtZQUVJLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUNyQixPQUFPLElBQUksT0FBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RCO1lBRUQsT0FBTyxJQUFJLE9BQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakcsQ0FBQzs7O09BQUE7SUFPRCxzQkFBVywwQ0FBbUI7UUFMOUI7Ozs7V0FJRzthQUNILGNBQW1DLE9BQU8sSUFBSSxPQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBRzlFLHNCQUFXLCtCQUFRO1FBRG5CLGlFQUFpRTthQUNqRSxjQUF3QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBTzlELHNCQUFXLGtDQUFXO1FBTHRCOzs7O1dBSUc7YUFDSCxjQUEyQixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxJQUFJLE9BQUksQ0FBQyxLQUFLLENBQUMsRUFBZixDQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBTXhGLHNCQUFXLG1DQUFZO1FBSnZCOzs7V0FHRzthQUNIO1lBQ0ksSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLElBQUksT0FBSSxDQUFDLEtBQUssQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUFDO1lBRXpFLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDcEIsT0FBTyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2FBQzFEO1lBRUQsT0FBTyxZQUFZLENBQUM7UUFDeEIsQ0FBQzs7O09BQUE7SUFHRCxzQkFBYyxxQ0FBYztRQUQ1Qiw4Q0FBOEM7YUFDOUMsY0FBaUMsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUV0RCxrQ0FBa0M7SUFDM0IscUNBQWlCLEdBQXhCLGNBQTZCLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUVwRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksMEJBQU0sR0FBYjtRQUVJLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3JCLE1BQU0sVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDekQ7UUFFRCxJQUFNLEdBQUcsR0FBRyxjQUFjLEVBQUUsQ0FBQztRQUM3QixJQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUUxQyxrRUFBa0U7UUFDbEUsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3RCLElBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUM7WUFFM0IsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbEM7UUFFRCxJQUFJLENBQUMsYUFBYSxHQUFHLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLE9BQU8sSUFBSSxPQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0kseUJBQUssR0FBWjtRQUNJLElBQUksQ0FBQyxhQUFhLEdBQUcsaUJBQU0sS0FBSyxXQUFFLENBQUM7UUFDbkMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksd0JBQUksR0FBWCxVQUFZLE1BQXdCO1FBQ2hDLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDbkMsSUFBTSxTQUFTLEdBQUcsaUJBQU0sSUFBSSxXQUFFLENBQUM7UUFFL0IsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztRQUUvQixJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFFRCxJQUFJLEdBQUcsR0FBRyxJQUFJLG9CQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekIsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFBLE9BQU8sSUFBSSxPQUFBLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQyxDQUFDO1FBRTdELHlHQUF5RztRQUN6RyxNQUFNLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFakUsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztJQUNMLGdCQUFDO0FBQUQsQ0F4SUEsQUF3SUMsQ0F4SThCLEtBQUssR0F3SW5DO0FBeElZLDhCQUFTO0FBMEl0Qjs7Ozs7R0FLRztBQUNIO0lBQWdDLDhCQUFLO0lBQXJDOztJQXdCQSxDQUFDO0lBdEJHLCtGQUErRjtJQUNqRiw2QkFBa0IsR0FBaEMsVUFBaUMsSUFBc0I7UUFBdEIscUJBQUEsRUFBQSxjQUFzQjtRQUNuRCxPQUFPLElBQUksVUFBVSxDQUFDLFNBQU8sSUFBSSx1QkFBb0IsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRCxpR0FBaUc7SUFDbkYsOEJBQW1CLEdBQWpDLFVBQWtDLElBQXNCO1FBQXRCLHFCQUFBLEVBQUEsY0FBc0I7UUFDcEQsT0FBTyxJQUFJLFVBQVUsQ0FBQyxTQUFPLElBQUkseUJBQXNCLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsMkZBQTJGO0lBQzdFLHlCQUFjLEdBQTVCLFVBQTZCLElBQXNCO1FBQXRCLHFCQUFBLEVBQUEsY0FBc0I7UUFDL0MsT0FBTyxJQUFJLFVBQVUsQ0FBQyxTQUFPLElBQUksbUJBQWdCLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsaUdBQWlHO0lBQ25GLDBCQUFlLEdBQTdCLFVBQThCLElBQXNCO1FBQXRCLHFCQUFBLEVBQUEsY0FBc0I7UUFDaEQsT0FBTyxJQUFJLFVBQVUsQ0FBQyxTQUFPLElBQUkseUJBQXNCLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBR0Qsc0JBQVcsc0JBQUMsTUFBTSxDQUFDLFdBQVk7UUFEL0IsbUhBQW1IO2FBQ25ILGNBQW9DLE9BQU8sWUFBWSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFDOUQsaUJBQUM7QUFBRCxDQXhCQSxBQXdCQyxDQXhCK0IsS0FBSyxHQXdCcEM7QUF4QlksZ0NBQVUiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIiLCIvKiEgZGVjaW1hbC5qcyB2MTAuMC4xIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanMvTElDRU5DRSAqL1xyXG47KGZ1bmN0aW9uIChnbG9iYWxTY29wZSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIGRlY2ltYWwuanMgdjEwLjAuMVxyXG4gICAqICBBbiBhcmJpdHJhcnktcHJlY2lzaW9uIERlY2ltYWwgdHlwZSBmb3IgSmF2YVNjcmlwdC5cclxuICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xyXG4gICAqICBDb3B5cmlnaHQgKGMpIDIwMTcgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICAgKiAgTUlUIExpY2VuY2VcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBFRElUQUJMRSBERUZBVUxUUyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IG1hZ25pdHVkZS5cclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHRvRXhwTmVnYCwgYHRvRXhwUG9zYCwgYG1pbkVgIGFuZCBgbWF4RWAuXHJcbiAgdmFyIEVYUF9MSU1JVCA9IDllMTUsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOWUxNVxyXG5cclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAsIGFuZCBvbiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50IHRvXHJcbiAgICAvLyBgdG9EZWNpbWFsUGxhY2VzYCwgYHRvRXhwb25lbnRpYWxgLCBgdG9GaXhlZGAsIGB0b1ByZWNpc2lvbmAgYW5kIGB0b1NpZ25pZmljYW50RGlnaXRzYC5cclxuICAgIE1BWF9ESUdJVFMgPSAxZTksICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAxZTlcclxuXHJcbiAgICAvLyBCYXNlIGNvbnZlcnNpb24gYWxwaGFiZXQuXHJcbiAgICBOVU1FUkFMUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJyxcclxuXHJcbiAgICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAgKDEwMjUgZGlnaXRzKS5cclxuICAgIExOMTAgPSAnMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4JyxcclxuXHJcbiAgICAvLyBQaSAoMTAyNSBkaWdpdHMpLlxyXG4gICAgUEkgPSAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5JyxcclxuXHJcblxyXG4gICAgLy8gVGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIG9mIHRoZSBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgREVGQVVMVFMgPSB7XHJcblxyXG4gICAgICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXHJcbiAgICAgIC8vIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIHRoZSBgRGVjaW1hbC5jb25maWdgIG1ldGhvZC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiBhIGNhbGN1bGF0aW9uIG9yIGJhc2UgY29udmVyc2lvbi5cclxuICAgICAgLy8gRS5nLiBgRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwIH0pO2BcclxuICAgICAgcHJlY2lzaW9uOiAyMCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhfRElHSVRTXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gYHByZWNpc2lvbmAuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFJPVU5EX1VQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gUk9VTkRfRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gUk9VTkRfQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBST1VORF9GTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIFJPVU5EX0hBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIFJPVU5EX0hBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gUk9VTkRfSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBST1VORF9IQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBST1VORF9IQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBFLmcuXHJcbiAgICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gNDtgXHJcbiAgICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQO2BcclxuICAgICAgcm91bmRpbmc6IDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQgKEphdmFTY3JpcHQgJSkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUaGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLiBBbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRydW5jYXRlZCBkaXZpc2lvbiAoMSksIGZsb29yZWQgZGl2aXNpb24gKDMpLCB0aGUgSUVFRSA3NTQgcmVtYWluZGVyICg2KSwgYW5kIEV1Y2xpZGlhblxyXG4gICAgICAvLyBkaXZpc2lvbiAoOSkgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi4gVGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvXHJcbiAgICAgIC8vIGJlIHVzZWQsIGJ1dCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgbW9kdWxvOiAxLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IC03XHJcbiAgICAgIHRvRXhwTmVnOiAtNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMjFcclxuICAgICAgdG9FeHBQb3M6ICAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBFWFBfTElNSVRcclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBtaW5FOiAtRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtRVhQX0xJTUlUXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICBtYXhFOiBFWFBfTElNSVQsICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIEVYUF9MSU1JVFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBjcnlwdG86IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVRBQkxFIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblxyXG4gICAgRGVjaW1hbCwgaW5leGFjdCwgbm9Db25mbGljdCwgcXVhZHJhbnQsXHJcbiAgICBleHRlcm5hbCA9IHRydWUsXHJcblxyXG4gICAgZGVjaW1hbEVycm9yID0gJ1tEZWNpbWFsRXJyb3JdICcsXHJcbiAgICBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyAnSW52YWxpZCBhcmd1bWVudDogJyxcclxuICAgIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyAnUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkJyxcclxuICAgIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScsXHJcblxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuICAgIG1hdGhwb3cgPSBNYXRoLnBvdyxcclxuXHJcbiAgICBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gICAgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzT2N0YWwgPSAvXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgICBCQVNFID0gMWU3LFxyXG4gICAgTE9HX0JBU0UgPSA3LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcblxyXG4gICAgTE4xMF9QUkVDSVNJT04gPSBMTjEwLmxlbmd0aCAtIDEsXHJcbiAgICBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxLFxyXG5cclxuICAgIC8vIERlY2ltYWwucHJvdG90eXBlIG9iamVjdFxyXG4gICAgUCA9IHsgbmFtZTogJ1tvYmplY3QgRGVjaW1hbF0nIH07XHJcblxyXG5cclxuICAvLyBEZWNpbWFsIHByb3RvdHlwZSBtZXRob2RzXHJcblxyXG5cclxuICAvKlxyXG4gICAqICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgIGFic1xyXG4gICAqICBjZWlsXHJcbiAgICogIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgY21wXHJcbiAgICogIGNvc2luZSAgICAgICAgICAgICAgICAgICAgY29zXHJcbiAgICogIGN1YmVSb290ICAgICAgICAgICAgICAgICAgY2JydFxyXG4gICAqICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgIGRwXHJcbiAgICogIGRpdmlkZWRCeSAgICAgICAgICAgICAgICAgZGl2XHJcbiAgICogIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICAgZGl2VG9JbnRcclxuICAgKiAgZXF1YWxzICAgICAgICAgICAgICAgICAgICBlcVxyXG4gICAqICBmbG9vclxyXG4gICAqICBncmVhdGVyVGhhbiAgICAgICAgICAgICAgIGd0XHJcbiAgICogIGdyZWF0ZXJUaGFuT3JFcXVhbFRvICAgICAgZ3RlXHJcbiAgICogIGh5cGVyYm9saWNDb3NpbmUgICAgICAgICAgY29zaFxyXG4gICAqICBoeXBlcmJvbGljU2luZSAgICAgICAgICAgIHNpbmhcclxuICAgKiAgaHlwZXJib2xpY1RhbmdlbnQgICAgICAgICB0YW5oXHJcbiAgICogIGludmVyc2VDb3NpbmUgICAgICAgICAgICAgYWNvc1xyXG4gICAqICBpbnZlcnNlSHlwZXJib2xpY0Nvc2luZSAgIGFjb3NoXHJcbiAgICogIGludmVyc2VIeXBlcmJvbGljU2luZSAgICAgYXNpbmhcclxuICAgKiAgaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ICBhdGFuaFxyXG4gICAqICBpbnZlcnNlU2luZSAgICAgICAgICAgICAgIGFzaW5cclxuICAgKiAgaW52ZXJzZVRhbmdlbnQgICAgICAgICAgICBhdGFuXHJcbiAgICogIGlzRmluaXRlXHJcbiAgICogIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgaXNJbnRcclxuICAgKiAgaXNOYU5cclxuICAgKiAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICBpc05lZ1xyXG4gICAqICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgIGlzUG9zXHJcbiAgICogIGlzWmVyb1xyXG4gICAqICBsZXNzVGhhbiAgICAgICAgICAgICAgICAgIGx0XHJcbiAgICogIGxlc3NUaGFuT3JFcXVhbFRvICAgICAgICAgbHRlXHJcbiAgICogIGxvZ2FyaXRobSAgICAgICAgICAgICAgICAgbG9nXHJcbiAgICogIFttYXhpbXVtXSAgICAgICAgICAgICAgICAgW21heF1cclxuICAgKiAgW21pbmltdW1dICAgICAgICAgICAgICAgICBbbWluXVxyXG4gICAqICBtaW51cyAgICAgICAgICAgICAgICAgICAgIHN1YlxyXG4gICAqICBtb2R1bG8gICAgICAgICAgICAgICAgICAgIG1vZFxyXG4gICAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgIGV4cFxyXG4gICAqICBuYXR1cmFsTG9nYXJpdGhtICAgICAgICAgIGxuXHJcbiAgICogIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgbmVnXHJcbiAgICogIHBsdXMgICAgICAgICAgICAgICAgICAgICAgYWRkXHJcbiAgICogIHByZWNpc2lvbiAgICAgICAgICAgICAgICAgc2RcclxuICAgKiAgcm91bmRcclxuICAgKiAgc2luZSAgICAgICAgICAgICAgICAgICAgICBzaW5cclxuICAgKiAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgICBzcXJ0XHJcbiAgICogIHRhbmdlbnQgICAgICAgICAgICAgICAgICAgdGFuXHJcbiAgICogIHRpbWVzICAgICAgICAgICAgICAgICAgICAgbXVsXHJcbiAgICogIHRvQmluYXJ5XHJcbiAgICogIHRvRGVjaW1hbFBsYWNlcyAgICAgICAgICAgdG9EUFxyXG4gICAqICB0b0V4cG9uZW50aWFsXHJcbiAgICogIHRvRml4ZWRcclxuICAgKiAgdG9GcmFjdGlvblxyXG4gICAqICB0b0hleGFkZWNpbWFsICAgICAgICAgICAgIHRvSGV4XHJcbiAgICogIHRvTmVhcmVzdFxyXG4gICAqICB0b051bWJlclxyXG4gICAqICB0b09jdGFsXHJcbiAgICogIHRvUG93ZXIgICAgICAgICAgICAgICAgICAgcG93XHJcbiAgICogIHRvUHJlY2lzaW9uXHJcbiAgICogIHRvU2lnbmlmaWNhbnREaWdpdHMgICAgICAgdG9TRFxyXG4gICAqICB0b1N0cmluZ1xyXG4gICAqICB0cnVuY2F0ZWQgICAgICAgICAgICAgICAgIHRydW5jXHJcbiAgICogIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgdG9KU09OXHJcbiAgICovXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAgICogZGlyZWN0aW9uIG9mIHBvc2l0aXZlIEluZmluaXR5LlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jZWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5cclxuICAgKiAgIDEgICAgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCxcclxuICAgKiAgLTEgICAgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCxcclxuICAgKiAgIDAgICAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAqICAgTmFOICBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIERlY2ltYWwgaXMgTmFOLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIGksIGosIHhkTCwgeWRMLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgeGQgPSB4LmQsXHJcbiAgICAgIHlkID0gKHkgPSBuZXcgeC5jb25zdHJ1Y3Rvcih5KSkuZCxcclxuICAgICAgeHMgPSB4LnMsXHJcbiAgICAgIHlzID0geS5zO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4gb3IgwrFJbmZpbml0eT9cclxuICAgIGlmICgheGQgfHwgIXlkKSB7XHJcbiAgICAgIHJldHVybiAheHMgfHwgIXlzID8gTmFOIDogeHMgIT09IHlzID8geHMgOiB4ZCA9PT0geWQgPyAwIDogIXhkIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHJldHVybiB4ZFswXSA/IHhzIDogeWRbMF0gPyAteXMgOiAwO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmICh4cyAhPT0geXMpIHJldHVybiB4cztcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICh4LmUgIT09IHkuZSkgcmV0dXJuIHguZSA+IHkuZSBeIHhzIDwgMCA/IDEgOiAtMTtcclxuXHJcbiAgICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgICB5ZEwgPSB5ZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcclxuICAgICAgaWYgKHhkW2ldICE9PSB5ZFtpXSkgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstMSwgMV1cclxuICAgKlxyXG4gICAqIGNvcygwKSAgICAgICAgID0gMVxyXG4gICAqIGNvcygtMCkgICAgICAgID0gMVxyXG4gICAqIGNvcyhJbmZpbml0eSkgID0gTmFOXHJcbiAgICogY29zKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiBjb3MoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jb3NpbmUgPSBQLmNvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguZCkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gY29zKDApID0gY29zKC0wKSA9IDFcclxuICAgIGlmICgheC5kWzBdKSByZXR1cm4gbmV3IEN0b3IoMSk7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSAzID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG9cclxuICAgKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogIGNicnQoMCkgID0gIDBcclxuICAgKiAgY2JydCgtMCkgPSAtMFxyXG4gICAqICBjYnJ0KDEpICA9ICAxXHJcbiAgICogIGNicnQoLTEpID0gLTFcclxuICAgKiAgY2JydChOKSAgPSAgTlxyXG4gICAqICBjYnJ0KC1JKSA9IC1JXHJcbiAgICogIGNicnQoSSkgID0gIElcclxuICAgKlxyXG4gICAqIE1hdGguY2JydCh4KSA9ICh4IDwgMCA/IC1NYXRoLnBvdygteCwgMS8zKSA6IE1hdGgucG93KHgsIDEvMykpXHJcbiAgICpcclxuICAgKi9cclxuICBQLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgcyA9IHgucyAqIE1hdGgucG93KHgucyAqIHgsIDEgLyAzKTtcclxuXHJcbiAgICAgLy8gTWF0aC5jYnJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAvLyBQYXNzIHggdG8gTWF0aC5wb3cgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICAgIGUgPSB4LmU7XHJcblxyXG4gICAgICAvLyBBZGp1c3QgbiBleHBvbmVudCBzbyBpdCBpcyBhIG11bHRpcGxlIG9mIDMgYXdheSBmcm9tIHggZXhwb25lbnQuXHJcbiAgICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMykgbiArPSAocyA9PSAxIHx8IHMgPT0gLTIgPyAnMCcgOiAnMDAnKTtcclxuICAgICAgcyA9IE1hdGgucG93KG4sIDEgLyAzKTtcclxuXHJcbiAgICAgIC8vIFJhcmVseSwgZSBtYXkgYmUgb25lIGxlc3MgdGhhbiB0aGUgcmVzdWx0IGV4cG9uZW50IHZhbHVlLlxyXG4gICAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcclxuXHJcbiAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgciA9IG5ldyBDdG9yKG4pO1xyXG4gICAgICByLnMgPSB4LnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgICAvLyBIYWxsZXkncyBtZXRob2QuXHJcbiAgICAvLyBUT0RPPyBDb21wYXJlIE5ld3RvbidzIG1ldGhvZC5cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgdCA9IHI7XHJcbiAgICAgIHQzID0gdC50aW1lcyh0KS50aW1lcyh0KTtcclxuICAgICAgdDNwbHVzeCA9IHQzLnBsdXMoeCk7XHJcbiAgICAgIHIgPSBkaXZpZGUodDNwbHVzeC5wbHVzKHgpLnRpbWVzKHQpLCB0M3BsdXN4LnBsdXModDMpLCBzZCArIDIsIDEpO1xyXG5cclxuICAgICAgLy8gVE9ETz8gUmVwbGFjZSB3aXRoIGZvci1sb29wIGFuZCBjaGVja1JvdW5kaW5nRGlnaXRzLlxyXG4gICAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHMgYXJlIDk5OTkgb3IgNDk5OVxyXG4gICAgICAgIC8vICwgaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxyXG4gICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlIGV4YWN0IHJlc3VsdCBhcyB0aGVcclxuICAgICAgICAgIC8vIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZCArPSA0O1xyXG4gICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgYW4gZXhhY3QgcmVzdWx0LlxyXG4gICAgICAgICAgLy8gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XHJcbiAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHcsXHJcbiAgICAgIGQgPSB0aGlzLmQsXHJcbiAgICAgIG4gPSBOYU47XHJcblxyXG4gICAgaWYgKGQpIHtcclxuICAgICAgdyA9IGQubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9ICh3IC0gbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3Qgd29yZC5cclxuICAgICAgdyA9IGRbd107XHJcbiAgICAgIGlmICh3KSBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApIG4tLTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAvIDAgPSBJXHJcbiAgICogIG4gLyBOID0gTlxyXG4gICAqICBuIC8gSSA9IDBcclxuICAgKiAgMCAvIG4gPSAwXHJcbiAgICogIDAgLyAwID0gTlxyXG4gICAqICAwIC8gTiA9IE5cclxuICAgKiAgMCAvIEkgPSAwXHJcbiAgICogIE4gLyBuID0gTlxyXG4gICAqICBOIC8gMCA9IE5cclxuICAgKiAgTiAvIE4gPSBOXHJcbiAgICogIE4gLyBJID0gTlxyXG4gICAqICBJIC8gbiA9IElcclxuICAgKiAgSSAvIDAgPSBJXHJcbiAgICogIEkgLyBOID0gTlxyXG4gICAqICBJIC8gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG9cclxuICAgKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICByZXR1cm4gZGl2aWRlKHRoaXMsIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHkpKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWxcclxuICAgKiBieSB0aGUgdmFsdWUgb2YgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuICAgIHJldHVybiBmaW5hbGlzZShkaXZpZGUoeCwgbmV3IEN0b3IoeSksIDAsIDEsIDEpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAgICogZGlyZWN0aW9uIG9mIG5lZ2F0aXZlIEluZmluaXR5LlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCwgb3RoZXJ3aXNlIHJldHVyblxyXG4gICAqIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYHlgLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgdmFyIGsgPSB0aGlzLmNtcCh5KTtcclxuICAgIHJldHVybiBrID09IDEgfHwgayA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpc1xyXG4gICAqIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbMSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiBjb3NoKHgpID0gMSArIHheMi8yISArIHheNC80ISArIHheNi82ISArIC4uLlxyXG4gICAqXHJcbiAgICogY29zaCgwKSAgICAgICAgID0gMVxyXG4gICAqIGNvc2goLTApICAgICAgICA9IDFcclxuICAgKiBjb3NoKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqIGNvc2goLUluZmluaXR5KSA9IEluZmluaXR5XHJcbiAgICogY29zaChOYU4pICAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKiAgeCAgICAgICAgdGltZSB0YWtlbiAobXMpICAgcmVzdWx0XHJcbiAgICogMTAwMCAgICAgIDkgICAgICAgICAgICAgICAgIDkuODUwMzU1NTcwMDg1MjM0OTY5NGUrNDMzXHJcbiAgICogMTAwMDAgICAgIDI1ICAgICAgICAgICAgICAgIDQuNDAzNDA5MTEyODMxNDYwNzkzNmUrNDM0MlxyXG4gICAqIDEwMDAwMCAgICAxNzEgICAgICAgICAgICAgICAxLjQwMzMzMTY4MDIxMzA2MTU4OTdlKzQzNDI5XHJcbiAgICogMTAwMDAwMCAgIDM4MTcgICAgICAgICAgICAgIDEuNTE2NjA3Njk4NDAxMDQzNzcyNWUrNDM0Mjk0XHJcbiAgICogMTAwMDAwMDAgIGFiYW5kb25lZCBhZnRlciAyIG1pbnV0ZSB3YWl0XHJcbiAgICpcclxuICAgKiBUT0RPPyBDb21wYXJlIHBlcmZvcm1hbmNlIG9mIGNvc2goeCkgPSAwLjUgKiAoZXhwKHgpICsgZXhwKC14KSlcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaHlwZXJib2xpY0Nvc2luZSA9IFAuY29zaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBrLCBuLCBwciwgcm0sIGxlbixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBvbmUgPSBuZXcgQ3RvcigxKTtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcclxuICAgIGlmICh4LmlzWmVybygpKSByZXR1cm4gb25lO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gICAgbGVuID0geC5kLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IGNvcyg0eCkgPSAxIC0gOGNvc14yKHgpICsgOGNvc140KHgpICsgMVxyXG4gICAgLy8gaS5lLiBjb3MoeCkgPSAxIC0gY29zXjIoeC80KSg4IC0gOGNvc14yKHgvNCkpXHJcblxyXG4gICAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgLy8gVE9ETz8gRXN0aW1hdGlvbiByZXVzZWQgZnJvbSBjb3NpbmUoKSBhbmQgbWF5IG5vdCBiZSBvcHRpbWFsIGhlcmUuXHJcbiAgICBpZiAobGVuIDwgMzIpIHtcclxuICAgICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgICAgbiA9IE1hdGgucG93KDQsIC1rKS50b1N0cmluZygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgayA9IDE2O1xyXG4gICAgICBuID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gICAgfVxyXG5cclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyhuKSwgbmV3IEN0b3IoMSksIHRydWUpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICB2YXIgY29zaDJfeCxcclxuICAgICAgaSA9IGssXHJcbiAgICAgIGQ4ID0gbmV3IEN0b3IoOCk7XHJcbiAgICBmb3IgKDsgaS0tOykge1xyXG4gICAgICBjb3NoMl94ID0geC50aW1lcyh4KTtcclxuICAgICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZSh4LCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpc1xyXG4gICAqIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIHNpbmgoeCkgPSB4ICsgeF4zLzMhICsgeF41LzUhICsgeF43LzchICsgLi4uXHJcbiAgICpcclxuICAgKiBzaW5oKDApICAgICAgICAgPSAwXHJcbiAgICogc2luaCgtMCkgICAgICAgID0gLTBcclxuICAgKiBzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqIHNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gICAqIHNpbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogeCAgICAgICAgdGltZSB0YWtlbiAobXMpXHJcbiAgICogMTAgICAgICAgMiBtc1xyXG4gICAqIDEwMCAgICAgIDUgbXNcclxuICAgKiAxMDAwICAgICAxNCBtc1xyXG4gICAqIDEwMDAwICAgIDgyIG1zXHJcbiAgICogMTAwMDAwICAgODg2IG1zICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gICAqIDIwMDAwMCAgIDI2MTMgbXNcclxuICAgKiAzMDAwMDAgICA1NDA3IG1zXHJcbiAgICogNDAwMDAwICAgODgyNCBtc1xyXG4gICAqIDUwMDAwMCAgIDEzMDI2IG1zICAgICAgICAgIDguNzA4MDY0MzYxMjcxODA4NDEyOWUrMjE3MTQ2XHJcbiAgICogMTAwMDAwMCAgNDg1NDMgbXNcclxuICAgKlxyXG4gICAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2Ygc2luaCh4KSA9IDAuNSAqIChleHAoeCkgLSBleHAoLXgpKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5oeXBlcmJvbGljU2luZSA9IFAuc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBrLCBwciwgcm0sIGxlbixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDMpIHtcclxuICAgICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBBbHRlcm5hdGl2ZSBhcmd1bWVudCByZWR1Y3Rpb246IHNpbmgoM3gpID0gc2luaCh4KSgzICsgNHNpbmheMih4KSlcclxuICAgICAgLy8gaS5lLiBzaW5oKHgpID0gc2luaCh4LzMpKDMgKyA0c2luaF4yKHgvMykpXHJcbiAgICAgIC8vIDMgbXVsdGlwbGljYXRpb25zIGFuZCAxIGFkZGl0aW9uXHJcblxyXG4gICAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IHNpbmgoNXgpID0gc2luaCh4KSg1ICsgc2luaF4yKHgpKDIwICsgMTZzaW5oXjIoeCkpKVxyXG4gICAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvNSkoNSArIHNpbmheMih4LzUpKDIwICsgMTZzaW5oXjIoeC81KSkpXHJcbiAgICAgIC8vIDQgbXVsdGlwbGljYXRpb25zIGFuZCAyIGFkZGl0aW9uc1xyXG5cclxuICAgICAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xyXG5cclxuICAgICAgeCA9IHgudGltZXMoTWF0aC5wb3coNSwgLWspKTtcclxuXHJcbiAgICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XHJcblxyXG4gICAgICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gICAgICB2YXIgc2luaDJfeCxcclxuICAgICAgICBkNSA9IG5ldyBDdG9yKDUpLFxyXG4gICAgICAgIGQxNiA9IG5ldyBDdG9yKDE2KSxcclxuICAgICAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgICAgIGZvciAoOyBrLS07KSB7XHJcbiAgICAgICAgc2luaDJfeCA9IHgudGltZXMoeCk7XHJcbiAgICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW5oMl94LnRpbWVzKGQxNi50aW1lcyhzaW5oMl94KS5wbHVzKGQyMCkpKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpc1xyXG4gICAqIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLTEsIDFdXHJcbiAgICpcclxuICAgKiB0YW5oKHgpID0gc2luaCh4KSAvIGNvc2goeClcclxuICAgKlxyXG4gICAqIHRhbmgoMCkgICAgICAgICA9IDBcclxuICAgKiB0YW5oKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIHRhbmgoSW5maW5pdHkpICA9IDFcclxuICAgKiB0YW5oKC1JbmZpbml0eSkgPSAtMVxyXG4gICAqIHRhbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5oeXBlcmJvbGljVGFuZ2VudCA9IFAudGFuaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyk7XHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgNztcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgKGludmVyc2UgY29zaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZlxyXG4gICAqIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy0xLCAxXVxyXG4gICAqIFJhbmdlOiBbMCwgcGldXHJcbiAgICpcclxuICAgKiBhY29zKHgpID0gcGkvMiAtIGFzaW4oeClcclxuICAgKlxyXG4gICAqIGFjb3MoMCkgICAgICAgPSBwaS8yXHJcbiAgICogYWNvcygtMCkgICAgICA9IHBpLzJcclxuICAgKiBhY29zKDEpICAgICAgID0gMFxyXG4gICAqIGFjb3MoLTEpICAgICAgPSBwaVxyXG4gICAqIGFjb3MoMS8yKSAgICAgPSBwaS8zXHJcbiAgICogYWNvcygtMS8yKSAgICA9IDIqcGkvM1xyXG4gICAqIGFjb3MofHh8ID4gMSkgPSBOYU5cclxuICAgKiBhY29zKE5hTikgICAgID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VDb3NpbmUgPSBQLmFjb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaGFsZlBpLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIGsgPSB4LmFicygpLmNtcCgxKSxcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIGlmIChrICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gayA9PT0gMFxyXG4gICAgICAgIC8vIHx4fCBpcyAxXHJcbiAgICAgICAgPyB4LmlzTmVnKCkgPyBnZXRQaShDdG9yLCBwciwgcm0pIDogbmV3IEN0b3IoMClcclxuICAgICAgICAvLyB8eHwgPiAxIG9yIHggaXMgTmFOXHJcbiAgICAgICAgOiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4LmlzWmVybygpKSByZXR1cm4gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuXHJcbiAgICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYWNvcygwLjUpID0gcGkvMyBhbmQgYWNvcygtMC41KSA9IDIqcGkvM1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHguYXNpbigpO1xyXG4gICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiBoYWxmUGkubWludXMoeCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgY29zaW5lIGluIHJhZGlhbnMgb2YgdGhlXHJcbiAgICogdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbMSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFswLCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIGFjb3NoKHgpID0gbG4oeCArIHNxcnQoeF4yIC0gMSkpXHJcbiAgICpcclxuICAgKiBhY29zaCh4IDwgMSkgICAgID0gTmFOXHJcbiAgICogYWNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gICAqIGFjb3NoKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqIGFjb3NoKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiBhY29zaCgwKSAgICAgICAgID0gTmFOXHJcbiAgICogYWNvc2goLTApICAgICAgICA9IE5hTlxyXG4gICAqIGFjb3NoKDEpICAgICAgICAgPSAwXHJcbiAgICogYWNvc2goLTEpICAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKHgubHRlKDEpKSByZXR1cm4gbmV3IEN0b3IoeC5lcSgxKSA/IDAgOiBOYU4pO1xyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIHgubG4oKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAgICogb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiBhc2luaCh4KSA9IGxuKHggKyBzcXJ0KHheMiArIDEpKVxyXG4gICAqXHJcbiAgICogYXNpbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqIGFzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqIGFzaW5oKC1JbmZpbml0eSkgPSAtSW5maW5pdHlcclxuICAgKiBhc2luaCgwKSAgICAgICAgID0gMFxyXG4gICAqIGFzaW5oKC0wKSAgICAgICAgPSAtMFxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlSHlwZXJib2xpY1NpbmUgPSBQLmFzaW5oID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByLCBybSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDIgKiBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICB4ID0geC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKHgpO1xyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIHgubG4oKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IGluIHJhZGlhbnMgb2YgdGhlXHJcbiAgICogdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLTEsIDFdXHJcbiAgICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqXHJcbiAgICogYXRhbmgoeCkgPSAwLjUgKiBsbigoMSArIHgpIC8gKDEgLSB4KSlcclxuICAgKlxyXG4gICAqIGF0YW5oKHx4fCA+IDEpICAgPSBOYU5cclxuICAgKiBhdGFuaChOYU4pICAgICAgID0gTmFOXHJcbiAgICogYXRhbmgoSW5maW5pdHkpICA9IE5hTlxyXG4gICAqIGF0YW5oKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiBhdGFuaCgwKSAgICAgICAgID0gMFxyXG4gICAqIGF0YW5oKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIGF0YW5oKDEpICAgICAgICAgPSBJbmZpbml0eVxyXG4gICAqIGF0YW5oKC0xKSAgICAgICAgPSAtSW5maW5pdHlcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ID0gUC5hdGFuaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sIHdwciwgeHNkLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHguZSA+PSAwKSByZXR1cm4gbmV3IEN0b3IoeC5hYnMoKS5lcSgxKSA/IHgucyAvIDAgOiB4LmlzWmVybygpID8geCA6IE5hTik7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIHhzZCA9IHguc2QoKTtcclxuXHJcbiAgICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHhzZCAtIHguZTtcclxuXHJcbiAgICB4ID0gZGl2aWRlKHgucGx1cygxKSwgbmV3IEN0b3IoMSkubWludXMoeCksIHdwciArIHByLCAxKTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHggPSB4LmxuKCk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4geC50aW1lcygwLjUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNzaW5lIChpbnZlcnNlIHNpbmUpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1waS8yLCBwaS8yXVxyXG4gICAqXHJcbiAgICogYXNpbih4KSA9IDIqYXRhbih4LygxICsgc3FydCgxIC0geF4yKSkpXHJcbiAgICpcclxuICAgKiBhc2luKDApICAgICAgID0gMFxyXG4gICAqIGFzaW4oLTApICAgICAgPSAtMFxyXG4gICAqIGFzaW4oMS8yKSAgICAgPSBwaS82XHJcbiAgICogYXNpbigtMS8yKSAgICA9IC1waS82XHJcbiAgICogYXNpbigxKSAgICAgICA9IHBpLzJcclxuICAgKiBhc2luKC0xKSAgICAgID0gLXBpLzJcclxuICAgKiBhc2luKHx4fCA+IDEpID0gTmFOXHJcbiAgICogYXNpbihOYU4pICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBUYXlsb3Igc2VyaWVzLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlU2luZSA9IFAuYXNpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBoYWxmUGksIGssXHJcbiAgICAgIHByLCBybSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgayA9IHguYWJzKCkuY21wKDEpO1xyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICBpZiAoayAhPT0gLTEpIHtcclxuXHJcbiAgICAgIC8vIHx4fCBpcyAxXHJcbiAgICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuICAgICAgICBoYWxmUGkucyA9IHgucztcclxuICAgICAgICByZXR1cm4gaGFsZlBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB8eHwgPiAxIG9yIHggaXMgTmFOXHJcbiAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8/IFNwZWNpYWwgY2FzZSBhc2luKDEvMikgPSBwaS82IGFuZCBhc2luKC0xLzIpID0gLXBpLzZcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIHggPSB4LmRpdihuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIHgudGltZXMoMik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3RhbmdlbnQgKGludmVyc2UgdGFuZ2VudCkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWVcclxuICAgKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAgICpcclxuICAgKiBhdGFuKHgpID0geCAtIHheMy8zICsgeF41LzUgLSB4XjcvNyArIC4uLlxyXG4gICAqXHJcbiAgICogYXRhbigwKSAgICAgICAgID0gMFxyXG4gICAqIGF0YW4oLTApICAgICAgICA9IC0wXHJcbiAgICogYXRhbigxKSAgICAgICAgID0gcGkvNFxyXG4gICAqIGF0YW4oLTEpICAgICAgICA9IC1waS80XHJcbiAgICogYXRhbihJbmZpbml0eSkgID0gcGkvMlxyXG4gICAqIGF0YW4oLUluZmluaXR5KSA9IC1waS8yXHJcbiAgICogYXRhbihOYU4pICAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VUYW5nZW50ID0gUC5hdGFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGksIGosIGssIG4sIHB4LCB0LCByLCB3cHIsIHgyLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkge1xyXG4gICAgICBpZiAoIXgucykgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICAgIGlmIChwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgICAgci5zID0geC5zO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHguaXNaZXJvKCkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gICAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuMjUpO1xyXG4gICAgICByLnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcclxuICAgIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAgIC8vIFRPRE8/IGlmICh4ID49IDEgJiYgcHIgPD0gUElfUFJFQ0lTSU9OKSBhdGFuKHgpID0gaGFsZlBpICogeC5zIC0gYXRhbigxIC8geCk7XHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICAvLyBFbnN1cmUgfHh8IDwgMC40MlxyXG4gICAgLy8gYXRhbih4KSA9IDIgKiBhdGFuKHggLyAoMSArIHNxcnQoMSArIHheMikpKVxyXG5cclxuICAgIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XHJcblxyXG4gICAgZm9yIChpID0gazsgaTsgLS1pKSB4ID0geC5kaXYoeC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIGogPSBNYXRoLmNlaWwod3ByIC8gTE9HX0JBU0UpO1xyXG4gICAgbiA9IDE7XHJcbiAgICB4MiA9IHgudGltZXMoeCk7XHJcbiAgICByID0gbmV3IEN0b3IoeCk7XHJcbiAgICBweCA9IHg7XHJcblxyXG4gICAgLy8gYXRhbih4KSA9IHggLSB4XjMvMyArIHheNS81IC0geF43LzcgKyAuLi5cclxuICAgIGZvciAoOyBpICE9PSAtMTspIHtcclxuICAgICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICAgIHQgPSByLm1pbnVzKHB4LmRpdihuICs9IDIpKTtcclxuXHJcbiAgICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcclxuXHJcbiAgICAgIGlmIChyLmRbal0gIT09IHZvaWQgMCkgZm9yIChpID0gajsgci5kW2ldID09PSB0LmRbaV0gJiYgaS0tOyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGspIHIgPSByLnRpbWVzKDIgPDwgKGsgLSAxKSk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuZDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmQgJiYgbWF0aGZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuZC5sZW5ndGggLSAyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5zO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuZCAmJiB0aGlzLmRbMF0gPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIGxvZ2FyaXRobSBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRvIHRoZSBzcGVjaWZpZWQgYmFzZSwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBJZiBubyBiYXNlIGlzIHNwZWNpZmllZCwgcmV0dXJuIGxvZ1sxMF0oYXJnKS5cclxuICAgKlxyXG4gICAqIGxvZ1tiYXNlXShhcmcpID0gbG4oYXJnKSAvIGxuKGJhc2UpXHJcbiAgICpcclxuICAgKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkIGlmIHRoZSBiYXNlIG9mIHRoZSBsb2cgaXMgMTAsIGFuZCAnYWxtb3N0IGFsd2F5cydcclxuICAgKiBvdGhlcndpc2U6XHJcbiAgICpcclxuICAgKiBEZXBlbmRpbmcgb24gdGhlIHJvdW5kaW5nIG1vZGUsIHRoZSByZXN1bHQgbWF5IGJlIGluY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGZpcnN0IGZpZnRlZW5cclxuICAgKiByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5OTk5OTk5OTk5OSBvciBbNTBdMDAwMDAwMDAwMDAwMDAuIEluIHRoYXQgY2FzZSwgdGhlIG1heGltdW0gZXJyb3JcclxuICAgKiBiZXR3ZWVuIHRoZSByZXN1bHQgYW5kIHRoZSBjb3JyZWN0bHkgcm91bmRlZCByZXN1bHQgd2lsbCBiZSBvbmUgdWxwICh1bml0IGluIHRoZSBsYXN0IHBsYWNlKS5cclxuICAgKlxyXG4gICAqIGxvZ1stYl0oYSkgICAgICAgPSBOYU5cclxuICAgKiBsb2dbMF0oYSkgICAgICAgID0gTmFOXHJcbiAgICogbG9nWzFdKGEpICAgICAgICA9IE5hTlxyXG4gICAqIGxvZ1tOYU5dKGEpICAgICAgPSBOYU5cclxuICAgKiBsb2dbSW5maW5pdHldKGEpID0gTmFOXHJcbiAgICogbG9nW2JdKDApICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqIGxvZ1tiXSgtMCkgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiBsb2dbYl0oLWEpICAgICAgID0gTmFOXHJcbiAgICogbG9nW2JdKDEpICAgICAgICA9IDBcclxuICAgKiBsb2dbYl0oSW5maW5pdHkpID0gSW5maW5pdHlcclxuICAgKiBsb2dbYl0oTmFOKSAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKiBbYmFzZV0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLFxyXG4gICAgICBhcmcgPSB0aGlzLFxyXG4gICAgICBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICAgIGd1YXJkID0gNTtcclxuXHJcbiAgICAvLyBEZWZhdWx0IGJhc2UgaXMgMTAuXHJcbiAgICBpZiAoYmFzZSA9PSBudWxsKSB7XHJcbiAgICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XHJcbiAgICAgIGlzQmFzZTEwID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcclxuICAgICAgZCA9IGJhc2UuZDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgYmFzZSBpcyBuZWdhdGl2ZSwgb3Igbm9uLWZpbml0ZSwgb3IgaXMgMCBvciAxLlxyXG4gICAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAgIGlzQmFzZTEwID0gYmFzZS5lcSgxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZCA9IGFyZy5kO1xyXG5cclxuICAgIC8vIElzIGFyZyBuZWdhdGl2ZSwgbm9uLWZpbml0ZSwgMCBvciAxP1xyXG4gICAgaWYgKGFyZy5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBhcmcuZXEoMSkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgYSBub24tdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb24gaWYgYmFzZSBpcyAxMCBhbmQgYXJnIGlzIG5vdCBhblxyXG4gICAgLy8gaW50ZWdlciBwb3dlciBvZiAxMC5cclxuICAgIGlmIChpc0Jhc2UxMCkge1xyXG4gICAgICBpZiAoZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgaW5mID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGsgPSBkWzBdOyBrICUgMTAgPT09IDA7KSBrIC89IDEwO1xyXG4gICAgICAgIGluZiA9IGsgIT09IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgc2QgPSBwciArIGd1YXJkO1xyXG4gICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcclxuICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcblxyXG4gICAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgNSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcclxuXHJcbiAgICAvLyBJZiBhdCBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBpLmUuIHRoZSByZXN1bHQncyByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwLFxyXG4gICAgLy8gY2FsY3VsYXRlIDEwIGZ1cnRoZXIgZGlnaXRzLlxyXG4gICAgLy9cclxuICAgIC8vIElmIHRoZSByZXN1bHQgaXMga25vd24gdG8gaGF2ZSBhbiBpbmZpbml0ZSBkZWNpbWFsIGV4cGFuc2lvbiwgcmVwZWF0IHRoaXMgdW50aWwgaXQgaXMgY2xlYXJcclxuICAgIC8vIHRoYXQgdGhlIHJlc3VsdCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgYm91bmRhcnkuIE90aGVyd2lzZSwgaWYgYWZ0ZXIgY2FsY3VsYXRpbmcgdGhlIDEwXHJcbiAgICAvLyBmdXJ0aGVyIGRpZ2l0cywgdGhlIGxhc3QgMTQgYXJlIG5pbmVzLCByb3VuZCB1cCBhbmQgYXNzdW1lIHRoZSByZXN1bHQgaXMgZXhhY3QuXHJcbiAgICAvLyBBbHNvIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0IGlmIHRoZSBsYXN0IDE0IGFyZSB6ZXJvLlxyXG4gICAgLy9cclxuICAgIC8vIEV4YW1wbGUgb2YgYSByZXN1bHQgdGhhdCB3aWxsIGJlIGluY29ycmVjdGx5IHJvdW5kZWQ6XHJcbiAgICAvLyBsb2dbMTA0ODU3Nl0oNDUwMzU5OTYyNzM3MDUwMikgPSAyLjYwMDAwMDAwMDAwMDAwMDA5NjEwMjc5NTExNDQ0NzQ2Li4uXHJcbiAgICAvLyBUaGUgYWJvdmUgcmVzdWx0IGNvcnJlY3RseSByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsIHBsYWNlIHNob3VsZCBiZSAyLjcsIGJ1dCBpdFxyXG4gICAgLy8gd2lsbCBiZSBnaXZlbiBhcyAyLjYgYXMgdGhlcmUgYXJlIDE1IHplcm9zIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXF1ZXN0ZWQgZGVjaW1hbCBwbGFjZSwgc29cclxuICAgIC8vIHRoZSBleGFjdCByZXN1bHQgd291bGQgYmUgYXNzdW1lZCB0byBiZSAyLjYsIHdoaWNoIHJvdW5kZWQgdXNpbmcgUk9VTkRfQ0VJTCB0byAxIGRlY2ltYWxcclxuICAgIC8vIHBsYWNlIGlzIHN0aWxsIDIuNi5cclxuICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayA9IHByLCBybSkpIHtcclxuXHJcbiAgICAgIGRvIHtcclxuICAgICAgICBzZCArPSAxMDtcclxuICAgICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xyXG4gICAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcbiAgICAgICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XHJcblxyXG4gICAgICAgIGlmICghaW5mKSB7XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCwgYXMgdGhlIGZpcnN0IG1heSBiZSA0LlxyXG4gICAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKGsgKyAxLCBrICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gIFAubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChhcmd1bWVudHMsIHRoaXMpO1xyXG4gICAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbiAgfTtcclxuICAgKi9cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cyBhbmQgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgUC5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4odGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCAnZ3QnKTtcclxuICB9O1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAtIDAgPSBuXHJcbiAgICogIG4gLSBOID0gTlxyXG4gICAqICBuIC0gSSA9IC1JXHJcbiAgICogIDAgLSBuID0gLW5cclxuICAgKiAgMCAtIDAgPSAwXHJcbiAgICogIDAgLSBOID0gTlxyXG4gICAqICAwIC0gSSA9IC1JXHJcbiAgICogIE4gLSBuID0gTlxyXG4gICAqICBOIC0gMCA9IE5cclxuICAgKiAgTiAtIE4gPSBOXHJcbiAgICogIE4gLSBJID0gTlxyXG4gICAqICBJIC0gbiA9IElcclxuICAgKiAgSSAtIDAgPSBJXHJcbiAgICogIEkgLSBOID0gTlxyXG4gICAqICBJIC0gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gICAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICAgIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geSBuZWdhdGVkIGlmIHggaXMgZmluaXRlIGFuZCB5IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgIGVsc2UgaWYgKHguZCkgeS5zID0gLXkucztcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCBkaWZmZXJlbnQgc2lnbnMuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcbiAgICAgIGVsc2UgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0geC5kO1xyXG4gICAgeWQgPSB5LmQ7XHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIC8vIElmIGVpdGhlciBpcyB6ZXJvLi4uXHJcbiAgICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIHplcm8gYW5kIHkgaXMgbm9uLXplcm8uXHJcbiAgICAgIGlmICh5ZFswXSkgeS5zID0gLXkucztcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVybyBhbmQgeCBpcyBub24temVyby5cclxuICAgICAgZWxzZSBpZiAoeGRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIC8vIEZyb20gSUVFRSA3NTQgKDIwMDgpIDYuMzogMCAtIDAgPSAtMCAtIC0wID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHkuXHJcbiAgICAgIGVsc2UgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcclxuXHJcbiAgICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICAgIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgIHhkID0geGQuc2xpY2UoKTtcclxuICAgIGsgPSB4ZSAtIGU7XHJcblxyXG4gICAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gICAgaWYgKGspIHtcclxuICAgICAgeExUeSA9IGsgPCAwO1xyXG5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICBkID0geGQ7XHJcbiAgICAgICAgayA9IC1rO1xyXG4gICAgICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkID0geWQ7XHJcbiAgICAgICAgZSA9IHhlO1xyXG4gICAgICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTnVtYmVycyB3aXRoIG1hc3NpdmVseSBkaWZmZXJlbnQgZXhwb25lbnRzIHdvdWxkIHJlc3VsdCBpbiBhIHZlcnkgaGlnaCBudW1iZXIgb2ZcclxuICAgICAgLy8gemVyb3MgbmVlZGluZyB0byBiZSBwcmVwZW5kZWQsIGJ1dCB0aGlzIGNhbiBiZSBhdm9pZGVkIHdoaWxlIHN0aWxsIGVuc3VyaW5nIGNvcnJlY3RcclxuICAgICAgLy8gcm91bmRpbmcgYnkgbGltaXRpbmcgdGhlIG51bWJlciBvZiB6ZXJvcyB0byBgTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpICsgMmAuXHJcbiAgICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xyXG5cclxuICAgICAgaWYgKGsgPiBpKSB7XHJcbiAgICAgICAgayA9IGk7XHJcbiAgICAgICAgZC5sZW5ndGggPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgZC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoaSA9IGs7IGktLTspIGQucHVzaCgwKTtcclxuICAgICAgZC5yZXZlcnNlKCk7XHJcblxyXG4gICAgLy8gQmFzZSAxZTcgZXhwb25lbnRzIGVxdWFsLlxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIENoZWNrIGRpZ2l0cyB0byBkZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcblxyXG4gICAgICBpID0geGQubGVuZ3RoO1xyXG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICAgIHhMVHkgPSBpIDwgbGVuO1xyXG4gICAgICBpZiAoeExUeSkgbGVuID0gaTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xyXG4gICAgICAgICAgeExUeSA9IHhkW2ldIDwgeWRbaV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGsgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4TFR5KSB7XHJcbiAgICAgIGQgPSB4ZDtcclxuICAgICAgeGQgPSB5ZDtcclxuICAgICAgeWQgPSBkO1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgfVxyXG5cclxuICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MgdG8gYHhkYCBpZiBzaG9ydGVyLlxyXG4gICAgLy8gRG9uJ3QgYWRkIHplcm9zIHRvIGB5ZGAgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IGB5ZGAgbGVuZ3RoLlxyXG4gICAgZm9yIChpID0geWQubGVuZ3RoIC0gbGVuOyBpID4gMDsgLS1pKSB4ZFtsZW4rK10gPSAwO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHlkIGZyb20geGQuXHJcbiAgICBmb3IgKGkgPSB5ZC5sZW5ndGg7IGkgPiBrOykge1xyXG5cclxuICAgICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xyXG4gICAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDspIHhkW2pdID0gQkFTRSAtIDE7XHJcbiAgICAgICAgLS14ZFtqXTtcclxuICAgICAgICB4ZFtpXSArPSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZFtpXSAtPSB5ZFtpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgeGRbLS1sZW5dID09PSAwOykgeGQucG9wKCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSkgLS1lO1xyXG5cclxuICAgIC8vIFplcm8/XHJcbiAgICBpZiAoIXhkWzBdKSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xyXG5cclxuICAgIHkuZCA9IHhkO1xyXG4gICAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xyXG5cclxuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgbW9kdWxvIG1vZGUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBxLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsUluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgwrEwLlxyXG4gICAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyDCsUluZmluaXR5IG9yIHggaXMgwrEwLlxyXG4gICAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcclxuICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJldmVudCByb3VuZGluZyBvZiBpbnRlcm1lZGlhdGUgY2FsY3VsYXRpb25zLlxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xyXG5cclxuICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgIC8vIHJlc3VsdCA9IHggLSBxICogeSAgICB3aGVyZSAgMCA8PSByZXN1bHQgPCBhYnMoeSlcclxuICAgICAgcSA9IGRpdmlkZSh4LCB5LmFicygpLCAwLCAzLCAxKTtcclxuICAgICAgcS5zICo9IHkucztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHEgPSBkaXZpZGUoeCwgeSwgMCwgQ3Rvci5tb2R1bG8sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHEgPSBxLnRpbWVzKHkpO1xyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geC5taW51cyhxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gICAqIGkuZS4gdGhlIGJhc2UgZSByYWlzZWQgdG8gdGhlIHBvd2VyIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAgICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5uYXR1cmFsTG9nYXJpdGhtID0gUC5sbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbmVnYXRlZCwgaS5lLiBhcyBpZiBtdWx0aXBsaWVkIGJ5XHJcbiAgICogLTEuXHJcbiAgICpcclxuICAgKi9cclxuICBQLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgICB4LnMgPSAteC5zO1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHgpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBwbHVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gICAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICAgIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIGZpbml0ZSBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgICAvLyBSZXR1cm4geSBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgICBlbHNlIGlmICgheC5kKSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB4ZCA9IHguZDtcclxuICAgIHlkID0geS5kO1xyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gICAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVyby5cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVyby5cclxuICAgICAgaWYgKCF5ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8geCBhbmQgeSBhcmUgZmluaXRlLCBub24temVybyBudW1iZXJzIHdpdGggdGhlIHNhbWUgc2lnbi5cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYmFzZSAxZTcgZXhwb25lbnRzLlxyXG4gICAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcbiAgICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgICB4ZCA9IHhkLnNsaWNlKCk7XHJcbiAgICBpID0gayAtIGU7XHJcblxyXG4gICAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gICAgaWYgKGkpIHtcclxuXHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGQgPSB4ZDtcclxuICAgICAgICBpID0gLWk7XHJcbiAgICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGQgPSB5ZDtcclxuICAgICAgICBlID0gaztcclxuICAgICAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExpbWl0IG51bWJlciBvZiB6ZXJvcyBwcmVwZW5kZWQgdG8gbWF4KGNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAxLlxyXG4gICAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xyXG4gICAgICBsZW4gPSBrID4gbGVuID8gayArIDEgOiBsZW4gKyAxO1xyXG5cclxuICAgICAgaWYgKGkgPiBsZW4pIHtcclxuICAgICAgICBpID0gbGVuO1xyXG4gICAgICAgIGQubGVuZ3RoID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIE5vdGU6IEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBkLnJldmVyc2UoKTtcclxuICAgICAgZm9yICg7IGktLTspIGQucHVzaCgwKTtcclxuICAgICAgZC5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgaSA9IHlkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBJZiB5ZCBpcyBsb25nZXIgdGhhbiB4ZCwgc3dhcCB4ZCBhbmQgeWQgc28geGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgICBpZiAobGVuIC0gaSA8IDApIHtcclxuICAgICAgaSA9IGxlbjtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICB5ZCA9IHhkO1xyXG4gICAgICB4ZCA9IGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWQubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGQgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgICBmb3IgKGNhcnJ5ID0gMDsgaTspIHtcclxuICAgICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcclxuICAgICAgeGRbaV0gJT0gQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FycnkpIHtcclxuICAgICAgeGQudW5zaGlmdChjYXJyeSk7XHJcbiAgICAgICsrZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgICB5LmQgPSB4ZDtcclxuICAgIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFt6XSB7Ym9vbGVhbnxudW1iZXJ9IFdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcclxuICAgIHZhciBrLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoeiAhPT0gdm9pZCAwICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDApIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHopO1xyXG5cclxuICAgIGlmICh4LmQpIHtcclxuICAgICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xyXG4gICAgICBpZiAoeiAmJiB4LmUgKyAxID4gaykgayA9IHguZSArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrID0gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciB1c2luZ1xyXG4gICAqIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAucm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy0xLCAxXVxyXG4gICAqXHJcbiAgICogc2luKHgpID0geCAtIHheMy8zISArIHheNS81ISAtIC4uLlxyXG4gICAqXHJcbiAgICogc2luKDApICAgICAgICAgPSAwXHJcbiAgICogc2luKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIHNpbihJbmZpbml0eSkgID0gTmFOXHJcbiAgICogc2luKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiBzaW4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5zaW5lID0gUC5zaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAqICBzcXJ0KE4pICA9ICBOXHJcbiAgICogIHNxcnQoLUkpID0gIE5cclxuICAgKiAgc3FydChJKSAgPSAgSVxyXG4gICAqICBzcXJ0KDApICA9ICAwXHJcbiAgICogIHNxcnQoLTApID0gLTBcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgZCA9IHguZCxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgcyA9IHgucyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICBpZiAocyAhPT0gMSB8fCAhZCB8fCAhZFswXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoIXMgfHwgcyA8IDAgJiYgKCFkIHx8IGRbMF0pID8gTmFOIDogZCA/IHggOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgcyA9IE1hdGguc3FydCgreCk7XHJcblxyXG4gICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGRpZ2l0c1RvU3RyaW5nKGQpO1xyXG5cclxuICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgcyA9IE1hdGguc3FydChuKTtcclxuICAgICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzFlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEN0b3Iobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIHQgPSByO1xyXG4gICAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xyXG5cclxuICAgICAgLy8gVE9ETz8gUmVwbGFjZSB3aXRoIGZvci1sb29wIGFuZCBjaGVja1JvdW5kaW5nRGlnaXRzLlxyXG4gICAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHMgYXJlIDk5OTkgb3JcclxuICAgICAgICAvLyA0OTk5LCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiB0YW4oMCkgICAgICAgICA9IDBcclxuICAgKiB0YW4oLTApICAgICAgICA9IC0wXHJcbiAgICogdGFuKEluZmluaXR5KSAgPSBOYU5cclxuICAgKiB0YW4oLUluZmluaXR5KSA9IE5hTlxyXG4gICAqIHRhbihOYU4pICAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRhbmdlbnQgPSBQLnRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgMTA7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0geC5zaW4oKTtcclxuICAgIHgucyA9IDE7XHJcbiAgICB4ID0gZGl2aWRlKHgsIG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKSwgcHIgKyAxMCwgMCk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSA0ID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGlzIERlY2ltYWwgdGltZXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgY2FycnksIGUsIGksIGssIHIsIHJMLCB0LCB4ZEwsIHlkTCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICB4ZCA9IHguZCxcclxuICAgICAgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xyXG5cclxuICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgIC8vIElmIGVpdGhlciBpcyBOYU4sIMKxSW5maW5pdHkgb3IgwrEwLi4uXHJcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGRcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsTAgYW5kIHkgaXMgwrFJbmZpbml0eSwgb3IgeSBpcyDCsTAgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgICAgICA/IE5hTlxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIHhkTCA9IHhkLmxlbmd0aDtcclxuICAgIHlkTCA9IHlkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgICBpZiAoeGRMIDwgeWRMKSB7XHJcbiAgICAgIHIgPSB4ZDtcclxuICAgICAgeGQgPSB5ZDtcclxuICAgICAgeWQgPSByO1xyXG4gICAgICByTCA9IHhkTDtcclxuICAgICAgeGRMID0geWRMO1xyXG4gICAgICB5ZEwgPSByTDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgIHIgPSBbXTtcclxuICAgIHJMID0geGRMICsgeWRMO1xyXG4gICAgZm9yIChpID0gckw7IGktLTspIHIucHVzaCgwKTtcclxuXHJcbiAgICAvLyBNdWx0aXBseSFcclxuICAgIGZvciAoaSA9IHlkTDsgLS1pID49IDA7KSB7XHJcbiAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgZm9yIChrID0geGRMICsgaTsgayA+IGk7KSB7XHJcbiAgICAgICAgdCA9IHJba10gKyB5ZFtpXSAqIHhkW2sgLSBpIC0gMV0gKyBjYXJyeTtcclxuICAgICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XHJcbiAgICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhclstLXJMXTspIHIucG9wKCk7XHJcblxyXG4gICAgaWYgKGNhcnJ5KSArK2U7XHJcbiAgICBlbHNlIHIuc2hpZnQoKTtcclxuXHJcbiAgICB5LmQgPSByO1xyXG4gICAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQociwgZSk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSAyLCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0JpbmFyeSA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIG1heGltdW0gb2YgYGRwYFxyXG4gICAqIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCBvciBgcm91bmRpbmdgIGlmIGBybWAgaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIElmIGBkcGAgaXMgb21pdHRlZCwgcmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHggPSBuZXcgQ3Rvcih4KTtcclxuICAgIGlmIChkcCA9PT0gdm9pZCAwKSByZXR1cm4geDtcclxuXHJcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG9cclxuICAgKiBgZHBgIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSwgZHAgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBub3JtYWwgKGZpeGVkLXBvaW50KSBub3RhdGlvbiB0b1xyXG4gICAqIGBkcGAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gIG9yIGByb3VuZGluZ2AgaWYgYHJtYCBpc1xyXG4gICAqIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBBcyB3aXRoIEphdmFTY3JpcHQgbnVtYmVycywgKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAqICgtMCkudG9GaXhlZCgxKSBpcyAnMC4wJywgYnV0ICgtMC4wMSkudG9GaXhlZCgxKSBpcyAnLTAuMCcuXHJcbiAgICogKC0wKS50b0ZpeGVkKDMpIGlzICcwLjAwMCcuXHJcbiAgICogKC0wLjUpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciBzdHIsIHksXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoZHAgPT09IHZvaWQgMCkge1xyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvIGRldGVybWluZSB3aGV0aGVyIHRvIGFkZCB0aGUgbWludXMgc2lnbiBsb29rIGF0IHRoZSB2YWx1ZSBiZWZvcmUgaXQgd2FzIHJvdW5kZWQsXHJcbiAgICAvLyBpLmUuIGxvb2sgYXQgYHhgIHJhdGhlciB0aGFuIGB5YC5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGFzIGEgc2ltcGxlIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlclxyXG4gICAqIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgKlxyXG4gICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bVxyXG4gICAqIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgdGhlIGxvd2VzdFxyXG4gICAqIHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAqXHJcbiAgICogW21heERdIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IE1heGltdW0gZGVub21pbmF0b3IuIEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtYXhEKSB7XHJcbiAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgcixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXhkKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgbjEgPSBkMCA9IG5ldyBDdG9yKDEpO1xyXG4gICAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xyXG5cclxuICAgIGQgPSBuZXcgQ3RvcihkMSk7XHJcbiAgICBlID0gZC5lID0gZ2V0UHJlY2lzaW9uKHhkKSAtIHguZSAtIDE7XHJcbiAgICBrID0gZSAlIExPR19CQVNFO1xyXG4gICAgZC5kWzBdID0gbWF0aHBvdygxMCwgayA8IDAgPyBMT0dfQkFTRSArIGsgOiBrKTtcclxuXHJcbiAgICBpZiAobWF4RCA9PSBudWxsKSB7XHJcblxyXG4gICAgICAvLyBkIGlzIDEwKiplLCB0aGUgbWluaW11bSBtYXgtZGVub21pbmF0b3IgbmVlZGVkLlxyXG4gICAgICBtYXhEID0gZSA+IDAgPyBkIDogbjE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gbmV3IEN0b3IobWF4RCk7XHJcbiAgICAgIGlmICghbi5pc0ludCgpIHx8IG4ubHQobjEpKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBuKTtcclxuICAgICAgbWF4RCA9IG4uZ3QoZCkgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgbiA9IG5ldyBDdG9yKGRpZ2l0c1RvU3RyaW5nKHhkKSk7XHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBlID0geGQubGVuZ3RoICogTE9HX0JBU0UgKiAyO1xyXG5cclxuICAgIGZvciAoOzspICB7XHJcbiAgICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XHJcbiAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgIGlmIChkMi5jbXAobWF4RCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgIGQwID0gZDE7XHJcbiAgICAgIGQxID0gZDI7XHJcbiAgICAgIGQyID0gbjE7XHJcbiAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XHJcbiAgICAgIG4wID0gZDI7XHJcbiAgICAgIGQyID0gZDtcclxuICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xyXG4gICAgICBuID0gZDI7XHJcbiAgICB9XHJcblxyXG4gICAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcclxuICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICBuMC5zID0gbjEucyA9IHgucztcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxP1xyXG4gICAgciA9IGRpdmlkZShuMSwgZDEsIGUsIDEpLm1pbnVzKHgpLmFicygpLmNtcChkaXZpZGUobjAsIGQwLCBlLCAxKS5taW51cyh4KS5hYnMoKSkgPCAxXHJcbiAgICAgICAgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgMTYsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDE2LCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYHlgIGluIHRoZSBkaXJlY3Rpb24gb2Ygcm91bmRpbmdcclxuICAgKiBtb2RlIGBybWAsIG9yIGBEZWNpbWFsLnJvdW5kaW5nYCBpZiBgcm1gIGlzIG9taXR0ZWQsIHRvIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgc2lnbiBhcyB0aGlzIERlY2ltYWwsIHVubGVzcyBlaXRoZXIgdGhpcyBEZWNpbWFsXHJcbiAgICogb3IgYHlgIGlzIE5hTiwgaW4gd2hpY2ggY2FzZSB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYWxzbyBiZSBOYU4uXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAuXHJcbiAgICpcclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBtYWduaXR1ZGUgdG8gcm91bmQgdG8gYSBtdWx0aXBsZSBvZi5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvTmVhcmVzdCA9IGZ1bmN0aW9uICh5LCBybSkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB4ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgaWYgKHkgPT0gbnVsbCkge1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geC5cclxuICAgICAgaWYgKCF4LmQpIHJldHVybiB4O1xyXG5cclxuICAgICAgeSA9IG5ldyBDdG9yKDEpO1xyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5ID0gbmV3IEN0b3IoeSk7XHJcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIG5vdCBmaW5pdGUsIHJldHVybiB4IGlmIHkgaXMgbm90IE5hTiwgZWxzZSBOYU4uXHJcbiAgICAgIGlmICgheC5kKSByZXR1cm4geS5zID8geCA6IHk7XHJcblxyXG4gICAgICAvLyBJZiB5IGlzIG5vdCBmaW5pdGUsIHJldHVybiBJbmZpbml0eSB3aXRoIHRoZSBzaWduIG9mIHggaWYgeSBpcyBJbmZpbml0eSwgZWxzZSBOYU4uXHJcbiAgICAgIGlmICgheS5kKSB7XHJcbiAgICAgICAgaWYgKHkucykgeS5zID0geC5zO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgeSBpcyBub3QgemVybywgY2FsY3VsYXRlIHRoZSBuZWFyZXN0IG11bHRpcGxlIG9mIHkgdG8geC5cclxuICAgIGlmICh5LmRbMF0pIHtcclxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XHJcbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgICAgZmluYWxpc2UoeCk7XHJcblxyXG4gICAgLy8gSWYgeSBpcyB6ZXJvLCByZXR1cm4gemVybyB3aXRoIHRoZSBzaWduIG9mIHguXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB5LnMgPSB4LnM7XHJcbiAgICAgIHggPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICogWmVybyBrZWVwcyBpdHMgc2lnbi5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gK3RoaXM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgOCwgcm91bmQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAgICpcclxuICAgKiBJZiB0aGUgb3B0aW9uYWwgYHNkYCBhcmd1bWVudCBpcyBwcmVzZW50IHRoZW4gcmV0dXJuIGJpbmFyeSBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9PY3RhbCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcmFpc2VkIHRvIHRoZSBwb3dlciBgeWAsIHJvdW5kZWRcclxuICAgKiB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogRUNNQVNjcmlwdCBjb21wbGlhbnQuXHJcbiAgICpcclxuICAgKiAgIHBvdyh4LCBOYU4pICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBOYU5cclxuICAgKiAgIHBvdyh4LCDCsTApICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMVxyXG5cclxuICAgKiAgIHBvdyhOYU4sIG5vbi16ZXJvKSAgICAgICAgICAgICAgICAgICAgPSBOYU5cclxuICAgKiAgIHBvdyhhYnMoeCkgPiAxLCArSW5maW5pdHkpICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdyhhYnMoeCkgPiAxLCAtSW5maW5pdHkpICAgICAgICAgICAgPSArMFxyXG4gICAqICAgcG93KGFicyh4KSA9PSAxLCDCsUluZmluaXR5KSAgICAgICAgICAgPSBOYU5cclxuICAgKiAgIHBvdyhhYnMoeCkgPCAxLCArSW5maW5pdHkpICAgICAgICAgICAgPSArMFxyXG4gICAqICAgcG93KGFicyh4KSA8IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KCtJbmZpbml0eSwgeSA+IDApICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KCtJbmZpbml0eSwgeSA8IDApICAgICAgICAgICAgICAgICA9ICswXHJcbiAgICogICBwb3coLUluZmluaXR5LCBvZGQgaW50ZWdlciA+IDApICAgICAgID0gLUluZmluaXR5XHJcbiAgICogICBwb3coLUluZmluaXR5LCBldmVuIGludGVnZXIgPiAwKSAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coLUluZmluaXR5LCBvZGQgaW50ZWdlciA8IDApICAgICAgID0gLTBcclxuICAgKiAgIHBvdygtSW5maW5pdHksIGV2ZW4gaW50ZWdlciA8IDApICAgICAgPSArMFxyXG4gICAqICAgcG93KCswLCB5ID4gMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICswXHJcbiAgICogICBwb3coKzAsIHkgPCAwKSAgICAgICAgICAgICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coLTAsIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgID0gLTBcclxuICAgKiAgIHBvdygtMCwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgPSArMFxyXG4gICAqICAgcG93KC0wLCBvZGQgaW50ZWdlciA8IDApICAgICAgICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqICAgcG93KC0wLCBldmVuIGludGVnZXIgPCAwKSAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KGZpbml0ZSB4IDwgMCwgZmluaXRlIG5vbi1pbnRlZ2VyKSA9IE5hTlxyXG4gICAqXHJcbiAgICogRm9yIG5vbi1pbnRlZ2VyIG9yIHZlcnkgbGFyZ2UgZXhwb25lbnRzIHBvdyh4LCB5KSBpcyBjYWxjdWxhdGVkIHVzaW5nXHJcbiAgICpcclxuICAgKiAgIHheeSA9IGV4cCh5KmxuKHgpKVxyXG4gICAqXHJcbiAgICogQXNzdW1pbmcgdGhlIGZpcnN0IDE1IHJvdW5kaW5nIGRpZ2l0cyBhcmUgZWFjaCBlcXVhbGx5IGxpa2VseSB0byBiZSBhbnkgZGlnaXQgMC05LCB0aGVcclxuICAgKiBwcm9iYWJpbGl0eSBvZiBhbiBpbmNvcnJlY3RseSByb3VuZGVkIHJlc3VsdFxyXG4gICAqIFAoWzQ5XTl7MTR9IHwgWzUwXTB7MTR9KSA9IDIgKiAwLjIgKiAxMF4tMTQgPSA0ZS0xNSA9IDEvMi41ZSsxNFxyXG4gICAqIGkuZS4gMSBpbiAyNTAsMDAwLDAwMCwwMDAsMDAwXHJcbiAgICpcclxuICAgKiBJZiBhIHJlc3VsdCBpcyBpbmNvcnJlY3RseSByb3VuZGVkIHRoZSBtYXhpbXVtIGVycm9yIHdpbGwgYmUgMSB1bHAgKHVuaXQgaW4gbGFzdCBwbGFjZSkuXHJcbiAgICpcclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBwb3dlciB0byB3aGljaCB0byByYWlzZSB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvUG93ZXIgPSBQLnBvdyA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgZSwgaywgcHIsIHIsIHJtLCBzLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHluID0gKyh5ID0gbmV3IEN0b3IoeSkpO1xyXG5cclxuICAgIC8vIEVpdGhlciDCsUluZmluaXR5LCBOYU4gb3IgwrEwP1xyXG4gICAgaWYgKCF4LmQgfHwgIXkuZCB8fCAheC5kWzBdIHx8ICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihtYXRocG93KCt4LCB5bikpO1xyXG5cclxuICAgIHggPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBpZiAoeC5lcSgxKSkgcmV0dXJuIHg7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICBpZiAoeS5lcSgxKSkgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSk7XHJcblxyXG4gICAgLy8geSBleHBvbmVudFxyXG4gICAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgLy8gSWYgeSBpcyBhIHNtYWxsIGludGVnZXIgdXNlIHRoZSAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnIGFsZ29yaXRobS5cclxuICAgIGlmIChlID49IHkuZC5sZW5ndGggLSAxICYmIChrID0geW4gPCAwID8gLXluIDogeW4pIDw9IE1BWF9TQUZFX0lOVEVHRVIpIHtcclxuICAgICAgciA9IGludFBvdyhDdG9yLCB4LCBrLCBwcik7XHJcbiAgICAgIHJldHVybiB5LnMgPCAwID8gbmV3IEN0b3IoMSkuZGl2KHIpIDogZmluYWxpc2UociwgcHIsIHJtKTtcclxuICAgIH1cclxuXHJcbiAgICBzID0geC5zO1xyXG5cclxuICAgIC8vIGlmIHggaXMgbmVnYXRpdmVcclxuICAgIGlmIChzIDwgMCkge1xyXG5cclxuICAgICAgLy8gaWYgeSBpcyBub3QgYW4gaW50ZWdlclxyXG4gICAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJlc3VsdCBpcyBwb3NpdGl2ZSBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB0aGUgbGFzdCBkaWdpdCBvZiBpbnRlZ2VyIHkgaXMgZXZlbi5cclxuICAgICAgaWYgKCh5LmRbZV0gJiAxKSA9PSAwKSBzID0gMTtcclxuXHJcbiAgICAgIC8vIGlmIHguZXEoLTEpXHJcbiAgICAgIGlmICh4LmUgPT0gMCAmJiB4LmRbMF0gPT0gMSAmJiB4LmQubGVuZ3RoID09IDEpIHtcclxuICAgICAgICB4LnMgPSBzO1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXN0aW1hdGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gICAgLy8geF55ID0gMTBeZSwgIHdoZXJlIGUgPSB5ICogbG9nMTAoeClcclxuICAgIC8vIGxvZzEwKHgpID0gbG9nMTAoeF9zaWduaWZpY2FuZCkgKyB4X2V4cG9uZW50XHJcbiAgICAvLyBsb2cxMCh4X3NpZ25pZmljYW5kKSA9IGxuKHhfc2lnbmlmaWNhbmQpIC8gbG4oMTApXHJcbiAgICBrID0gbWF0aHBvdygreCwgeW4pO1xyXG4gICAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaylcclxuICAgICAgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coJzAuJyArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpXHJcbiAgICAgIDogbmV3IEN0b3IoayArICcnKS5lO1xyXG5cclxuICAgIC8vIEV4cG9uZW50IGVzdGltYXRlIG1heSBiZSBpbmNvcnJlY3QgZS5nLiB4OiAwLjk5OTk5OTk5OTk5OTk5OTk5OSwgeTogMi4yOSwgZTogMCwgci5lOiAtMS5cclxuXHJcbiAgICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/XHJcbiAgICBpZiAoZSA+IEN0b3IubWF4RSArIDEgfHwgZSA8IEN0b3IubWluRSAtIDEpIHJldHVybiBuZXcgQ3RvcihlID4gMCA/IHMgLyAwIDogMCk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIEN0b3Iucm91bmRpbmcgPSB4LnMgPSAxO1xyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBleHRyYSBndWFyZCBkaWdpdHMgbmVlZGVkIHRvIGVuc3VyZSBmaXZlIGNvcnJlY3Qgcm91bmRpbmcgZGlnaXRzIGZyb21cclxuICAgIC8vIG5hdHVyYWxMb2dhcml0aG0oeCkuIEV4YW1wbGUgb2YgZmFpbHVyZSB3aXRob3V0IHRoZXNlIGV4dHJhIGRpZ2l0cyAocHJlY2lzaW9uOiAxMCk6XHJcbiAgICAvLyBuZXcgRGVjaW1hbCgyLjMyNDU2KS5wb3coJzIwODc5ODc0MzY1MzQ1NjYuNDY0MTEnKVxyXG4gICAgLy8gc2hvdWxkIGJlIDEuMTYyMzc3ODIzZSs3NjQ5MTQ5MDUxNzM4MTUsIGJ1dCBpcyAxLjE2MjM1NTgyM2UrNzY0OTE0OTA1MTczODE1XHJcbiAgICBrID0gTWF0aC5taW4oMTIsIChlICsgJycpLmxlbmd0aCk7XHJcblxyXG4gICAgLy8gciA9IHheeSA9IGV4cCh5KmxuKHgpKVxyXG4gICAgciA9IG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgcHIgKyBrKSksIHByKTtcclxuXHJcbiAgICAvLyByIG1heSBiZSBJbmZpbml0eSwgZS5nLiAoMC45OTk5OTk5OTk5OTk5OTk5KS5wb3coLTFlKzQwKVxyXG4gICAgaWYgKHIuZCkge1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIHJlcXVpcmVkIHByZWNpc2lvbiBwbHVzIGZpdmUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwIGluY3JlYXNlIHRoZSBwcmVjaXNpb24gYnkgMTAgYW5kIHJlY2FsY3VsYXRlXHJcbiAgICAgIC8vIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgcHIsIHJtKSkge1xyXG4gICAgICAgIGUgPSBwciArIDEwO1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgaW5jcmVhc2VkIHByZWNpc2lvbiBwbHVzIGZpdmUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQgKHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdCBtYXkgYmUgNCBvciA5KS5cclxuICAgICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UocHIgKyAxLCBwciArIDE1KSArIDEgPT0gMWUxNCkge1xyXG4gICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgci5zID0gcztcclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBgc2RgIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50XHJcbiAgICogdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gbm9ybWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoc2QgPT09IHZvaWQgMCkge1xyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBgc2RgXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCwgb3IgdG8gYHByZWNpc2lvbmAgYW5kIGByb3VuZGluZ2AgcmVzcGVjdGl2ZWx5IGlmXHJcbiAgICogb21pdHRlZC5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICd0b1NEKCkgZGlnaXRzIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgKiAndG9TRCgpIGRpZ2l0cyBub3QgYW4gaW50ZWdlcjoge3NkfSdcclxuICAgKiAndG9TRCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICogJ3RvU0QoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9TaWduaWZpY2FudERpZ2l0cyA9IFAudG9TRCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKHNkID09PSB2b2lkIDApIHtcclxuICAgICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBEZWNpbWFsIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxyXG4gICAqIGB0b0V4cFBvc2AsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIGB0b0V4cE5lZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0cnVuY2F0ZWQgdG8gYSB3aG9sZSBudW1iZXIuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKiBVbmxpa2UgYHRvU3RyaW5nYCwgbmVnYXRpdmUgemVybyB3aWxsIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24uXHJcbiAgICpcclxuICAgKi9cclxuICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuXHJcbiAgICByZXR1cm4geC5pc05lZygpID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gIC8vIEFkZCBhbGlhc2VzIHRvIG1hdGNoIEJpZ0RlY2ltYWwgbWV0aG9kIG5hbWVzLlxyXG4gIC8vIFAuYWRkID0gUC5wbHVzO1xyXG4gIFAuc3VidHJhY3QgPSBQLm1pbnVzO1xyXG4gIFAubXVsdGlwbHkgPSBQLnRpbWVzO1xyXG4gIFAuZGl2aWRlID0gUC5kaXY7XHJcbiAgUC5yZW1haW5kZXIgPSBQLm1vZDtcclxuICBQLmNvbXBhcmVUbyA9IFAuY21wO1xyXG4gIFAubmVnYXRlID0gUC5uZWc7XHJcbiAgICovXHJcblxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBEZWNpbWFsLnByb3RvdHlwZSAoUCkgYW5kL29yIERlY2ltYWwgbWV0aG9kcywgYW5kIHRoZWlyIGNhbGxlcnMuXHJcblxyXG5cclxuICAvKlxyXG4gICAqICBkaWdpdHNUb1N0cmluZyAgICAgICAgICAgUC5jdWJlUm9vdCwgUC5sb2dhcml0aG0sIFAuc3F1YXJlUm9vdCwgUC50b0ZyYWN0aW9uLCBQLnRvUG93ZXIsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pdGVUb1N0cmluZywgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAgICogIGNoZWNrSW50MzIgICAgICAgICAgICAgICBQLnRvRGVjaW1hbFBsYWNlcywgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9OZWFyZXN0LFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b1ByZWNpc2lvbiwgUC50b1NpZ25pZmljYW50RGlnaXRzLCB0b1N0cmluZ0JpbmFyeSwgcmFuZG9tXHJcbiAgICogIGNoZWNrUm91bmRpbmdEaWdpdHMgICAgICBQLmxvZ2FyaXRobSwgUC50b1Bvd2VyLCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG1cclxuICAgKiAgY29udmVydEJhc2UgICAgICAgICAgICAgIHRvU3RyaW5nQmluYXJ5LCBwYXJzZU90aGVyXHJcbiAgICogIGNvcyAgICAgICAgICAgICAgICAgICAgICBQLmNvc1xyXG4gICAqICBkaXZpZGUgICAgICAgICAgICAgICAgICAgUC5hdGFuaCwgUC5jdWJlUm9vdCwgUC5kaXZpZGVkQnksIFAuZGl2aWRlZFRvSW50ZWdlckJ5LFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAubW9kdWxvLCBQLnNxdWFyZVJvb3QsIFAudGFuLCBQLnRhbmgsIFAudG9GcmFjdGlvbixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCB0b1N0cmluZ0JpbmFyeSwgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGF5bG9yU2VyaWVzLCBhdGFuMiwgcGFyc2VPdGhlclxyXG4gICAqICBmaW5hbGlzZSAgICAgICAgICAgICAgICAgUC5hYnNvbHV0ZVZhbHVlLCBQLmF0YW4sIFAuYXRhbmgsIFAuY2VpbCwgUC5jb3MsIFAuY29zaCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY3ViZVJvb3QsIFAuZGl2aWRlZFRvSW50ZWdlckJ5LCBQLmZsb29yLCBQLmxvZ2FyaXRobSwgUC5taW51cyxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAubW9kdWxvLCBQLm5lZ2F0ZWQsIFAucGx1cywgUC5yb3VuZCwgUC5zaW4sIFAuc2luaCwgUC5zcXVhcmVSb290LFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50YW4sIFAudGltZXMsIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCBQLnRvUG93ZXIsIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cyxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudHJ1bmNhdGVkLCBkaXZpZGUsIGdldExuMTAsIGdldFBpLCBuYXR1cmFsRXhwb25lbnRpYWwsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjZWlsLCBmbG9vciwgcm91bmQsIHRydW5jXHJcbiAgICogIGZpbml0ZVRvU3RyaW5nICAgICAgICAgICBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b1ByZWNpc2lvbiwgUC50b1N0cmluZywgUC52YWx1ZU9mLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpbmdCaW5hcnlcclxuICAgKiAgZ2V0QmFzZTEwRXhwb25lbnQgICAgICAgIFAubWludXMsIFAucGx1cywgUC50aW1lcywgcGFyc2VPdGhlclxyXG4gICAqICBnZXRMbjEwICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIG5hdHVyYWxMb2dhcml0aG1cclxuICAgKiAgZ2V0UGkgICAgICAgICAgICAgICAgICAgIFAuYWNvcywgUC5hc2luLCBQLmF0YW4sIHRvTGVzc1RoYW5IYWxmUGksIGF0YW4yXHJcbiAgICogIGdldFByZWNpc2lvbiAgICAgICAgICAgICBQLnByZWNpc2lvbiwgUC50b0ZyYWN0aW9uXHJcbiAgICogIGdldFplcm9TdHJpbmcgICAgICAgICAgICBkaWdpdHNUb1N0cmluZywgZmluaXRlVG9TdHJpbmdcclxuICAgKiAgaW50UG93ICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgcGFyc2VPdGhlclxyXG4gICAqICBpc09kZCAgICAgICAgICAgICAgICAgICAgdG9MZXNzVGhhbkhhbGZQaVxyXG4gICAqICBtYXhPck1pbiAgICAgICAgICAgICAgICAgbWF4LCBtaW5cclxuICAgKiAgbmF0dXJhbEV4cG9uZW50aWFsICAgICAgIFAubmF0dXJhbEV4cG9uZW50aWFsLCBQLnRvUG93ZXJcclxuICAgKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgIFAuYWNvc2gsIFAuYXNpbmgsIFAuYXRhbmgsIFAubG9nYXJpdGhtLCBQLm5hdHVyYWxMb2dhcml0aG0sXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbFxyXG4gICAqICBub25GaW5pdGVUb1N0cmluZyAgICAgICAgZmluaXRlVG9TdHJpbmcsIHRvU3RyaW5nQmluYXJ5XHJcbiAgICogIHBhcnNlRGVjaW1hbCAgICAgICAgICAgICBEZWNpbWFsXHJcbiAgICogIHBhcnNlT3RoZXIgICAgICAgICAgICAgICBEZWNpbWFsXHJcbiAgICogIHNpbiAgICAgICAgICAgICAgICAgICAgICBQLnNpblxyXG4gICAqICB0YXlsb3JTZXJpZXMgICAgICAgICAgICAgUC5jb3NoLCBQLnNpbmgsIGNvcywgc2luXHJcbiAgICogIHRvTGVzc1RoYW5IYWxmUGkgICAgICAgICBQLmNvcywgUC5zaW5cclxuICAgKiAgdG9TdHJpbmdCaW5hcnkgICAgICAgICAgIFAudG9CaW5hcnksIFAudG9IZXhhZGVjaW1hbCwgUC50b09jdGFsXHJcbiAgICogIHRydW5jYXRlICAgICAgICAgICAgICAgICBpbnRQb3dcclxuICAgKlxyXG4gICAqICBUaHJvd3M6ICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAucHJlY2lzaW9uLCBQLnRvRnJhY3Rpb24sIGNoZWNrSW50MzIsIGdldExuMTAsIGdldFBpLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbExvZ2FyaXRobSwgY29uZmlnLCBwYXJzZU90aGVyLCByYW5kb20sIERlY2ltYWxcclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGRpZ2l0c1RvU3RyaW5nKGQpIHtcclxuICAgIHZhciBpLCBrLCB3cyxcclxuICAgICAgaW5kZXhPZkxhc3RXb3JkID0gZC5sZW5ndGggLSAxLFxyXG4gICAgICBzdHIgPSAnJyxcclxuICAgICAgdyA9IGRbMF07XHJcblxyXG4gICAgaWYgKGluZGV4T2ZMYXN0V29yZCA+IDApIHtcclxuICAgICAgc3RyICs9IHc7XHJcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBpbmRleE9mTGFzdFdvcmQ7IGkrKykge1xyXG4gICAgICAgIHdzID0gZFtpXSArICcnO1xyXG4gICAgICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICAgICAgc3RyICs9IHdzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3ID0gZFtpXTtcclxuICAgICAgd3MgPSB3ICsgJyc7XHJcbiAgICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcclxuICAgICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgfSBlbHNlIGlmICh3ID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAnMCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zIG9mIGxhc3Qgdy5cclxuICAgIGZvciAoOyB3ICUgMTAgPT09IDA7KSB3IC89IDEwO1xyXG5cclxuICAgIHJldHVybiBzdHIgKyB3O1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrSW50MzIoaSwgbWluLCBtYXgpIHtcclxuICAgIGlmIChpICE9PSB+fmkgfHwgaSA8IG1pbiB8fCBpID4gbWF4KSB7XHJcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgNSByb3VuZGluZyBkaWdpdHMgaWYgYHJlcGVhdGluZ2AgaXMgbnVsbCwgNCBvdGhlcndpc2UuXHJcbiAgICogYHJlcGVhdGluZyA9PSBudWxsYCBpZiBjYWxsZXIgaXMgYGxvZ2Agb3IgYHBvd2AsXHJcbiAgICogYHJlcGVhdGluZyAhPSBudWxsYCBpZiBjYWxsZXIgaXMgYG5hdHVyYWxMb2dhcml0aG1gIG9yIGBuYXR1cmFsRXhwb25lbnRpYWxgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoZCwgaSwgcm0sIHJlcGVhdGluZykge1xyXG4gICAgdmFyIGRpLCBrLCByLCByZDtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgYXJyYXkgZC5cclxuICAgIGZvciAoayA9IGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIC0taTtcclxuXHJcbiAgICAvLyBJcyB0aGUgcm91bmRpbmcgZGlnaXQgaW4gdGhlIGZpcnN0IHdvcmQgb2YgZD9cclxuICAgIGlmICgtLWkgPCAwKSB7XHJcbiAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgIGRpID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcbiAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaSBpcyB0aGUgaW5kZXggKDAgLSA2KSBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAvLyBFLmcuIGlmIHdpdGhpbiB0aGUgd29yZCAzNDg3NTYzIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdCBpcyA1LFxyXG4gICAgLy8gdGhlbiBpID0gNCwgayA9IDEwMDAsIHJkID0gMzQ4NzU2MyAlIDEwMDAgPSA1NjNcclxuICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG4gICAgcmQgPSBkW2RpXSAlIGsgfCAwO1xyXG5cclxuICAgIGlmIChyZXBlYXRpbmcgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoaSA8IDMpIHtcclxuICAgICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMTAwIHwgMDtcclxuICAgICAgICBlbHNlIGlmIChpID09IDEpIHJkID0gcmQgLyAxMCB8IDA7XHJcbiAgICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNTAwMDAgfHwgcmQgPT0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gKHJtIDwgNCAmJiByZCArIDEgPT0gayB8fCBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJlxyXG4gICAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMikgLSAxIHx8XHJcbiAgICAgICAgICAgIChyZCA9PSBrIC8gMiB8fCByZCA9PSAwKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IDA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpIDwgNCkge1xyXG4gICAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxMDAwIHwgMDtcclxuICAgICAgICBlbHNlIGlmIChpID09IDEpIHJkID0gcmQgLyAxMDAgfCAwO1xyXG4gICAgICAgIGVsc2UgaWYgKGkgPT0gMikgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgICByID0gKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkID09IDk5OTkgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgPT0gNDk5OTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gKChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCArIDEgPT0gayB8fFxyXG4gICAgICAgICghcmVwZWF0aW5nICYmIHJtID4gMykgJiYgcmQgKyAxID09IGsgLyAyKSAmJlxyXG4gICAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDMpIC0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbnZlcnQgc3RyaW5nIG9mIGBiYXNlSW5gIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYGJhc2VPdXRgLlxyXG4gIC8vIEVnLiBjb252ZXJ0QmFzZSgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gIC8vIEVnLiBjb252ZXJ0QmFzZSgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gIGZ1bmN0aW9uIGNvbnZlcnRCYXNlKHN0ciwgYmFzZUluLCBiYXNlT3V0KSB7XHJcbiAgICB2YXIgaixcclxuICAgICAgYXJyID0gWzBdLFxyXG4gICAgICBhcnJMLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgc3RyTCA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgZm9yICg7IGkgPCBzdHJMOykge1xyXG4gICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07KSBhcnJbYXJyTF0gKj0gYmFzZUluO1xyXG4gICAgICBhcnJbMF0gKz0gTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PT0gdm9pZCAwKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIGNvcyh4KSA9IDEgLSB4XjIvMiEgKyB4XjQvNCEgLSAuLi5cclxuICAgKiB8eHwgPCBwaS8yXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjb3NpbmUoQ3RvciwgeCkge1xyXG4gICAgdmFyIGssIHksXHJcbiAgICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBjb3MoNHgpID0gOCooY29zXjQoeCkgLSBjb3NeMih4KSkgKyAxXHJcbiAgICAvLyBpLmUuIGNvcyh4KSA9IDgqKGNvc140KHgvNCkgLSBjb3NeMih4LzQpKSArIDFcclxuXHJcbiAgICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICBpZiAobGVuIDwgMzIpIHtcclxuICAgICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgICAgeSA9IE1hdGgucG93KDQsIC1rKS50b1N0cmluZygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgayA9IDE2O1xyXG4gICAgICB5ID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gICAgfVxyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uICs9IGs7XHJcblxyXG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKHkpLCBuZXcgQ3RvcigxKSk7XHJcblxyXG4gICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgIGZvciAodmFyIGkgPSBrOyBpLS07KSB7XHJcbiAgICAgIHZhciBjb3MyeCA9IHgudGltZXMoeCk7XHJcbiAgICAgIHggPSBjb3MyeC50aW1lcyhjb3MyeCkubWludXMoY29zMngpLnRpbWVzKDgpLnBsdXMoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gLT0gaztcclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLlxyXG4gICAqL1xyXG4gIHZhciBkaXZpZGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIEFzc3VtZXMgbm9uLXplcm8geCBhbmQgaywgYW5kIGhlbmNlIG5vbi16ZXJvIHJlc3VsdC5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlcih4LCBrLCBiYXNlKSB7XHJcbiAgICAgIHZhciB0ZW1wLFxyXG4gICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICBpID0geC5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICB0ZW1wID0geFtpXSAqIGsgKyBjYXJyeTtcclxuICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xyXG4gICAgICAgIGNhcnJ5ID0gdGVtcCAvIGJhc2UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FycnkpIHgudW5zaGlmdChjYXJyeSk7XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICB2YXIgaSwgcjtcclxuXHJcbiAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSA9IHIgPSAwOyBpIDwgYUw7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICByID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7KSBhLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBwciwgcm0sIGRwLCBiYXNlKSB7XHJcbiAgICAgIHZhciBjbXAsIGUsIGksIGssIGxvZ0Jhc2UsIG1vcmUsIHByb2QsIHByb2RMLCBxLCBxZCwgcmVtLCByZW1MLCByZW0wLCBzZCwgdCwgeGksIHhMLCB5ZDAsXHJcbiAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgIHNpZ24gPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgIHhkID0geC5kLFxyXG4gICAgICAgIHlkID0geS5kO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEN0b3IoLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhkID8geWQgJiYgeGRbMF0gPT0geWRbMF0gOiAheWQpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgMC5cclxuICAgICAgICAgIHhkICYmIHhkWzBdID09IDAgfHwgIXlkID8gc2lnbiAqIDAgOiBzaWduIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYXNlKSB7XHJcbiAgICAgICAgbG9nQmFzZSA9IDE7XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XHJcbiAgICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeUwgPSB5ZC5sZW5ndGg7XHJcbiAgICAgIHhMID0geGQubGVuZ3RoO1xyXG4gICAgICBxID0gbmV3IEN0b3Ioc2lnbik7XHJcbiAgICAgIHFkID0gcS5kID0gW107XHJcblxyXG4gICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoYW4gZS5cclxuICAgICAgLy8gVGhlIGRpZ2l0IGFycmF5IG9mIGEgRGVjaW1hbCBmcm9tIHRvU3RyaW5nQmluYXJ5IG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyB5ZFtpXSA9PSAoeGRbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICBpZiAoeWRbaV0gPiAoeGRbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgIGlmIChwciA9PSBudWxsKSB7XHJcbiAgICAgICAgc2QgPSBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgfSBlbHNlIGlmIChkcCkge1xyXG4gICAgICAgIHNkID0gcHIgKyAoeC5lIC0geS5lKSArIDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2QgPSBwcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkIDwgMCkge1xyXG4gICAgICAgIHFkLnB1c2goMSk7XHJcbiAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgcHJlY2lzaW9uIGluIG51bWJlciBvZiBiYXNlIDEwIGRpZ2l0cyB0byBiYXNlIDFlNyBkaWdpdHMuXHJcbiAgICAgICAgc2QgPSBzZCAvIGxvZ0Jhc2UgKyAyIHwgMDtcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gZGl2aXNvciA8IDFlN1xyXG4gICAgICAgIGlmICh5TCA9PSAxKSB7XHJcbiAgICAgICAgICBrID0gMDtcclxuICAgICAgICAgIHlkID0geWRbMF07XHJcbiAgICAgICAgICBzZCsrO1xyXG5cclxuICAgICAgICAgIC8vIGsgaXMgdGhlIGNhcnJ5LlxyXG4gICAgICAgICAgZm9yICg7IChpIDwgeEwgfHwgaykgJiYgc2QtLTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHQgPSBrICogYmFzZSArICh4ZFtpXSB8fCAwKTtcclxuICAgICAgICAgICAgcWRbaV0gPSB0IC8geWQgfCAwO1xyXG4gICAgICAgICAgICBrID0gdCAlIHlkIHwgMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBtb3JlID0gayB8fCBpIDwgeEw7XHJcblxyXG4gICAgICAgIC8vIGRpdmlzb3IgPj0gMWU3XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGQgYW5kIHlkIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWQgaXMgPj0gYmFzZS8yXHJcbiAgICAgICAgICBrID0gYmFzZSAvICh5ZFswXSArIDEpIHwgMDtcclxuXHJcbiAgICAgICAgICBpZiAoayA+IDEpIHtcclxuICAgICAgICAgICAgeWQgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICB4ZCA9IG11bHRpcGx5SW50ZWdlcih4ZCwgaywgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWQubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGQuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7KSByZW1bcmVtTCsrXSA9IDA7XHJcblxyXG4gICAgICAgICAgeXogPSB5ZC5zbGljZSgpO1xyXG4gICAgICAgICAgeXoudW5zaGlmdCgwKTtcclxuICAgICAgICAgIHlkMCA9IHlkWzBdO1xyXG5cclxuICAgICAgICAgIGlmICh5ZFsxXSA+PSBiYXNlIC8gMikgKyt5ZDA7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBrID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgay5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBrIHdpbGwgYmUgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBrID0gcmVtMCAvIHlkMCB8IDA7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIDEuIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQgKGspXHJcbiAgICAgICAgICAgICAgLy8gIDIuIGlmIHByb2R1Y3QgPiByZW1haW5kZXI6IHByb2R1Y3QgLT0gZGl2aXNvciwgay0tXHJcbiAgICAgICAgICAgICAgLy8gIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgICAgLy8gIDQuIGlmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyIGF0IDI6XHJcbiAgICAgICAgICAgICAgLy8gICAgNS4gY29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yXHJcbiAgICAgICAgICAgICAgLy8gICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIGsrK1xyXG5cclxuICAgICAgICAgICAgICBpZiAoayA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrID49IGJhc2UpIGsgPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPiByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoY21wID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgay0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHlkLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBrIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5ZCBhbmQgcmVtIGFnYWluIGJlbG93LCBzbyBjaGFuZ2UgY21wIHRvIDFcclxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGl0LiBJZiBrIGlzIDEgdGhlcmUgaXMgYSBuZWVkIHRvIGNvbXBhcmUgeWQgYW5kIHJlbSBhZ2FpbiBiZWxvdy5cclxuICAgICAgICAgICAgICAgIGlmIChrID09IDApIGNtcCA9IGsgPSAxO1xyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHlkLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QudW5zaGlmdCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHByZXZpb3VzIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGsrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9ICAgIC8vIGlmIGNtcCA9PT0gMSwgayB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgaywgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWRbaSsrXSA9IGs7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCAmJiByZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4ZFt4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT09IHZvaWQgMCkgJiYgc2QtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPT0gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgIGlmICghcWRbMF0pIHFkLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGxvZ0Jhc2UgaXMgMSB3aGVuIGRpdmlkZSBpcyBiZWluZyB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uXHJcbiAgICAgIGlmIChsb2dCYXNlID09IDEpIHtcclxuICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgIGluZXhhY3QgPSBtb3JlO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWRbMF0uXHJcbiAgICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKSBpKys7XHJcbiAgICAgICAgcS5lID0gaSArIGUgKiBsb2dCYXNlIC0gMTtcclxuXHJcbiAgICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUm91bmQgYHhgIHRvIGBzZGAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICAgKiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAqL1xyXG4gICBmdW5jdGlvbiBmaW5hbGlzZSh4LCBzZCwgcm0sIGlzVHJ1bmNhdGVkKSB7XHJcbiAgICB2YXIgZGlnaXRzLCBpLCBqLCBrLCByZCwgcm91bmRVcCwgdywgeGQsIHhkaSxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgLy8gRG9uJ3Qgcm91bmQgaWYgc2QgaXMgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgICBvdXQ6IGlmIChzZCAhPSBudWxsKSB7XHJcbiAgICAgIHhkID0geC5kO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOLlxyXG4gICAgICBpZiAoIXhkKSByZXR1cm4geDtcclxuXHJcbiAgICAgIC8vIHJkOiB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAvLyB3OiB0aGUgd29yZCBvZiB4ZCBjb250YWluaW5nIHJkLCBhIGJhc2UgMWU3IG51bWJlci5cclxuICAgICAgLy8geGRpOiB0aGUgaW5kZXggb2YgdyB3aXRoaW4geGQuXHJcbiAgICAgIC8vIGRpZ2l0czogdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgICAgLy8gaTogd2hhdCB3b3VsZCBiZSB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcgaWYgYWxsIHRoZSBudW1iZXJzIHdlcmUgNyBkaWdpdHMgbG9uZyAoaS5lLiBpZlxyXG4gICAgICAvLyB0aGV5IGhhZCBsZWFkaW5nIHplcm9zKVxyXG4gICAgICAvLyBqOiBpZiA+IDAsIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIHcgKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG5cclxuICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheSB4ZC5cclxuICAgICAgZm9yIChkaWdpdHMgPSAxLCBrID0geGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG4gICAgICBpID0gc2QgLSBkaWdpdHM7XHJcblxyXG4gICAgICAvLyBJcyB0aGUgcm91bmRpbmcgZGlnaXQgaW4gdGhlIGZpcnN0IHdvcmQgb2YgeGQ/XHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgIHcgPSB4ZFt4ZGkgPSAwXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIHcuXHJcbiAgICAgICAgcmQgPSB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgIGsgPSB4ZC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHhkaSA+PSBrKSB7XHJcbiAgICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5lZWRlZCBieSBgbmF0dXJhbEV4cG9uZW50aWFsYCwgYG5hdHVyYWxMb2dhcml0aG1gIGFuZCBgc3F1YXJlUm9vdGAuXHJcbiAgICAgICAgICAgIGZvciAoOyBrKysgPD0geGRpOykgeGQucHVzaCgwKTtcclxuICAgICAgICAgICAgdyA9IHJkID0gMDtcclxuICAgICAgICAgICAgZGlnaXRzID0gMTtcclxuICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHcgPSBrID0geGRbeGRpXTtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgICAgICAgIGZvciAoZGlnaXRzID0gMTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gdy5cclxuICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gdywgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgdyBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGRpZ2l0cy5cclxuICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkaWdpdHM7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIHcuXHJcbiAgICAgICAgICByZCA9IGogPCAwID8gMCA6IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8XHJcbiAgICAgICAgeGRbeGRpICsgMV0gIT09IHZvaWQgMCB8fCAoaiA8IDAgPyB3IDogdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSk7XHJcblxyXG4gICAgICAvLyBUaGUgZXhwcmVzc2lvbiBgdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKWAgcmV0dXJucyBhbGwgdGhlIGRpZ2l0cyBvZiB3IHRvIHRoZSByaWdodFxyXG4gICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgKGxlZnQtdG8tcmlnaHQpIGluZGV4IGosIGUuZy4gaWYgdyBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb25cclxuICAgICAgLy8gd2lsbCBnaXZlIDcxNC5cclxuXHJcbiAgICAgIHJvdW5kVXAgPSBybSA8IDRcclxuICAgICAgICA/IChyZCB8fCBpc1RydW5jYXRlZCkgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCBpc1RydW5jYXRlZCB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSA6IDAgOiB4ZFt4ZGkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIGlmIChzZCA8IDEgfHwgIXhkWzBdKSB7XHJcbiAgICAgICAgeGQubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAocm91bmRVcCkge1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICB4ZFswXSA9IG1hdGhwb3coMTAsIChMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0UpO1xyXG4gICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeGRbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgeGQubGVuZ3RoID0geGRpO1xyXG4gICAgICAgIGsgPSAxO1xyXG4gICAgICAgIHhkaS0tO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaSArIDE7XHJcbiAgICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XHJcblxyXG4gICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygdy5cclxuICAgICAgICB4ZFt4ZGldID0gaiA+IDAgPyAodyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopICUgbWF0aHBvdygxMCwgaikgfCAwKSAqIGsgOiAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocm91bmRVcCkge1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuXHJcbiAgICAgICAgICAvLyBJcyB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpbiB0aGUgZmlyc3Qgd29yZCBvZiB4ZD9cclxuICAgICAgICAgIGlmICh4ZGkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGRbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMCkgaSsrO1xyXG4gICAgICAgICAgICBqID0geGRbMF0gKz0gaztcclxuICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCkgaysrO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgIGlmICh4ZFswXSA9PSBCQVNFKSB4ZFswXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGRbeGRpXSArPSBrO1xyXG4gICAgICAgICAgICBpZiAoeGRbeGRpXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgeGRbeGRpLS1dID0gMDtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhkLmxlbmd0aDsgeGRbLS1pXSA9PT0gMDspIHhkLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHRlcm5hbCkge1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICh4LmUgPiBDdG9yLm1heEUpIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICB4LmUgPSBOYU47XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5lID0gMDtcclxuICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgLy8gQ3Rvci51bmRlcmZsb3cgPSB0cnVlO1xyXG4gICAgICB9IC8vIGVsc2UgQ3Rvci51bmRlcmZsb3cgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbm9uRmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICB2YXIgayxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgc3RyID0gZGlnaXRzVG9TdHJpbmcoeC5kKSxcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoaXNFeHApIHtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xyXG4gICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgKyBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcclxuICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBzdHIgKyAoeC5lIDwgMCA/ICdlJyA6ICdlKycpICsgeC5lO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG4gICAgICBzdHIgPSAnMC4nICsgZ2V0WmVyb1N0cmluZygtZSAtIDEpICsgc3RyO1xyXG4gICAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgIH0gZWxzZSBpZiAoZSA+PSBsZW4pIHtcclxuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xyXG4gICAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGUgLSAxKSA+IDApIHN0ciA9IHN0ciArICcuJyArIGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoKGsgPSBlICsgMSkgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBrKSArICcuJyArIHN0ci5zbGljZShrKTtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xyXG4gICAgICAgIGlmIChlICsgMSA9PT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQgZnJvbSB0aGUgYmFzZSAxZTcgZXhwb25lbnQuXHJcbiAgZnVuY3Rpb24gZ2V0QmFzZTEwRXhwb25lbnQoZGlnaXRzLCBlKSB7XHJcbiAgICB2YXIgdyA9IGRpZ2l0c1swXTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheS5cclxuICAgIGZvciAoIGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApIGUrKztcclxuICAgIHJldHVybiBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldExuMTAoQ3Rvciwgc2QsIHByKSB7XHJcbiAgICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgLy8gUmVzZXQgZ2xvYmFsIHN0YXRlIGluIGNhc2UgdGhlIGV4Y2VwdGlvbiBpcyBjYXVnaHQuXHJcbiAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgICAgaWYgKHByKSBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihMTjEwKSwgc2QsIDEsIHRydWUpO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldFBpKEN0b3IsIHNkLCBybSkge1xyXG4gICAgaWYgKHNkID4gUElfUFJFQ0lTSU9OKSB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihQSSksIHNkLCBybSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xyXG4gICAgdmFyIHcgPSBkaWdpdHMubGVuZ3RoIC0gMSxcclxuICAgICAgbGVuID0gdyAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICB3ID0gZGlnaXRzW3ddO1xyXG5cclxuICAgIC8vIElmIG5vbi16ZXJvLi4uXHJcbiAgICBpZiAodykge1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApIGxlbi0tO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkLlxyXG4gICAgICBmb3IgKHcgPSBkaWdpdHNbMF07IHcgPj0gMTA7IHcgLz0gMTApIGxlbisrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsZW47XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0WmVyb1N0cmluZyhrKSB7XHJcbiAgICB2YXIgenMgPSAnJztcclxuICAgIGZvciAoOyBrLS07KSB6cyArPSAnMCc7XHJcbiAgICByZXR1cm4genM7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgRGVjaW1hbCBgeGAgdG8gdGhlIHBvd2VyIGBuYCwgd2hlcmUgYG5gIGlzIGFuXHJcbiAgICogaW50ZWdlciBvZiB0eXBlIG51bWJlci5cclxuICAgKlxyXG4gICAqIEltcGxlbWVudHMgJ2V4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nJy4gQ2FsbGVkIGJ5IGBwb3dgIGFuZCBgcGFyc2VPdGhlcmAuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRQb3coQ3RvciwgeCwgbiwgcHIpIHtcclxuICAgIHZhciBpc1RydW5jYXRlZCxcclxuICAgICAgciA9IG5ldyBDdG9yKDEpLFxyXG5cclxuICAgICAgLy8gTWF4IG4gb2YgOTAwNzE5OTI1NDc0MDk5MSB0YWtlcyA1MyBsb29wIGl0ZXJhdGlvbnMuXHJcbiAgICAgIC8vIE1heGltdW0gZGlnaXRzIGFycmF5IGxlbmd0aDsgbGVhdmVzIFsyOCwgMzRdIGd1YXJkIGRpZ2l0cy5cclxuICAgICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFICsgNCk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIGlmIChuICUgMikge1xyXG4gICAgICAgIHIgPSByLnRpbWVzKHgpO1xyXG4gICAgICAgIGlmICh0cnVuY2F0ZShyLmQsIGspKSBpc1RydW5jYXRlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG4gPSBtYXRoZmxvb3IobiAvIDIpO1xyXG4gICAgICBpZiAobiA9PT0gMCkge1xyXG5cclxuICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCByb3VuZGluZyB3aGVuIHIuZCBpcyB0cnVuY2F0ZWQsIGluY3JlbWVudCB0aGUgbGFzdCB3b3JkIGlmIGl0IGlzIHplcm8uXHJcbiAgICAgICAgbiA9IHIuZC5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChpc1RydW5jYXRlZCAmJiByLmRbbl0gPT09IDApICsrci5kW25dO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ID0geC50aW1lcyh4KTtcclxuICAgICAgdHJ1bmNhdGUoeC5kLCBrKTtcclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogSGFuZGxlIGBtYXhgIGFuZCBgbWluYC4gYGx0Z3RgIGlzICdsdCcgb3IgJ2d0Jy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBsdGd0KSB7XHJcbiAgICB2YXIgeSxcclxuICAgICAgeCA9IG5ldyBDdG9yKGFyZ3NbMF0pLFxyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7KSB7XHJcbiAgICAgIHkgPSBuZXcgQ3RvcihhcmdzW2ldKTtcclxuICAgICAgaWYgKCF5LnMpIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfSBlbHNlIGlmICh4W2x0Z3RdKHkpKSB7XHJcbiAgICAgICAgeCA9IHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMuXHJcbiAgICpcclxuICAgKiBUYXlsb3IvTWFjbGF1cmluIHNlcmllcy5cclxuICAgKlxyXG4gICAqIGV4cCh4KSA9IHheMC8wISArIHheMS8xISArIHheMi8yISArIHheMy8zISArIC4uLlxyXG4gICAqXHJcbiAgICogQXJndW1lbnQgcmVkdWN0aW9uOlxyXG4gICAqICAgUmVwZWF0IHggPSB4IC8gMzIsIGsgKz0gNSwgdW50aWwgfHh8IDwgMC4xXHJcbiAgICogICBleHAoeCkgPSBleHAoeCAvIDJeayleKDJeaylcclxuICAgKlxyXG4gICAqIFByZXZpb3VzbHksIHRoZSBhcmd1bWVudCB3YXMgaW5pdGlhbGx5IHJlZHVjZWQgYnlcclxuICAgKiBleHAoeCkgPSBleHAocikgKiAxMF5rICB3aGVyZSByID0geCAtIGsgKiBsbjEwLCBrID0gZmxvb3IoeCAvIGxuMTApXHJcbiAgICogdG8gZmlyc3QgcHV0IHIgaW4gdGhlIHJhbmdlIFswLCBsbjEwXSwgYmVmb3JlIGRpdmlkaW5nIGJ5IDMyIHVudGlsIHx4fCA8IDAuMSwgYnV0IHRoaXMgd2FzXHJcbiAgICogZm91bmQgdG8gYmUgc2xvd2VyIHRoYW4ganVzdCBkaXZpZGluZyByZXBlYXRlZGx5IGJ5IDMyIGFzIGFib3ZlLlxyXG4gICAqXHJcbiAgICogTWF4IGludGVnZXIgYXJndW1lbnQ6IGV4cCgnMjA3MjMyNjU4MzY5NDY0MTMnKSA9IDYuM2UrOTAwMDAwMDAwMDAwMDAwMFxyXG4gICAqIE1pbiBpbnRlZ2VyIGFyZ3VtZW50OiBleHAoJy0yMDcyMzI2NTgzNjk0NjQxMScpID0gMS4yZS05MDAwMDAwMDAwMDAwMDAwXHJcbiAgICogKE1hdGggb2JqZWN0IGludGVnZXIgbWluL21heDogTWF0aC5leHAoNzA5KSA9IDguMmUrMzA3LCBNYXRoLmV4cCgtNzQ1KSA9IDVlLTMyNClcclxuICAgKlxyXG4gICAqICBleHAoSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogIGV4cCgtSW5maW5pdHkpID0gMFxyXG4gICAqICBleHAoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqICBleHAowrEwKSAgICAgICAgPSAxXHJcbiAgICpcclxuICAgKiAgZXhwKHgpIGlzIG5vbi10ZXJtaW5hdGluZyBmb3IgYW55IGZpbml0ZSwgbm9uLXplcm8geC5cclxuICAgKlxyXG4gICAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XHJcbiAgICB2YXIgZGVub21pbmF0b3IsIGd1YXJkLCBqLCBwb3csIHN1bSwgdCwgd3ByLFxyXG4gICAgICByZXAgPSAwLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgayA9IDAsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcblxyXG4gICAgLy8gMC9OYU4vSW5maW5pdHk/XHJcbiAgICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoeC5kXHJcbiAgICAgICAgPyAheC5kWzBdID8gMSA6IHgucyA8IDAgPyAwIDogMSAvIDBcclxuICAgICAgICA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgICB3cHIgPSBwcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdwciA9IHNkO1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSBuZXcgQ3RvcigwLjAzMTI1KTtcclxuXHJcbiAgICAvLyB3aGlsZSBhYnMoeCkgPj0gMC4xXHJcbiAgICB3aGlsZSAoeC5lID4gLTIpIHtcclxuXHJcbiAgICAgIC8vIHggPSB4IC8gMl41XHJcbiAgICAgIHggPSB4LnRpbWVzKHQpO1xyXG4gICAgICBrICs9IDU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlIDIgKiBsb2cxMCgyXmspICsgNSAoZW1waXJpY2FsbHkgZGVyaXZlZCkgdG8gZXN0aW1hdGUgdGhlIGluY3JlYXNlIGluIHByZWNpc2lvblxyXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgYXJlIGNvcnJlY3QuXHJcbiAgICBndWFyZCA9IE1hdGgubG9nKG1hdGhwb3coMiwgaykpIC8gTWF0aC5MTjEwICogMiArIDUgfCAwO1xyXG4gICAgd3ByICs9IGd1YXJkO1xyXG4gICAgZGVub21pbmF0b3IgPSBwb3cgPSBzdW0gPSBuZXcgQ3RvcigxKTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gd3ByO1xyXG5cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgcG93ID0gZmluYWxpc2UocG93LnRpbWVzKHgpLCB3cHIsIDEpO1xyXG4gICAgICBkZW5vbWluYXRvciA9IGRlbm9taW5hdG9yLnRpbWVzKCsraSk7XHJcbiAgICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUocG93LCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XHJcblxyXG4gICAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCB3cHIpID09PSBkaWdpdHNUb1N0cmluZyhzdW0uZCkuc2xpY2UoMCwgd3ByKSkge1xyXG4gICAgICAgIGogPSBrO1xyXG4gICAgICAgIHdoaWxlIChqLS0pIHN1bSA9IGZpbmFsaXNlKHN1bS50aW1lcyhzdW0pLCB3cHIsIDEpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5LlxyXG4gICAgICAgIC8vIElmIHNvLCByZXBlYXQgdGhlIHN1bW1hdGlvbiB3aXRoIGEgaGlnaGVyIHByZWNpc2lvbiwgb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTgsIHJvdW5kaW5nOiAxXHJcbiAgICAgICAgLy8gZXhwKDE4LjQwNDI3MjQ2MjU5NTAzNDA4MzU2Nzc5MzkxOTg0Mzc2MSkgPSA5ODM3MjU2MC4xMjI5OTk5OTk5IChzaG91bGQgYmUgOTgzNzI1NjAuMTIzKVxyXG4gICAgICAgIC8vIGB3cHIgLSBndWFyZGAgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHJlcCA8IDMgJiYgY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0uZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XHJcbiAgICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IDEwO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdyA9IHQgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIHJlcCsrO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc3VtID0gdDtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzLlxyXG4gICAqXHJcbiAgICogIGxuKC1uKSAgICAgICAgPSBOYU5cclxuICAgKiAgbG4oMCkgICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqICBsbigtMCkgICAgICAgID0gLUluZmluaXR5XHJcbiAgICogIGxuKDEpICAgICAgICAgPSAwXHJcbiAgICogIGxuKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqICBsbigtSW5maW5pdHkpID0gTmFOXHJcbiAgICogIGxuKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqICBsbihuKSAobiAhPSAxKSBpcyBub24tdGVybWluYXRpbmcuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBuYXR1cmFsTG9nYXJpdGhtKHksIHNkKSB7XHJcbiAgICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtLCB0LCB3cHIsIHgxLCB4MixcclxuICAgICAgbiA9IDEsXHJcbiAgICAgIGd1YXJkID0gMTAsXHJcbiAgICAgIHggPSB5LFxyXG4gICAgICB4ZCA9IHguZCxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuXHJcbiAgICAvLyBJcyB4IG5lZ2F0aXZlIG9yIEluZmluaXR5LCBOYU4sIDAgb3IgMT9cclxuICAgIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQ3Rvcih4ZCAmJiAheGRbMF0gPyAtMSAvIDAgOiB4LnMgIT0gMSA/IE5hTiA6IHhkID8gMCA6IHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgIHdwciA9IHByO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3ByID0gc2Q7XHJcbiAgICB9XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgICBjID0gZGlnaXRzVG9TdHJpbmcoeGQpO1xyXG4gICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuXHJcbiAgICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxLjVlMTUpIHtcclxuXHJcbiAgICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgICAgLy8gVGhlIHNlcmllcyBjb252ZXJnZXMgZmFzdGVyIHRoZSBjbG9zZXIgdGhlIGFyZ3VtZW50IGlzIHRvIDEsIHNvIHVzaW5nXHJcbiAgICAgIC8vIGxuKGFeYikgPSBiICogbG4oYSksICAgbG4oYSkgPSBsbihhXmIpIC8gYlxyXG4gICAgICAvLyBtdWx0aXBseSB0aGUgYXJndW1lbnQgYnkgaXRzZWxmIHVudGlsIHRoZSBsZWFkaW5nIGRpZ2l0cyBvZiB0aGUgc2lnbmlmaWNhbmQgYXJlIDcsIDgsIDksXHJcbiAgICAgIC8vIDEwLCAxMSwgMTIgb3IgMTMsIHJlY29yZGluZyB0aGUgbnVtYmVyIG9mIG11bHRpcGxpY2F0aW9ucyBzbyB0aGUgc3VtIG9mIHRoZSBzZXJpZXMgY2FuXHJcbiAgICAgIC8vIGxhdGVyIGJlIGRpdmlkZWQgYnkgdGhpcyBudW1iZXIsIHRoZW4gc2VwYXJhdGUgb3V0IHRoZSBwb3dlciBvZiAxMCB1c2luZ1xyXG4gICAgICAvLyBsbihhKjEwXmIpID0gbG4oYSkgKyBiKmxuKDEwKS5cclxuXHJcbiAgICAgIC8vIG1heCBuIGlzIDIxIChnaXZlcyAwLjksIDEuMCBvciAxLjEpICg5ZTE1IC8gMjEgPSA0LjJlMTQpLlxyXG4gICAgICAvL3doaWxlIChjMCA8IDkgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMSkge1xyXG4gICAgICAvLyBtYXggbiBpcyA2IChnaXZlcyAwLjcgLSAxLjMpXHJcbiAgICAgIHdoaWxlIChjMCA8IDcgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMykge1xyXG4gICAgICAgIHggPSB4LnRpbWVzKHkpO1xyXG4gICAgICAgIGMgPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xyXG4gICAgICAgIGMwID0gYy5jaGFyQXQoMCk7XHJcbiAgICAgICAgbisrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0geC5lO1xyXG5cclxuICAgICAgaWYgKGMwID4gMSkge1xyXG4gICAgICAgIHggPSBuZXcgQ3RvcignMC4nICsgYyk7XHJcbiAgICAgICAgZSsrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHggPSBuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gVGhlIGFyZ3VtZW50IHJlZHVjdGlvbiBtZXRob2QgYWJvdmUgbWF5IHJlc3VsdCBpbiBvdmVyZmxvdyBpZiB0aGUgYXJndW1lbnQgeSBpcyBhIG1hc3NpdmVcclxuICAgICAgLy8gbnVtYmVyIHdpdGggZXhwb25lbnQgPj0gMTUwMDAwMDAwMDAwMDAwMCAoOWUxNSAvIDYgPSAxLjVlMTUpLCBzbyBpbnN0ZWFkIHJlY2FsbCB0aGlzXHJcbiAgICAgIC8vIGZ1bmN0aW9uIHVzaW5nIGxuKHgqMTBeZSkgPSBsbih4KSArIGUqbG4oMTApLlxyXG4gICAgICB0ID0gZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArICcnKTtcclxuICAgICAgeCA9IG5hdHVyYWxMb2dhcml0aG0obmV3IEN0b3IoYzAgKyAnLicgKyBjLnNsaWNlKDEpKSwgd3ByIC0gZ3VhcmQpLnBsdXModCk7XHJcbiAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcblxyXG4gICAgICByZXR1cm4gc2QgPT0gbnVsbCA/IGZpbmFsaXNlKHgsIHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKSA6IHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8geDEgaXMgeCByZWR1Y2VkIHRvIGEgdmFsdWUgbmVhciAxLlxyXG4gICAgeDEgPSB4O1xyXG5cclxuICAgIC8vIFRheWxvciBzZXJpZXMuXHJcbiAgICAvLyBsbih5KSA9IGxuKCgxICsgeCkvKDEgLSB4KSkgPSAyKHggKyB4XjMvMyArIHheNS81ICsgeF43LzcgKyAuLi4pXHJcbiAgICAvLyB3aGVyZSB4ID0gKHkgLSAxKS8oeSArIDEpICAgICh8eHwgPCAxKVxyXG4gICAgc3VtID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4Lm1pbnVzKDEpLCB4LnBsdXMoMSksIHdwciwgMSk7XHJcbiAgICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XHJcbiAgICBkZW5vbWluYXRvciA9IDM7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xyXG4gICAgICB0ID0gc3VtLnBsdXMoZGl2aWRlKG51bWVyYXRvciwgbmV3IEN0b3IoZGVub21pbmF0b3IpLCB3cHIsIDEpKTtcclxuXHJcbiAgICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XHJcbiAgICAgICAgc3VtID0gc3VtLnRpbWVzKDIpO1xyXG5cclxuICAgICAgICAvLyBSZXZlcnNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uIENoZWNrIHRoYXQgZSBpcyBub3QgMCBiZWNhdXNlLCBiZXNpZGVzIHByZXZlbnRpbmcgYW5cclxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbiwgLTAgKyAwID0gKzAgYW5kIHRvIGVuc3VyZSBjb3JyZWN0IHJvdW5kaW5nIC0wIG5lZWRzIHRvIHN0YXkgLTAuXHJcbiAgICAgICAgaWYgKGUgIT09IDApIHN1bSA9IHN1bS5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJykpO1xyXG4gICAgICAgIHN1bSA9IGRpdmlkZShzdW0sIG5ldyBDdG9yKG4pLCB3cHIsIDEpO1xyXG5cclxuICAgICAgICAvLyBJcyBybSA+IDMgYW5kIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyA0OTk5LCBvciBybSA8IDQgKG9yIHRoZSBzdW1tYXRpb24gaGFzXHJcbiAgICAgICAgLy8gYmVlbiByZXBlYXRlZCBwcmV2aW91c2x5KSBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDk5OTk/XHJcbiAgICAgICAgLy8gSWYgc28sIHJlc3RhcnQgdGhlIHN1bW1hdGlvbiB3aXRoIGEgaGlnaGVyIHByZWNpc2lvbiwgb3RoZXJ3aXNlXHJcbiAgICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTIsIHJvdW5kaW5nOiAxXHJcbiAgICAgICAgLy8gbG4oMTM1NTIwMDI4LjYxMjYwOTE3MTQyNjUzODE1MzMpID0gMTguNzI0NjI5OTk5OSB3aGVuIGl0IHNob3VsZCBiZSAxOC43MjQ2My5cclxuICAgICAgICAvLyBgd3ByIC0gZ3VhcmRgIGlzIHRoZSBpbmRleCBvZiBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcclxuICAgICAgICAgICAgdCA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeDEubWludXMoMSksIHgxLnBsdXMoMSksIHdwciwgMSk7XHJcbiAgICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgICAgICAgICAgZGVub21pbmF0b3IgPSByZXAgPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc3VtID0gdDtcclxuICAgICAgZGVub21pbmF0b3IgKz0gMjtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyDCsUluZmluaXR5LCBOYU4uXHJcbiAgZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xyXG4gICAgLy8gVW5zaWduZWQuXHJcbiAgICByZXR1cm4gU3RyaW5nKHgucyAqIHgucyAvIDApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUGFyc2UgdGhlIHZhbHVlIG9mIGEgbmV3IERlY2ltYWwgYHhgIGZyb20gc3RyaW5nIGBzdHJgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBhcnNlRGVjaW1hbCh4LCBzdHIpIHtcclxuICAgIHZhciBlLCBpLCBsZW47XHJcblxyXG4gICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbik7XHJcbiAgICBzdHIgPSBzdHIuc2xpY2UoaSwgbGVuKTtcclxuXHJcbiAgICBpZiAoc3RyKSB7XHJcbiAgICAgIGxlbiAtPSBpO1xyXG4gICAgICB4LmUgPSBlID0gZSAtIGkgLSAxO1xyXG4gICAgICB4LmQgPSBbXTtcclxuXHJcbiAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheS5cclxuICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAoaSkgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcbiAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB4LmQucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XHJcbiAgICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpIC09IGxlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICg7IGktLTspIHN0ciArPSAnMCc7XHJcbiAgICAgIHguZC5wdXNoKCtzdHIpO1xyXG5cclxuICAgICAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICh4LmUgPiB4LmNvbnN0cnVjdG9yLm1heEUpIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICB4LmUgPSBOYU47XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IHguY29uc3RydWN0b3IubWluRSkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgICAgLy8geC5jb25zdHJ1Y3Rvci51bmRlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgIH0gLy8gZWxzZSB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gWmVyby5cclxuICAgICAgeC5lID0gMDtcclxuICAgICAgeC5kID0gWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUGFyc2UgdGhlIHZhbHVlIG9mIGEgbmV3IERlY2ltYWwgYHhgIGZyb20gYSBzdHJpbmcgYHN0cmAsIHdoaWNoIGlzIG5vdCBhIGRlY2ltYWwgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcclxuICAgIHZhciBiYXNlLCBDdG9yLCBkaXZpc29yLCBpLCBpc0Zsb2F0LCBsZW4sIHAsIHhkLCB4ZTtcclxuXHJcbiAgICBpZiAoc3RyID09PSAnSW5maW5pdHknIHx8IHN0ciA9PT0gJ05hTicpIHtcclxuICAgICAgaWYgKCErc3RyKSB4LnMgPSBOYU47XHJcbiAgICAgIHguZSA9IE5hTjtcclxuICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSGV4LnRlc3Qoc3RyKSkgIHtcclxuICAgICAgYmFzZSA9IDE2O1xyXG4gICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICAgIH0gZWxzZSBpZiAoaXNCaW5hcnkudGVzdChzdHIpKSAge1xyXG4gICAgICBiYXNlID0gMjtcclxuICAgIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpICB7XHJcbiAgICAgIGJhc2UgPSA4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJcyB0aGVyZSBhIGJpbmFyeSBleHBvbmVudCBwYXJ0P1xyXG4gICAgaSA9IHN0ci5zZWFyY2goL3AvaSk7XHJcblxyXG4gICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgIHAgPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IGBzdHJgIGFzIGFuIGludGVnZXIgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBgYmFzZWAgcmFpc2VkIHRvIGEgcG93ZXIgc3VjaCB0aGF0IHRoZVxyXG4gICAgLy8gZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG4gICAgaSA9IHN0ci5pbmRleE9mKCcuJyk7XHJcbiAgICBpc0Zsb2F0ID0gaSA+PSAwO1xyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKGlzRmxvYXQpIHtcclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIGkgPSBsZW4gLSBpO1xyXG5cclxuICAgICAgLy8gbG9nWzEwXSgxNikgPSAxLjIwNDEuLi4gLCBsb2dbMTBdKDg4KSA9IDEuOTQ0NC4uLi5cclxuICAgICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBCQVNFKTtcclxuICAgIHhlID0geGQubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4ZTsgeGRbaV0gPT09IDA7IC0taSkgeGQucG9wKCk7XHJcbiAgICBpZiAoaSA8IDApIHJldHVybiBuZXcgQ3Rvcih4LnMgKiAwKTtcclxuICAgIHguZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCB4ZSk7XHJcbiAgICB4LmQgPSB4ZDtcclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQXQgd2hhdCBwcmVjaXNpb24gdG8gcGVyZm9ybSB0aGUgZGl2aXNpb24gdG8gZW5zdXJlIGV4YWN0IGNvbnZlcnNpb24/XHJcbiAgICAvLyBtYXhEZWNpbWFsSW50ZWdlclBhcnREaWdpdENvdW50ID0gY2VpbChsb2dbMTBdKGIpICogb3RoZXJCYXNlSW50ZWdlclBhcnREaWdpdENvdW50KVxyXG4gICAgLy8gbG9nWzEwXSgyKSA9IDAuMzAxMDMsIGxvZ1sxMF0oOCkgPSAwLjkwMzA5LCBsb2dbMTBdKDE2KSA9IDEuMjA0MTJcclxuICAgIC8vIEUuZy4gY2VpbCgxLjIgKiAzKSA9IDQsIHNvIHVwIHRvIDQgZGVjaW1hbCBkaWdpdHMgYXJlIG5lZWRlZCB0byByZXByZXNlbnQgMyBoZXggaW50IGRpZ2l0cy5cclxuICAgIC8vIG1heERlY2ltYWxGcmFjdGlvblBhcnREaWdpdENvdW50ID0ge0hleDo0fE9jdDozfEJpbjoxfSAqIG90aGVyQmFzZUZyYWN0aW9uUGFydERpZ2l0Q291bnRcclxuICAgIC8vIFRoZXJlZm9yZSB1c2luZyA0ICogdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygc3RyIHdpbGwgYWx3YXlzIGJlIGVub3VnaC5cclxuICAgIGlmIChpc0Zsb2F0KSB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xyXG5cclxuICAgIC8vIE11bHRpcGx5IGJ5IHRoZSBiaW5hcnkgZXhwb25lbnQgcGFydCBpZiBwcmVzZW50LlxyXG4gICAgaWYgKHApIHggPSB4LnRpbWVzKE1hdGguYWJzKHApIDwgNTQgPyBNYXRoLnBvdygyLCBwKSA6IERlY2ltYWwucG93KDIsIHApKTtcclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICAgKiB8eHwgPCBwaS8yXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaW5lKEN0b3IsIHgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICAgIGlmIChsZW4gPCAzKSByZXR1cm4gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogc2luKDV4KSA9IDE2KnNpbl41KHgpIC0gMjAqc2luXjMoeCkgKyA1KnNpbih4KVxyXG4gICAgLy8gaS5lLiBzaW4oeCkgPSAxNipzaW5eNSh4LzUpIC0gMjAqc2luXjMoeC81KSArIDUqc2luKHgvNSlcclxuICAgIC8vIGFuZCAgc2luKHgpID0gc2luKHgvNSkoNSArIHNpbl4yKHgvNSkoMTZzaW5eMih4LzUpIC0gMjApKVxyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xyXG5cclxuICAgIC8vIE1heCBrIGJlZm9yZSBNYXRoLnBvdyBwcmVjaXNpb24gbG9zcyBpcyAyMlxyXG4gICAgeCA9IHgudGltZXMoTWF0aC5wb3coNSwgLWspKTtcclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XHJcblxyXG4gICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgIHZhciBzaW4yX3gsXHJcbiAgICAgIGQ1ID0gbmV3IEN0b3IoNSksXHJcbiAgICAgIGQxNiA9IG5ldyBDdG9yKDE2KSxcclxuICAgICAgZDIwID0gbmV3IEN0b3IoMjApO1xyXG4gICAgZm9yICg7IGstLTspIHtcclxuICAgICAgc2luMl94ID0geC50aW1lcyh4KTtcclxuICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW4yX3gudGltZXMoZDE2LnRpbWVzKHNpbjJfeCkubWludXMoZDIwKSkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvLyBDYWxjdWxhdGUgVGF5bG9yIHNlcmllcyBmb3IgYGNvc2AsIGBjb3NoYCwgYHNpbmAgYW5kIGBzaW5oYC5cclxuICBmdW5jdGlvbiB0YXlsb3JTZXJpZXMoQ3RvciwgbiwgeCwgeSwgaXNIeXBlcmJvbGljKSB7XHJcbiAgICB2YXIgaiwgdCwgdSwgeDIsXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICB4MiA9IHgudGltZXMoeCk7XHJcbiAgICB1ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICB0ID0gZGl2aWRlKHUudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XHJcbiAgICAgIHUgPSBpc0h5cGVyYm9saWMgPyB5LnBsdXModCkgOiB5Lm1pbnVzKHQpO1xyXG4gICAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XHJcbiAgICAgIHQgPSB1LnBsdXMoeSk7XHJcblxyXG4gICAgICBpZiAodC5kW2tdICE9PSB2b2lkIDApIHtcclxuICAgICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07KTtcclxuICAgICAgICBpZiAoaiA9PSAtMSkgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGogPSB1O1xyXG4gICAgICB1ID0geTtcclxuICAgICAgeSA9IHQ7XHJcbiAgICAgIHQgPSBqO1xyXG4gICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgdC5kLmxlbmd0aCA9IGsgKyAxO1xyXG5cclxuICAgIHJldHVybiB0O1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgIHJlZHVjZWQgdG8gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhhbGYgcGkuXHJcbiAgZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XHJcbiAgICB2YXIgdCxcclxuICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICBwaSA9IGdldFBpKEN0b3IsIEN0b3IucHJlY2lzaW9uLCAxKSxcclxuICAgICAgaGFsZlBpID0gcGkudGltZXMoMC41KTtcclxuXHJcbiAgICB4ID0geC5hYnMoKTtcclxuXHJcbiAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xyXG4gICAgICBxdWFkcmFudCA9IGlzTmVnID8gNCA6IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSB4LmRpdlRvSW50KHBpKTtcclxuXHJcbiAgICBpZiAodC5pc1plcm8oKSkge1xyXG4gICAgICBxdWFkcmFudCA9IGlzTmVnID8gMyA6IDI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0geC5taW51cyh0LnRpbWVzKHBpKSk7XHJcblxyXG4gICAgICAvLyAwIDw9IHggPCBwaVxyXG4gICAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xyXG4gICAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyAoaXNOZWcgPyAyIDogMykgOiAoaXNOZWcgPyA0IDogMSk7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyAoaXNOZWcgPyAxIDogNCkgOiAoaXNOZWcgPyAzIDogMik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHgubWludXMocGkpLmFicygpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBEZWNpbWFsIGB4YCBhcyBhIHN0cmluZyBpbiBiYXNlIGBiYXNlT3V0YC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgaW5jbHVkZSBhIGJpbmFyeSBleHBvbmVudCBzdWZmaXguXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdG9TdHJpbmdCaW5hcnkoeCwgYmFzZU91dCwgc2QsIHJtKSB7XHJcbiAgICB2YXIgYmFzZSwgZSwgaSwgaywgbGVuLCByb3VuZFVwLCBzdHIsIHhkLCB5LFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgaXNFeHAgPSBzZCAhPT0gdm9pZCAwO1xyXG5cclxuICAgIGlmIChpc0V4cCkge1xyXG4gICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuICAgICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkge1xyXG4gICAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgICBpID0gc3RyLmluZGV4T2YoJy4nKTtcclxuXHJcbiAgICAgIC8vIFVzZSBleHBvbmVudGlhbCBub3RhdGlvbiBhY2NvcmRpbmcgdG8gYHRvRXhwUG9zYCBhbmQgYHRvRXhwTmVnYD8gTm8sIGJ1dCBpZiByZXF1aXJlZDpcclxuICAgICAgLy8gbWF4QmluYXJ5RXhwb25lbnQgPSBmbG9vcigoZGVjaW1hbEV4cG9uZW50ICsgMSkgKiBsb2dbMl0oMTApKVxyXG4gICAgICAvLyBtaW5CaW5hcnlFeHBvbmVudCA9IGZsb29yKGRlY2ltYWxFeHBvbmVudCAqIGxvZ1syXSgxMCkpXHJcbiAgICAgIC8vIGxvZ1syXSgxMCkgPSAzLjMyMTkyODA5NDg4NzM2MjM0Nzg3MDMxOTQyOTQ4OTM5MDE3NTg2NFxyXG5cclxuICAgICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgICAgYmFzZSA9IDI7XHJcbiAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYpIHtcclxuICAgICAgICAgIHNkID0gc2QgKiA0IC0gMztcclxuICAgICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xyXG4gICAgICAgICAgc2QgPSBzZCAqIDMgLSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiYXNlID0gYmFzZU91dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGFuIGludGVnZXIgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlciBzdWNoXHJcbiAgICAgIC8vIHRoYXQgdGhlIGZyYWN0aW9uIHBhcnQgd2lsbCBiZSByZXN0b3JlZC5cclxuXHJcbiAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgeSA9IG5ldyBDdG9yKDEpO1xyXG4gICAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xyXG4gICAgICAgIHkuZCA9IGNvbnZlcnRCYXNlKGZpbml0ZVRvU3RyaW5nKHkpLCAxMCwgYmFzZSk7XHJcbiAgICAgICAgeS5lID0geS5kLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIDEwLCBiYXNlKTtcclxuICAgICAgZSA9IGxlbiA9IHhkLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7IHhkWy0tbGVuXSA9PSAwOykgeGQucG9wKCk7XHJcblxyXG4gICAgICBpZiAoIXhkWzBdKSB7XHJcbiAgICAgICAgc3RyID0gaXNFeHAgPyAnMHArMCcgOiAnMCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBlLS07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHggPSBuZXcgQ3Rvcih4KTtcclxuICAgICAgICAgIHguZCA9IHhkO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHggPSBkaXZpZGUoeCwgeSwgc2QsIHJtLCAwLCBiYXNlKTtcclxuICAgICAgICAgIHhkID0geC5kO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICAgIHJvdW5kVXAgPSBpbmV4YWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGRbc2RdO1xyXG4gICAgICAgIGsgPSBiYXNlIC8gMjtcclxuICAgICAgICByb3VuZFVwID0gcm91bmRVcCB8fCB4ZFtzZCArIDFdICE9PSB2b2lkIDA7XHJcblxyXG4gICAgICAgIHJvdW5kVXAgPSBybSA8IDRcclxuICAgICAgICAgID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgOiBpID4gayB8fCBpID09PSBrICYmIChybSA9PT0gNCB8fCByb3VuZFVwIHx8IHJtID09PSA2ICYmIHhkW3NkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgIHJtID09PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIHhkLmxlbmd0aCA9IHNkO1xyXG5cclxuICAgICAgICBpZiAocm91bmRVcCkge1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICBmb3IgKDsgKyt4ZFstLXNkXSA+IGJhc2UgLSAxOykge1xyXG4gICAgICAgICAgICB4ZFtzZF0gPSAwO1xyXG4gICAgICAgICAgICBpZiAoIXNkKSB7XHJcbiAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgIHhkLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPCBsZW47IGkrKykgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBiaW5hcnkgZXhwb25lbnQgc3VmZml4P1xyXG4gICAgICAgIGlmIChpc0V4cCkge1xyXG4gICAgICAgICAgaWYgKGxlbiA+IDEpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICAgICAgaSA9IGJhc2VPdXQgPT0gMTYgPyA0IDogMztcclxuICAgICAgICAgICAgICBmb3IgKC0tbGVuOyBsZW4gJSBpOyBsZW4rKykgc3RyICs9ICcwJztcclxuICAgICAgICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgYmFzZU91dCk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pO1xyXG5cclxuICAgICAgICAgICAgICAvLyB4ZFswXSB3aWxsIGFsd2F5cyBiZSBiZSAxXHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMSwgc3RyID0gJzEuJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gIHN0ciArIChlIDwgMCA/ICdwJyA6ICdwKycpICsgZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgICBmb3IgKDsgKytlOykgc3RyID0gJzAnICsgc3RyO1xyXG4gICAgICAgICAgc3RyID0gJzAuJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCsrZSA+IGxlbikgZm9yIChlIC09IGxlbjsgZS0tIDspIHN0ciArPSAnMCc7XHJcbiAgICAgICAgICBlbHNlIGlmIChlIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSAoYmFzZU91dCA9PSAxNiA/ICcweCcgOiBiYXNlT3V0ID09IDIgPyAnMGInIDogYmFzZU91dCA9PSA4ID8gJzBvJyA6ICcnKSArIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geC5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBEb2VzIG5vdCBzdHJpcCB0cmFpbGluZyB6ZXJvcy5cclxuICBmdW5jdGlvbiB0cnVuY2F0ZShhcnIsIGxlbikge1xyXG4gICAgaWYgKGFyci5sZW5ndGggPiBsZW4pIHtcclxuICAgICAgYXJyLmxlbmd0aCA9IGxlbjtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRGVjaW1hbCBtZXRob2RzXHJcblxyXG5cclxuICAvKlxyXG4gICAqICBhYnNcclxuICAgKiAgYWNvc1xyXG4gICAqICBhY29zaFxyXG4gICAqICBhZGRcclxuICAgKiAgYXNpblxyXG4gICAqICBhc2luaFxyXG4gICAqICBhdGFuXHJcbiAgICogIGF0YW5oXHJcbiAgICogIGF0YW4yXHJcbiAgICogIGNicnRcclxuICAgKiAgY2VpbFxyXG4gICAqICBjbG9uZVxyXG4gICAqICBjb25maWdcclxuICAgKiAgY29zXHJcbiAgICogIGNvc2hcclxuICAgKiAgZGl2XHJcbiAgICogIGV4cFxyXG4gICAqICBmbG9vclxyXG4gICAqICBoeXBvdFxyXG4gICAqICBsblxyXG4gICAqICBsb2dcclxuICAgKiAgbG9nMlxyXG4gICAqICBsb2cxMFxyXG4gICAqICBtYXhcclxuICAgKiAgbWluXHJcbiAgICogIG1vZFxyXG4gICAqICBtdWxcclxuICAgKiAgcG93XHJcbiAgICogIHJhbmRvbVxyXG4gICAqICByb3VuZFxyXG4gICAqICBzZXRcclxuICAgKiAgc2lnblxyXG4gICAqICBzaW5cclxuICAgKiAgc2luaFxyXG4gICAqICBzcXJ0XHJcbiAgICogIHN1YlxyXG4gICAqICB0YW5cclxuICAgKiAgdGFuaFxyXG4gICAqICB0cnVuY1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWJzKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hYnMoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgaW4gcmFkaWFucyBvZiBgeGAuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhY29zKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hY29zKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYHhgLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWNvc2goeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIGB4YCBhbmQgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhZGQoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnBsdXMoeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSBpbiByYWRpYW5zIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhc2luKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFzaW5oKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hc2luaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3RhbmdlbnQgaW4gcmFkaWFucyBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXRhbih4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICAgKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdGFuaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHkveGAgaW4gdGhlIHJhbmdlIC1waSB0byBwaVxyXG4gICAqIChpbmNsdXNpdmUpLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLXBpLCBwaV1cclxuICAgKlxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHktY29vcmRpbmF0ZS5cclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSB4LWNvb3JkaW5hdGUuXHJcbiAgICpcclxuICAgKiBhdGFuMijCsTAsIC0wKSAgICAgICAgICAgICAgID0gwrFwaVxyXG4gICAqIGF0YW4yKMKxMCwgKzApICAgICAgICAgICAgICAgPSDCsTBcclxuICAgKiBhdGFuMijCsTAsIC14KSAgICAgICAgICAgICAgID0gwrFwaSBmb3IgeCA+IDBcclxuICAgKiBhdGFuMijCsTAsIHgpICAgICAgICAgICAgICAgID0gwrEwIGZvciB4ID4gMFxyXG4gICAqIGF0YW4yKC15LCDCsTApICAgICAgICAgICAgICAgPSAtcGkvMiBmb3IgeSA+IDBcclxuICAgKiBhdGFuMih5LCDCsTApICAgICAgICAgICAgICAgID0gcGkvMiBmb3IgeSA+IDBcclxuICAgKiBhdGFuMijCsXksIC1JbmZpbml0eSkgICAgICAgID0gwrFwaSBmb3IgZmluaXRlIHkgPiAwXHJcbiAgICogYXRhbjIowrF5LCArSW5maW5pdHkpICAgICAgICA9IMKxMCBmb3IgZmluaXRlIHkgPiAwXHJcbiAgICogYXRhbjIowrFJbmZpbml0eSwgeCkgICAgICAgICA9IMKxcGkvMiBmb3IgZmluaXRlIHhcclxuICAgKiBhdGFuMijCsUluZmluaXR5LCAtSW5maW5pdHkpID0gwrEzKnBpLzRcclxuICAgKiBhdGFuMijCsUluZmluaXR5LCArSW5maW5pdHkpID0gwrFwaS80XHJcbiAgICogYXRhbjIoTmFOLCB4KSA9IE5hTlxyXG4gICAqIGF0YW4yKHksIE5hTikgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcclxuICAgIHkgPSBuZXcgdGhpcyh5KTtcclxuICAgIHggPSBuZXcgdGhpcyh4KTtcclxuICAgIHZhciByLFxyXG4gICAgICBwciA9IHRoaXMucHJlY2lzaW9uLFxyXG4gICAgICBybSA9IHRoaXMucm91bmRpbmcsXHJcbiAgICAgIHdwciA9IHByICsgNDtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOXHJcbiAgICBpZiAoIXkucyB8fCAheC5zKSB7XHJcbiAgICAgIHIgPSBuZXcgdGhpcyhOYU4pO1xyXG5cclxuICAgIC8vIEJvdGggwrFJbmZpbml0eVxyXG4gICAgfSBlbHNlIGlmICgheS5kICYmICF4LmQpIHtcclxuICAgICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoeC5zID4gMCA/IDAuMjUgOiAwLjc1KTtcclxuICAgICAgci5zID0geS5zO1xyXG5cclxuICAgIC8vIHggaXMgwrFJbmZpbml0eSBvciB5IGlzIMKxMFxyXG4gICAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcclxuICAgICAgciA9IHgucyA8IDAgPyBnZXRQaSh0aGlzLCBwciwgcm0pIDogbmV3IHRoaXMoMCk7XHJcbiAgICAgIHIucyA9IHkucztcclxuXHJcbiAgICAvLyB5IGlzIMKxSW5maW5pdHkgb3IgeCBpcyDCsTBcclxuICAgIH0gZWxzZSBpZiAoIXkuZCB8fCB4LmlzWmVybygpKSB7XHJcbiAgICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKDAuNSk7XHJcbiAgICAgIHIucyA9IHkucztcclxuXHJcbiAgICAvLyBCb3RoIG5vbi16ZXJvIGFuZCBmaW5pdGVcclxuICAgIH0gZWxzZSBpZiAoeC5zIDwgMCkge1xyXG4gICAgICB0aGlzLnByZWNpc2lvbiA9IHdwcjtcclxuICAgICAgdGhpcy5yb3VuZGluZyA9IDE7XHJcbiAgICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xyXG4gICAgICB4ID0gZ2V0UGkodGhpcywgd3ByLCAxKTtcclxuICAgICAgdGhpcy5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgdGhpcy5yb3VuZGluZyA9IHJtO1xyXG4gICAgICByID0geS5zIDwgMCA/IHIubWludXMoeCkgOiByLnBsdXMoeCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBjdWJlIHJvb3Qgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNicnQoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZGVkIHRvIGFuIGludGVnZXIgdXNpbmcgYFJPVU5EX0NFSUxgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2VpbCh4KSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENvbmZpZ3VyZSBnbG9iYWwgc2V0dGluZ3MgZm9yIGEgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIGBvYmpgIGlzIGFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyxcclxuICAgKlxyXG4gICAqICAgcHJlY2lzaW9uICB7bnVtYmVyfVxyXG4gICAqICAgcm91bmRpbmcgICB7bnVtYmVyfVxyXG4gICAqICAgdG9FeHBOZWcgICB7bnVtYmVyfVxyXG4gICAqICAgdG9FeHBQb3MgICB7bnVtYmVyfVxyXG4gICAqICAgbWF4RSAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgbWluRSAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgbW9kdWxvICAgICB7bnVtYmVyfVxyXG4gICAqICAgY3J5cHRvICAgICB7Ym9vbGVhbnxudW1iZXJ9XHJcbiAgICogICBkZWZhdWx0cyAgIHt0cnVlfVxyXG4gICAqXHJcbiAgICogRS5nLiBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAsIHJvdW5kaW5nOiA0IH0pXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjb25maWcob2JqKSB7XHJcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgJ09iamVjdCBleHBlY3RlZCcpO1xyXG4gICAgdmFyIGksIHAsIHYsXHJcbiAgICAgIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLFxyXG4gICAgICBwcyA9IFtcclxuICAgICAgICAncHJlY2lzaW9uJywgMSwgTUFYX0RJR0lUUyxcclxuICAgICAgICAncm91bmRpbmcnLCAwLCA4LFxyXG4gICAgICAgICd0b0V4cE5lZycsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICAgJ3RvRXhwUG9zJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtYXhFJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtaW5FJywgLUVYUF9MSU1JVCwgMCxcclxuICAgICAgICAnbW9kdWxvJywgMCwgOVxyXG4gICAgICBdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBpZiAocCA9IHBzW2ldLCB1c2VEZWZhdWx0cykgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xyXG4gICAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKSB0aGlzW3BdID0gdjtcclxuICAgICAgICBlbHNlIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyAnOiAnICsgdik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocCA9ICdjcnlwdG8nLCB1c2VEZWZhdWx0cykgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xyXG4gICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xyXG4gICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzW3BdID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvcyh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYHhgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvc2goeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgRGVjaW1hbCBjb25zdHJ1Y3RvciB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBhcyB0aGlzIERlY2ltYWxcclxuICAgKiBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gICAgdmFyIGksIHAsIHBzO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERlY2ltYWwodikge1xyXG4gICAgICB2YXIgZSwgaSwgdCxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgRGVjaW1hbCkpIHJldHVybiBuZXcgRGVjaW1hbCh2KTtcclxuXHJcbiAgICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIERlY2ltYWwgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgRGVjaW1hbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgICAgLy8gd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWw7XHJcblxyXG4gICAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgRGVjaW1hbCkge1xyXG4gICAgICAgIHgucyA9IHYucztcclxuICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgeC5kID0gKHYgPSB2LmQpID8gdi5zbGljZSgpIDogdjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQgPSB0eXBlb2YgdjtcclxuXHJcbiAgICAgIGlmICh0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICh2ID09PSAwKSB7XHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgICB2ID0gLXY7XHJcbiAgICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZhc3QgcGF0aCBmb3Igc21hbGwgaW50ZWdlcnMuXHJcbiAgICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XHJcbiAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCkgZSsrO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHksIE5hTi5cclxuICAgICAgICB9IGVsc2UgaWYgKHYgKiAwICE9PSAwKSB7XHJcbiAgICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1pbnVzIHNpZ24/XHJcbiAgICAgIGlmICh2LmNoYXJDb2RlQXQoMCkgPT09IDQ1KSB7XHJcbiAgICAgICAgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcclxuICAgIH1cclxuXHJcbiAgICBEZWNpbWFsLnByb3RvdHlwZSA9IFA7XHJcblxyXG4gICAgRGVjaW1hbC5ST1VORF9VUCA9IDA7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgRGVjaW1hbC5ST1VORF9DRUlMID0gMjtcclxuICAgIERlY2ltYWwuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgRGVjaW1hbC5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBEZWNpbWFsLkVVQ0xJRCA9IDk7XHJcblxyXG4gICAgRGVjaW1hbC5jb25maWcgPSBEZWNpbWFsLnNldCA9IGNvbmZpZztcclxuICAgIERlY2ltYWwuY2xvbmUgPSBjbG9uZTtcclxuICAgIERlY2ltYWwuaXNEZWNpbWFsID0gaXNEZWNpbWFsSW5zdGFuY2U7XHJcblxyXG4gICAgRGVjaW1hbC5hYnMgPSBhYnM7XHJcbiAgICBEZWNpbWFsLmFjb3MgPSBhY29zO1xyXG4gICAgRGVjaW1hbC5hY29zaCA9IGFjb3NoOyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmFkZCA9IGFkZDtcclxuICAgIERlY2ltYWwuYXNpbiA9IGFzaW47XHJcbiAgICBEZWNpbWFsLmFzaW5oID0gYXNpbmg7ICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuYXRhbiA9IGF0YW47XHJcbiAgICBEZWNpbWFsLmF0YW5oID0gYXRhbmg7ICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuYXRhbjIgPSBhdGFuMjtcclxuICAgIERlY2ltYWwuY2JydCA9IGNicnQ7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5jZWlsID0gY2VpbDtcclxuICAgIERlY2ltYWwuY29zID0gY29zO1xyXG4gICAgRGVjaW1hbC5jb3NoID0gY29zaDsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmRpdiA9IGRpdjtcclxuICAgIERlY2ltYWwuZXhwID0gZXhwO1xyXG4gICAgRGVjaW1hbC5mbG9vciA9IGZsb29yO1xyXG4gICAgRGVjaW1hbC5oeXBvdCA9IGh5cG90OyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmxuID0gbG47XHJcbiAgICBEZWNpbWFsLmxvZyA9IGxvZztcclxuICAgIERlY2ltYWwubG9nMTAgPSBsb2cxMDsgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5sb2cyID0gbG9nMjsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLm1heCA9IG1heDtcclxuICAgIERlY2ltYWwubWluID0gbWluO1xyXG4gICAgRGVjaW1hbC5tb2QgPSBtb2Q7XHJcbiAgICBEZWNpbWFsLm11bCA9IG11bDtcclxuICAgIERlY2ltYWwucG93ID0gcG93O1xyXG4gICAgRGVjaW1hbC5yYW5kb20gPSByYW5kb207XHJcbiAgICBEZWNpbWFsLnJvdW5kID0gcm91bmQ7XHJcbiAgICBEZWNpbWFsLnNpZ24gPSBzaWduOyAgICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuc2luID0gc2luO1xyXG4gICAgRGVjaW1hbC5zaW5oID0gc2luaDsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLnNxcnQgPSBzcXJ0O1xyXG4gICAgRGVjaW1hbC5zdWIgPSBzdWI7XHJcbiAgICBEZWNpbWFsLnRhbiA9IHRhbjtcclxuICAgIERlY2ltYWwudGFuaCA9IHRhbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC50cnVuYyA9IHRydW5jOyAgICAgICAgLy8gRVM2XHJcblxyXG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSBvYmogPSB7fTtcclxuICAgIGlmIChvYmopIHtcclxuICAgICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIHBzID0gWydwcmVjaXNpb24nLCAncm91bmRpbmcnLCAndG9FeHBOZWcnLCAndG9FeHBQb3MnLCAnbWF4RScsICdtaW5FJywgJ21vZHVsbycsICdjcnlwdG8nXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOykgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRGVjaW1hbC5jb25maWcob2JqKTtcclxuXHJcbiAgICByZXR1cm4gRGVjaW1hbDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGl2KHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5kaXYoeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhlIGJhc2Ugb2YgdGhlIG5hdHVyYWwgbG9nLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZXhwKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZCB0byBhbiBpbnRlZ2VyIHVzaW5nIGBST1VORF9GTE9PUmAuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBmbG9vcih4KSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAzKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSBhcmd1bWVudHMsXHJcbiAgICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogaHlwb3QoYSwgYiwgLi4uKSA9IHNxcnQoYV4yICsgYl4yICsgLi4uKVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaHlwb3QoKSB7XHJcbiAgICB2YXIgaSwgbixcclxuICAgICAgdCA9IG5ldyB0aGlzKDApO1xyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KSB7XHJcbiAgICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgIGlmICghbi5kKSB7XHJcbiAgICAgICAgaWYgKG4ucykge1xyXG4gICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKDEgLyAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdCA9IG47XHJcbiAgICAgIH0gZWxzZSBpZiAodC5kKSB7XHJcbiAgICAgICAgdCA9IHQucGx1cyhuLnRpbWVzKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdC5zcXJ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBvYmplY3QgaXMgYSBEZWNpbWFsIGluc3RhbmNlICh3aGVyZSBEZWNpbWFsIGlzIGFueSBEZWNpbWFsIGNvbnN0cnVjdG9yKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaXNEZWNpbWFsSW5zdGFuY2Uob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGVjaW1hbCB8fCBvYmogJiYgb2JqLm5hbWUgPT09ICdbb2JqZWN0IERlY2ltYWxdJyB8fCBmYWxzZTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbG4oeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxuKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbG9nIG9mIGB4YCB0byB0aGUgYmFzZSBgeWAsIG9yIHRvIGJhc2UgMTAgaWYgbm8gYmFzZVxyXG4gICAqIGlzIHNwZWNpZmllZCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogbG9nW3ldKHgpXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBhcmd1bWVudCBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxvZyh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGJhc2UgMiBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBiYXNlIDEwIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbG9nMTAoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygxMCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBtYXgoKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAnbHQnKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1pbigpIHtcclxuICAgIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsICdndCcpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG1vZHVsbyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1vZCh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkubW9kKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG11bHRpcGxpZWQgYnkgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBtdWwoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLm11bCh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByYWlzZWQgdG8gdGhlIHBvd2VyIGB5YCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYmFzZS5cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBleHBvbmVudC5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvdyh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkucG93KHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJucyBhIG5ldyBEZWNpbWFsIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLCBhbmQgd2l0aFxyXG4gICAqIGBzZGAsIG9yIGBEZWNpbWFsLnByZWNpc2lvbmAgaWYgYHNkYCBpcyBvbWl0dGVkLCBzaWduaWZpY2FudCBkaWdpdHMgKG9yIGxlc3MgaWYgdHJhaWxpbmcgemVyb3NcclxuICAgKiBhcmUgcHJvZHVjZWQpLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiByYW5kb20oc2QpIHtcclxuICAgIHZhciBkLCBlLCBrLCBuLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgciA9IG5ldyB0aGlzKDEpLFxyXG4gICAgICByZCA9IFtdO1xyXG5cclxuICAgIGlmIChzZCA9PT0gdm9pZCAwKSBzZCA9IHRoaXMucHJlY2lzaW9uO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBrID0gTWF0aC5jZWlsKHNkIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgIGlmICghdGhpcy5jcnlwdG8pIHtcclxuICAgICAgZm9yICg7IGkgPCBrOykgcmRbaSsrXSA9IE1hdGgucmFuZG9tKCkgKiAxZTcgfCAwO1xyXG5cclxuICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG4gICAgICBkID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaykpO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgIG4gPSBkW2ldO1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPCA0Mjk0OTY3Mjk2XHJcbiAgICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSA0LjI5ZTksIGlzIDQ5NjcyOTYgLyA0Mjk0OTY3Mjk2ID0gMC4wMDExNiAoMSBpbiA4NjUpLlxyXG4gICAgICAgIGlmIChuID49IDQuMjllOSkge1xyXG4gICAgICAgICAgZFtpXSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIDAgPD0gbiA8PSA0Mjg5OTk5OTk5XHJcbiAgICAgICAgICAvLyAwIDw9IChuICUgMWU3KSA8PSA5OTk5OTk5XHJcbiAgICAgICAgICByZFtpKytdID0gbiAlIDFlNztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgIC8vIDAgPD0gbiA8IDIxNDc0ODM2NDhcclxuICAgICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMHg3ZikgPDwgMjQpO1xyXG5cclxuICAgICAgICAvLyBQcm9iYWJpbGl0eSBuID49IDIuMTRlOSwgaXMgNzQ4MzY0OCAvIDIxNDc0ODM2NDggPSAwLjAwMzUgKDEgaW4gMjg2KS5cclxuICAgICAgICBpZiAobiA+PSAyLjE0ZTkpIHtcclxuICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gMCA8PSBuIDw9IDIxMzk5OTk5OTlcclxuICAgICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICAgIHJkLnB1c2gobiAlIDFlNyk7XHJcbiAgICAgICAgICBpICs9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpID0gayAvIDQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgayA9IHJkWy0taV07XHJcbiAgICBzZCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gc2QuXHJcbiAgICBpZiAoayAmJiBzZCkge1xyXG4gICAgICBuID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBzZCk7XHJcbiAgICAgIHJkW2ldID0gKGsgLyBuIHwgMCkgKiBuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB3b3JkcyB3aGljaCBhcmUgemVyby5cclxuICAgIGZvciAoOyByZFtpXSA9PT0gMDsgaS0tKSByZC5wb3AoKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIGUgPSAwO1xyXG4gICAgICByZCA9IFswXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGUgPSAtMTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHdvcmRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyByZFswXSA9PT0gMDsgZSAtPSBMT0dfQkFTRSkgcmQuc2hpZnQoKTtcclxuXHJcbiAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQgb2YgcmQgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMCkgaysrO1xyXG5cclxuICAgICAgLy8gQWRqdXN0IHRoZSBleHBvbmVudCBmb3IgbGVhZGluZyB6ZXJvcyBvZiB0aGUgZmlyc3Qgd29yZCBvZiByZC5cclxuICAgICAgaWYgKGsgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGs7XHJcbiAgICB9XHJcblxyXG4gICAgci5lID0gZTtcclxuICAgIHIuZCA9IHJkO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBUbyBlbXVsYXRlIGBNYXRoLnJvdW5kYCwgc2V0IHJvdW5kaW5nIHRvIDcgKFJPVU5EX0hBTEZfQ0VJTCkuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiByb3VuZCh4KSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCB0aGlzLnJvdW5kaW5nKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVyblxyXG4gICAqICAgMSAgICBpZiB4ID4gMCxcclxuICAgKiAgLTEgICAgaWYgeCA8IDAsXHJcbiAgICogICAwICAgIGlmIHggaXMgMCxcclxuICAgKiAgLTAgICAgaWYgeCBpcyAtMCxcclxuICAgKiAgIE5hTiAgb3RoZXJ3aXNlXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaWduKHgpIHtcclxuICAgIHggPSBuZXcgdGhpcyh4KTtcclxuICAgIHJldHVybiB4LmQgPyAoeC5kWzBdID8geC5zIDogMCAqIHgucykgOiB4LnMgfHwgTmFOO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc2luKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc2luaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuc2luaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzcXJ0KHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzdWIoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnN1Yih5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRhbih4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkudGFuKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRhbmgoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbmgoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENyZWF0ZSBhbmQgY29uZmlndXJlIGluaXRpYWwgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICBEZWNpbWFsID0gY2xvbmUoREVGQVVMVFMpO1xyXG5cclxuICBEZWNpbWFsWydkZWZhdWx0J10gPSBEZWNpbWFsLkRlY2ltYWwgPSBEZWNpbWFsO1xyXG5cclxuICAvLyBDcmVhdGUgdGhlIGludGVybmFsIGNvbnN0YW50cyBmcm9tIHRoZWlyIHN0cmluZyB2YWx1ZXMuXHJcbiAgTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xyXG4gIFBJID0gbmV3IERlY2ltYWwoUEkpO1xyXG5cclxuXHJcbiAgLy8gRXhwb3J0LlxyXG5cclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gTm9kZSBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRGVjaW1hbDtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxTY29wZSkge1xyXG4gICAgICBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgJiYgc2VsZi5zZWxmID09IHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIG5vQ29uZmxpY3QgPSBnbG9iYWxTY29wZS5EZWNpbWFsO1xyXG4gICAgRGVjaW1hbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBnbG9iYWxTY29wZS5EZWNpbWFsID0gbm9Db25mbGljdDtcclxuICAgICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgICB9O1xyXG5cclxuICAgIGdsb2JhbFNjb3BlLkRlY2ltYWwgPSBEZWNpbWFsO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggUGVkcm8gSm9zw6kgQmF0aXN0YVxyXG5NSVQgTGljZW5zZVxyXG5cclxuU2VlIHRoZSBMSUNFTlNFIGZpbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qKiBbW2luY2x1ZGU6aW5kZXgubWRdXSAqLyAvKiogKi9cclxuaW1wb3J0IHsgRGVjaW1hbCB9IGZyb20gXCJkZWNpbWFsLmpzXCI7XHJcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gXCIuL2xvY2FsaXphdGlvblwiO1xyXG5pbXBvcnQgKiBhcyBsb2NhbGl6YXRpb24gZnJvbSBcIi4vbG9jYWxpemF0aW9uXCI7XHJcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3V0aWxzXCI7XHJcblxyXG4vLyBBbGxvdyBzdWItbW9kdWxlcyB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseSB2aWEgdGhlIG1haW4gbW9kdWxlXHJcbmV4cG9ydCB7IGxvY2FsaXphdGlvbiB9O1xyXG5leHBvcnQgeyB1dGlscyB9O1xyXG5cclxuLy8gT25lIGh1bmRyZWQgc2lnbmlmaWNhbnQgZGlnaXRzIHNlZW0gdG8gYmUgZW5vdWdoIHRvIGhhbmRsZSBtb3JlIGV4dHJlbWUgdGltZSB1bml0c1xyXG5EZWNpbWFsLnNldCh7IHByZWNpc2lvbjogMTAwIH0pO1xyXG5cclxuLy8jcmVnaW9uIE5vbi1leHBvcnRlZCBGdW5jdGlvbnNcclxuXHJcbmZ1bmN0aW9uIGZpbHRlckVtcHR5KHRhcmdldDogYW55W10pIHtcclxuICAgIHJldHVybiB0YXJnZXQuZmlsdGVyKHZhbHVlID0+IHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gXCJcIjtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBNZXJnZXMgdGhlIGltbWVkaWF0ZSBwcm9wZXJ0aWVzIG9mIGFsbCBnaXZlbiBvYmplY3RzXHJcbmZ1bmN0aW9uIG1lcmdlPFQgZXh0ZW5kcyBvYmplY3Q+KC4uLiBvYmplY3RzOiBBcnJheTxUIHwgdW5kZWZpbmVkPikge1xyXG5cclxuICAgIGxldCBtZXJnZWQgPSB7fSBhcyBUO1xyXG5cclxuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcclxuICAgICAgICBtZXJnZWQgPSBPYmplY3QuYXNzaWduKG1lcmdlZCwgb2JqZWN0IHx8IHt9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG59XHJcblxyXG4vLyBSZXBsYWNlcyB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGEgc3RyaW5nLCB3aXRoaW4gYSBzdHJpbmdcclxuLy8gVGhhbmtzIHRvIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDk3MzY1XHJcbmZ1bmN0aW9uIHJlcGxhY2VMYXN0KHN0cjogc3RyaW5nLCBzZWFyY2g6IHN0cmluZywgcmVwbGFjZW1lbnQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgaW5kZXggPSBzdHIubGFzdEluZGV4T2Yoc2VhcmNoKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyByZXBsYWNlbWVudCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcclxufVxyXG5cclxuLy8gR2V0cyBhIG5hbWVkIHRpbWUgdW5pdCBvYmplY3QgZnJvbSBhIHRpbWUgdW5pdCBwYXJhbWV0ZXIsIHVzaW5nIHRoZSBUSU1FX1VOSVRTIGRhdGFiYXNlXHJcbmZ1bmN0aW9uIHRpbWVVbml0RnJvbVNvdXJjZShwYXJhbWV0ZXI6IFRpbWVVbml0U291cmNlIHwgc3RyaW5nKSB7XHJcblxyXG4gICAgY29uc3QgYXNzaWduID0gKG5hbWU6IHN0cmluZywgdGltZVVuaXQ6IGFueSk6IE5hbWVkVGltZVVuaXQgPT4gT2JqZWN0LmFzc2lnbih7IG5hbWUgfSwgdGltZVVuaXQpO1xyXG5cclxuICAgIC8vIHRzbGludDpkaXNhYmxlOmN1cmx5XHJcbiAgICBpZiAodHlwZW9mKHBhcmFtZXRlcikgPT09IFwib2JqZWN0XCIpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGNvbmRpdGlvbiAxOiBUaGUgb2JqZWN0IGFscmVhZHkgaXMgbmFtZWRcclxuICAgICAgICBpZiAocGFyYW1ldGVyLmhhc093blByb3BlcnR5KFwibmFtZVwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyIGFzIE5hbWVkVGltZVVuaXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gY29uZGl0aW9uIDI6IEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGFuZCBuYW1lIGl0XHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lVW5pdE5hbWUgaW4gVGltZVVuaXRzKSBpZiAoVGltZVVuaXRzLmhhc093blByb3BlcnR5KHRpbWVVbml0TmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKFRpbWVVbml0c1t0aW1lVW5pdE5hbWUgYXMga2V5b2YgVGltZVVuaXREYXRhYmFzZV0gPT09IHBhcmFtZXRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbih0aW1lVW5pdE5hbWUsIChUaW1lVW5pdHMgYXMgYW55KVt0aW1lVW5pdE5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mKHBhcmFtZXRlcikgPT09IFwic3RyaW5nXCIpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGNvbmRpdGlvbiAzOiBVbml0IG5hbWUgbWF0Y2hlcyBvYmplY3QgbmFtZSBleGFjdGx5IChUUyB3aWxsIGVuZm9yY2UgdGhpcywgYnV0IEpTIHdvbid0KVxyXG4gICAgICAgIGlmIChUaW1lVW5pdHMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKHBhcmFtZXRlciwgKFRpbWVVbml0cyBhcyBhbnkpW3BhcmFtZXRlcl0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyYW1ldGVyLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBjb25kaXRpb24gNDogVW5pdCBuYW1lIGlzIGEgY2FzZSB2YXJpYXRpb24gb3IgcGx1cmFsXHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lVW5pdE5hbWUgaW4gVGltZVVuaXRzKSBpZiAoVGltZVVuaXRzLmhhc093blByb3BlcnR5KHRpbWVVbml0TmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tUGx1cmFsID0gVGltZVVuaXRzW3RpbWVVbml0TmFtZSBhcyBrZXlvZiBUaW1lVW5pdERhdGFiYXNlXS5jdXN0b21QbHVyYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWItY29uZGl0aW9ucyAoaWYgdGFyZ2V0IGlzIGVxdWFsIHRvIGFueSBvZiB0aGVzZSwgd2UgZm91bmQgYSB2YXJpYXRpb24pXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbjEgPSB0aW1lVW5pdE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uMiA9IGNvbmRpdGlvbjEgKyBcInNcIjtcclxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uMyA9IHRpbWVVbml0TmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxICQyXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbjQgPSB0eXBlb2YoY3VzdG9tUGx1cmFsKSA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgPyBjdXN0b21QbHVyYWwudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICAgICAgOiBjb25kaXRpb24zICsgXCJzXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb25kaXRpb24xIHx8IHRhcmdldCA9PT0gY29uZGl0aW9uMiB8fCB0YXJnZXQgPT09IGNvbmRpdGlvbjMgfHwgdGFyZ2V0ID09PSBjb25kaXRpb240KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduKHRpbWVVbml0TmFtZSwgKFRpbWVVbml0cyBhcyBhbnkpW3RpbWVVbml0TmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmVuYWJsZTpjdXJseVxyXG5cclxuICAgIC8vIE5vIGNvbmRpdGlvbiBtZXQsIHVuaXQgaXMgaW52YWxpZFxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lIHVuaXRcIik7XHJcbn1cclxuXHJcbi8vI2VuZHJlZ2lvblxyXG5cclxuLy8jcmVnaW9uIE5vbi1leHBvcnRlZCBWYXJpYWJsZXNcclxuXHJcbmNvbnN0IGRlZmF1bHRTZXR0aW5nczogVGltZVdyaXRlclNldHRpbmdzID0ge1xyXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogXCIuXCIsXHJcbiAgICBoaWRlVGltZVVuaXQ6IGZhbHNlLFxyXG4gICAgaGlkZVplcm9TZWdtZW50czogdHJ1ZSxcclxuICAgIG51bWVyaWNOb3RhdGlvbjogXCJkZWNpbWFsXCIsXHJcbiAgICByb3VuZGluZ01vZGU6IDQsXHJcbiAgICBzZWdtZW50U2VwYXJhdG9yOiBcIiwgXCIsXHJcbiAgICBzaWduaWZpY2FudERpZ2l0czogMTAsXHJcbiAgICBzeW1ib2xBcHByb3hpbWF0ZWx5OiBcIuKJiFwiLFxyXG4gICAgc3ltYm9sSW5maW5pdGU6IFwi4oieXCIsXHJcbiAgICBzeW1ib2xOYU46IFwiTmFOXCIsXHJcbiAgICB0ZXJtQXBwcm94aW1hdGVseTogXCJhcHByb3hpbWF0ZWx5XCIsXHJcbiAgICB0ZXJtSW5maW5pdGU6IFwiaW5maW5pdGVcIixcclxuICAgIHRlcm1OYU46IFwiaW52YWxpZCBudW1iZXIgb2ZcIixcclxuICAgIHRpbWVVbml0U2VwYXJhdG9yOiBcIiBcIixcclxuICAgIHZlcmJvc2U6IGZhbHNlLFxyXG59O1xyXG5cclxuLy8gR2V0cyB0aGUgZGVjaW1hbCBzZXBhcmF0b3IgZnJvbSBhIGxvY2FsZSBzdHJpbmdcclxuY29uc3QgbG9jYWxlRGVjaW1hbFNlcGFyYXRvciA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IDEuMTtcclxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkuc3Vic3RyaW5nKDEsIDIpO1xyXG4gICAgcmV0dXJuIHNlcGFyYXRvcjtcclxufSkoKTtcclxuXHJcbi8vIExpc3Qgb2Ygcm9tYW4gbnVtZXJhbHMgZnJvbSBncmVhdGVyIHRvIGxlc3NlclxyXG5jb25zdCByb21hbk51bWVyYWxzOiBBcnJheTxbbnVtYmVyLCBzdHJpbmddPiA9IFtcclxuICAgIFsxMDAwLCBcIk1cIl0sICBbOTAwLCBcIkNNXCJdLCBbNTAwLCBcIkRcIl0sIFs0MDAsIFwiQ0RcIl0sXHJcbiAgICBbMTAwLCBcIkNcIl0sICAgWzkwLCBcIlhDXCJdLCAgWzUwLCBcIkxcIl0sICBbNDAsIFwiWExcIl0sXHJcbiAgICBbMTAsIFwiWFwiXSwgICAgWzksIFwiSVhcIl0sICAgWzUsIFwiVlwiXSwgICBbNCwgXCJJVlwiXSwgWzEsIFwiSVwiXSxcclxuXTtcclxuXHJcbmNvbnN0IHJvbWFuTnVtZXJhbHNCaWc6IEFycmF5PFtudW1iZXIsIHN0cmluZ10+ID0gW1xyXG4gICAgWzEwMDAwMDAsIGBNzIVgXSwgWzkwMDAwMCwgYEPMhU3MhWBdLCBbNTAwMDAwLCBgRMyFYF0sIFs0MDAwMDAsIGBDzIVEzIVgXSxcclxuICAgIFsxMDAwMDAsIGBDzIVgXSwgIFs5MDAwMCwgYFjMhUPMhWBdLCAgWzUwMDAwLCBgTMyFYF0sICBbNDAwMDAsIGBYzIVMzIVgXSxcclxuICAgIFsxMDAwMCwgYFjMhWBdLCAgIFs5MDAwLCBgScyFWMyFYF0sICAgWzUwMDAsIGBWzIVgXSwgICBbNDAwMCwgYEnMhVbMhWBdLCBbMTAwMCwgYEnMhWBdLFxyXG5dLmNvbmNhdChyb21hbk51bWVyYWxzLnNsaWNlKDEpKSBhcyBhbnk7XHJcblxyXG4vLyBMaXN0IG9mIHJvbWFuIGZyYWN0aW9ucyBpbiBubyBzcGVjaWZpYyBvcmRlclxyXG5jb25zdCByb21hbkZyYWN0aW9uczogQXJyYXk8W251bWJlciwgc3RyaW5nXT4gPSBbXHJcbiAgICBbMSAvIDEyLCBcIuKAolwiXSwgIFsyIC8gMTIsIFwiOlwiXSwgIFszIC8gMTIsIFwi4oi0XCJdLCAgWzQgLyAxMiwgXCI6OlwiXSwgICBbNSAvIDEyLCBcIjrCtzpcIl0sICAgWzYgLyAxMiwgXCJTXCJdLFxyXG4gICAgWzcgLyAxMiwgXCJT4oCiXCJdLCBbOCAvIDEyLCBcIlM6XCJdLCBbOSAvIDEyLCBcIlPiiLRcIl0sIFsxMCAvIDEyLCBcIlM6OlwiXSwgWzExIC8gMTIsIFwiUzrCtzpcIl0sXHJcbiAgICBbMSAvIDM2LCBcIsanxqdcIl0sIFsxIC8gNDgsIFwixoZcIl0sIFsxIC8gNzIsIFwixqdcIl0sIFsxIC8gMjg4LCBcIuKEiFwiXSxcclxuXTtcclxuXHJcbi8vI2VuZHJlZ2lvblxyXG5cclxuLy8jcmVnaW9uIEV4cG9ydGVkIEZ1bmN0aW9uc1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIG51bWVyaWMgdmFsdWUgdXNpbmcgbnVtZXJhbHMgZnJvbSB0aGUgX0FuY2llbnQgUm9tZV8uXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiAgIEEgbnVtYmVyIG9yIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly9taWtlbWNsLmdpdGh1Yi5pby9kZWNpbWFsLmpzKSB0byBiZSBjb252ZXJ0ZWQgdG8gcm9tYW4uXHJcbiAqIEBwYXJhbSBmcmFjdGlvbnNcclxuICogICBXaGV0aGVyIHRvIGluY2x1ZGUgW2NvbW1vbiBmcmFjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbWFuX251bWVyYWxzI0ZyYWN0aW9ucykgb3Igbm90LlxyXG4gKiBAcmV0dXJuXHJcbiAqICAgQSBzdHJpbmcgd2l0aCB0aGUgcm9tYW4gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIG51bWJlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVJvbWFuKHZhbHVlOiBudW1iZXIgfCBEZWNpbWFsLCBmcmFjdGlvbnM6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG5cclxuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgdmFsdWUgPSBuZXcgRGVjaW1hbCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZml4ZWRWYWx1ZSA9IHZhbHVlLnRydW5jKCk7XHJcbiAgICBjb25zdCBudW1lcmFscyA9IHZhbHVlLmNvbXBhcmVkVG8oNTAwMCkgPiAwID8gcm9tYW5OdW1lcmFsc0JpZyA6IHJvbWFuTnVtZXJhbHM7XHJcbiAgICBsZXQgYW1vdW50TGVmdCA9IGZpeGVkVmFsdWU7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuXHJcbiAgICB3aGlsZSAoYW1vdW50TGVmdC5jb21wYXJlZFRvKDApID4gMCkge1xyXG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiByb21hbk51bWVyYWxzIGlzIGltcG9ydGFudCBoZXJlOiB0aGV5IGFyZSB3cml0dGVuIGZyb20gbGFyZ2UgdG8gbGVzc2VyXHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBudW1lcmFscykge1xyXG5cclxuICAgICAgICAgICAgLy8gU28sIGlmIHZhbHVlIGlzIDExMTEsIHRoaXMgYWNjb3VudHMgZm9yIE0gKDEwMDApIGZpcnN0LCB0aGVuIEMgKDEwMCksIHRoZW4gWCAoMTApLCB0aGVuIEkgKDEpXHJcbiAgICAgICAgICAgIGlmIChhbW91bnRMZWZ0LmNvbXBhcmVkVG8oZW50cnlbMF0pID49IDApIHtcclxuICAgICAgICAgICAgICAgIGFtb3VudExlZnQgPSBhbW91bnRMZWZ0Lm1pbnVzKGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlbnRyeVsxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChmcmFjdGlvbnMgJiYgdmFsdWUuY29tcGFyZWRUbyhmaXhlZFZhbHVlKSA+IDApIHtcclxuICAgICAgICByZXN1bHQgKz0gd3JpdGVSb21hbkZyYWN0aW9ucyh2YWx1ZS5taW51cyhmaXhlZFZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogXCJudWxsYVwiO1xyXG59XHJcblxyXG4vKipcclxuICogV3JpdGVzIHRoZSBmcmFjdGlvbiBwYXJ0IG9mIGEgbnVtZXJpYyB2YWx1ZSB1c2luZyBjb21tb24gZnJhY3Rpb25zIGZyb20gdGhlIF9BbmNpZW50IFJvbWVfLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogICBBIG51bWJlciB0aGF0IHdpbGwgaGF2ZSBpdHMgZGVjaW1hbCBwYXJ0IGV4dHJhY3RlZCBhbmQgd3JpdHRlbiBpbiByb21hbi5cclxuICogQHJldHVyblxyXG4gKiAgIEEgc3RyaW5nIHdpdGggdGhlIHJvbWFuIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBmcmFjdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVJvbWFuRnJhY3Rpb25zKHZhbHVlOiBudW1iZXIgfCBEZWNpbWFsKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSA9IHZhbHVlLm1pbnVzKHZhbHVlLnRydW5jKCkpO1xyXG5cclxuICAgIGlmICh2YWx1ZS5jb21wYXJlZFRvKDApID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNtYWxsZXN0RGlmZmVyZW5jZSA9IG5ldyBEZWNpbWFsKDEpO1xyXG4gICAgbGV0IHNtYWxsZXN0SW5kZXggPSAtMTtcclxuXHJcbiAgICAvLyBOb3QgbXVjaCB0byBleHBsYWluOiBjb21wYXJlcyBhbGwgcm9tYW5GcmFjdGlvbnMgd2l0aCB0aGUgZ2l2ZW4gZnJhY3Rpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZVxyXG4gICAgLy8gc21hbGxlc3QgZGlmZmVyZW5jZSAob25seSBmYXN0ZXIgaWYgdGhlIGRpZmZlcmVuY2UgaXMgZXhhY3RseSB6ZXJvKVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9tYW5GcmFjdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBjb25zdCByb21hbkZyYWN0aW9uID0gcm9tYW5GcmFjdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHZhbHVlLm1pbnVzKHJvbWFuRnJhY3Rpb25bMF0pLmFicygpO1xyXG5cclxuICAgICAgICBpZiAoZGlmZmVyZW5jZS5jb21wYXJlZFRvKDApID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb21hbkZyYWN0aW9uWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpZmZlcmVuY2UuY29tcGFyZWRUbyhzbWFsbGVzdERpZmZlcmVuY2UpIDwgMCkge1xyXG4gICAgICAgICAgICBzbWFsbGVzdERpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICBzbWFsbGVzdEluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvbWFuRnJhY3Rpb25zW3NtYWxsZXN0SW5kZXhdWzFdO1xyXG59XHJcblxyXG4vLyNlbmRyZWdpb25cclxuXHJcbi8vI3JlZ2lvbiBFeHBvcnRlZCBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBPYmplY3RzIHBlcnRhaW5pbmcgdG8gdGhpcyBjb25zdGFudCBjYW4gYmUgdXNlZCBhcyBhIHBhcmFtZXRlciB2YWx1ZSBmb3IgdGhlXHJcbiAqIFtjb3VudGRvd25dKC4uL2NsYXNzZXMvX2luZGV4Xy50aW1ld3JpdGVyLmh0bWwjY291bnRkb3duKSBtZXRob2Qgb2YgdGltZSB3cml0ZXJzLlxyXG4gKlxyXG4gKiBUaGVzZSBjb25zdGFudHMgY29udGFpbnMgZ3JvdXBzIG9mIFt0aW1lIHVuaXRzXSguLi9jbGFzc2VzL19pbmRleF8udGltZXVuaXRkYXRhYmFzZS5odG1sKSB0aGF0IGFyZSByZWxhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRpbWVTZWdtZW50cyA9IHtcclxuXHJcbiAgICAvKiogQWxsIGJhc2UgdGVuIFtTSV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9TeXN0ZW1fb2ZfVW5pdHMpIHRpbWUgdW5pdHMuICovXHJcbiAgICBiYXNlVGVuOiBbXCJ5b3R0YXNlY29uZFwiLCBcInpldHRhc2Vjb25kXCIsIFwiZXhhc2Vjb25kXCIsIFwicGV0YXNlY29uZFwiLCBcInRlcmFzZWNvbmRcIiwgXCJnaWdhc2Vjb25kXCIsIFwibWVnYXNlY29uZFwiLFxyXG4gICAgICAgIFwia2lsb3NlY29uZFwiLCBcInNlY29uZFwiLCBcIm1pbGlzZWNvbmRcIiwgXCJtaWNyb3NlY29uZFwiLCBcIm5hbm9zZWNvbmRcIiwgXCJwaWNvc2Vjb25kXCIsIFwiZmVtdG9zZWNvbmRcIiwgXCJhdHRvc2Vjb25kXCIsXHJcbiAgICAgICAgXCJ6ZXB0b3NlY29uZFwiLCBcInlvY3Rvc2Vjb25kXCJdLFxyXG5cclxuICAgIC8qKiBBbGwgYmFzZSB0d28gYmluYXJ5IHRpbWUgdW5pdHMuICovXHJcbiAgICBiaW5hcnk6IFtcInlvYmlzZWNvbmRcIiwgXCJ6ZWJpc2Vjb25kXCIsIFwiZXhiaXNlY29uZFwiLCBcInBlYmlzZWNvbmRcIiwgXCJ0ZWJpc2Vjb25kXCIsIFwiZ2liaXNlY29uZFwiLCBcIm1lYmlzZWNvbmRcIixcclxuICAgICAgICBcImtpYmlzZWNvbmRcIiwgXCJzZWNvbmRcIl0sXHJcblxyXG4gICAgLyoqIENvbW1vbiB0aW1lIHVuaXQgc2VnbWVudGF0aW9uOiB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUgYW5kIHNlY29uZC4gKi9cclxuICAgIGNvbW1vbjogW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiXSxcclxuXHJcbiAgICAvKiogRXh0cmVtZXMgYW5kIHRoZSBtaWRkbGUtcG9pbnQgb2YgdGltZWNvdW50IHVuaXRzOiBQbGFuY2sgdGltZSwgbmFub3NlY29uZCBhbmQgeW9iaXNlY29uZC4gKi9cclxuICAgIGV4dHJlbWVzOiBbXCJwbGFuY2tUaW1lXCIsIFwibmFub3NlY29uZFwiLCBcInlvYmlzZWNvbmRcIl0sXHJcblxyXG4gICAgLyoqIENvbnRhaW5zIGFsbCB1bml0cyBvZiBhIFtzaWRlcmVhbCB0aW1lXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWRlcmVhbF90aW1lKS4gKi9cclxuICAgIHNpZGVyZWFsOiBbXCJzaWRlcmVhbFllYXJcIiwgXCJzaWRlcmVhbE1vbnRoXCIsIFwic2lkZXJlYWxEYXlcIiwgXCJzaWRlcmVhbEhvdXJcIiwgXCJzaWRlcmVhbE1pbnV0ZVwiLCBcInNpZGVyZWFsU2Vjb25kXCJdLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgZGF0YWJhc2Ugb2YgW3RpbWUgdW5pdHNdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ldW5pdC5odG1sKSwgdXNlZCB0byBxdWFsaWZ5IGFuZCBkZXNjcmliZSBsZW5ndGhzIG9mIHRpbWUuXHJcbiAqXHJcbiAqIEVhY2ggcHJvcGVydHkgb2YgdGhpcyBvYmplY3QgZW51bWVyYXRlcyB0aGUgbGluZ3Vpc3RpYyBhbmQgbWF0aGVtYXRpY2FsIGZlYXR1cmVzIG9mIHRoZSB0aW1lIHVuaXQgaXQgcmVwcmVzZW50cy5cclxuICpcclxuICogLS0tXHJcbiAqXHJcbiAqIFNlZSBbVGltZVVuaXREYXRhYmFzZV0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV1bml0ZGF0YWJhc2UuaHRtbCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGltZSB1bml0cy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBUaW1lVW5pdHM6IFRpbWVVbml0RGF0YWJhc2U8VGltZVVuaXQ+ID0ge1xyXG4gICAgYW5vbWFsaXN0aWNNb250aDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMi4zODA3MTMxMmUrMTVcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgYW5vbWFsaXN0aWNZZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1NTg0MzI1NTA0ZSsxNlwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBhdHRvc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZS05XCIpLCBzeW1ib2w6IFwiYXNcIiB9LFxyXG4gICAgYmllbm5pdW06IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjYuMzExMzkwNGUrMTZcIiksIGN1c3RvbVBsdXJhbDogXCJiaWVubmlhXCIgfSxcclxuICAgIGNlbnR1cnk6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjMuMTUzNmUrMThcIiksIGN1c3RvbVBsdXJhbDogXCJjZW50dXJpZXNcIiB9LFxyXG4gICAgY29zbWljWWVhcjogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiNy40ODk4ZSsyNFwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBkYXk6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjguNjRlKzEzXCIpLCBzeW1ib2w6IFwiZFwiIH0sXHJcbiAgICBkZWNhZGU6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjMuMTU1Njk1MmUrMTdcIikgfSxcclxuICAgIGRyYWNvbmljTW9udGg6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuMzUxMTM1ODA4ZSsxNVwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBkcmFjb25pY1llYXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuOTk0Nzk3NDU1NjI5ZSsxNlwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBlY2xpcHRpY1llYXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuOTk0Nzk3NDU1NjI5ZSsxNlwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBleGFzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlKzI3XCIpLCBzeW1ib2w6IFwiRXNcIiB9LFxyXG4gICAgZXhiaXNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMS4xNTI5MjE1MDQ2MDY4NDY5NzZlKzI3XCIpLCBzeW1ib2w6IFwiRWlzXCIgfSxcclxuICAgIGZlbXRvc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZS02XCIpLCBzeW1ib2w6IFwiZnNcIiB9LFxyXG4gICAgZm9ydG5pZ2h0OiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxLjIwOTZlKzE1XCIpIH0sXHJcbiAgICBnYWxhY3RpY1llYXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjcuNDg5OGUrMjRcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgZ2liaXNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMS4wNzM3NDE4MjRlKzE4XCIpLCBzeW1ib2w6IFwiR2lzXCIgfSxcclxuICAgIGdpZ2FzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlKzE4XCIpLCBzeW1ib2w6IFwiR3NcIiB9LFxyXG4gICAgZ3JlZ29yaWFuWWVhcjogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMy4xNTU2OTUyZSsxNlwiKSwgcmVhZGFibGVOYW1lOiBcIkdyZWdvcmlhbiB5ZWFyXCIgfSxcclxuICAgIGhvdXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjMuNmUrMTJcIiksIHN5bWJvbDogXCJoXCIgfSxcclxuICAgIGppZmZ5OiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzZS0xNVwiKSwgY3VzdG9tUGx1cmFsOiBcImppZmZpZXNcIiB9LFxyXG4gICAganVsaWFuWWVhcjogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMy4xNTU3NmUrMTZcIiksIHJlYWRhYmxlTmFtZTogXCJKdWxpYW4geWVhclwiIH0sXHJcbiAgICBraWJpc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxLjAyNGUrMTJcIiksIHN5bWJvbDogXCJLaXNcIiB9LFxyXG4gICAga2lsb3NlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMWUrMTJcIiksIHN5bWJvbDogXCJLc1wiIH0sXHJcbiAgICBraWxveWVhcjogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMy4xNTM2ZSsxOVwiKSwgc3ltYm9sOiBcImt5XCIgfSxcclxuICAgIGxlYXBZZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE2MjI0ZSsxNlwiKSB9LFxyXG4gICAgbHVzdHJ1bTogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMS41Nzc4NDc2ZSsxN1wiKSwgY3VzdG9tUGx1cmFsOiBcImx1c3RyYVwiIH0sXHJcbiAgICBtZWJpc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxLjA0ODU3NmUrMTVcIiksIHN5bWJvbDogXCJNaXNcIiB9LFxyXG4gICAgbWVnYXNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMWUrMTVcIiksIHN5bWJvbDogXCJNc1wiIH0sXHJcbiAgICBtaWNyb3NlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMWUrM1wiKSwgc3ltYm9sOiBcIsK1c1wiIH0sXHJcbiAgICBtaWxpc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZSs2XCIpLCBzeW1ib2w6IFwibXNcIiB9LFxyXG4gICAgbWlsbGVuaXVtOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1NTY5NTJlKzE5XCIpLCBjdXN0b21QbHVyYWw6IFwibWlsbGVubmlhXCIgfSxcclxuICAgIG1pbnV0ZTogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiNmUrMTBcIiksIHN5bWJvbDogXCJtaW5cIiB9LFxyXG4gICAgbW9udGg6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuNjI4ZSsxNVwiKSwgc3ltYm9sOiBcIm1cIiB9LFxyXG4gICAgbmFub3NlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMVwiKSwgc3ltYm9sOiBcIm5zXCIgfSxcclxuICAgIG5vZGljYWxNb250aDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMi4zNTExMzU4MDhlKzE1XCIpLCBhcHByb3hpbWF0ZWQ6IHRydWUgfSxcclxuICAgIG5vbkxlYXBZZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1MzZlKzE2XCIpLCByZWFkYWJsZU5hbWU6IFwibm9uLWxlYXAgeWVhclwiIH0sXHJcbiAgICBub3Zlbm5pdW06IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuODQwMTI1NjhlKzE3XCIpLCBjdXN0b21QbHVyYWw6IFwibm92ZW5uaWFcIiB9LFxyXG4gICAgb2N0ZW5uaXVtOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIyLjUyNDU1NjE2ZSsxN1wiKSwgY3VzdG9tUGx1cmFsOiBcIm9jdGVubmlhXCIgfSxcclxuICAgIHBlYmlzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjEuMTI1ODk5OTA2ODQyNjI0ZSsyNFwiKSwgc3ltYm9sOiBcIlBpc1wiIH0sXHJcbiAgICBwZXRhc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZSsyNFwiKSwgc3ltYm9sOiBcIlBzXCIgfSxcclxuICAgIHBpY29zZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlLTNcIiksIHN5bWJvbDogXCJwc1wiIH0sXHJcbiAgICBwbGFuY2tUaW1lOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCI1LjM5MDU2ZS0zNVwiKSwgc3ltYm9sOiBcInTigppcIiwgcmVhZGFibGVOYW1lOiBcIlBsYW5jayB0aW1lXCIgfSxcclxuICAgIHF1YWRyZW5uaXVtOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxLjI2MjI3ODA4ZSsxN1wiKSwgY3VzdG9tUGx1cmFsOiBcInF1YWRyZW5uaWFcIiB9LFxyXG4gICAgcXVpbmRlY2Vubml1bTogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiNC43MzM1NDI4ZSsxN1wiKSwgY3VzdG9tUGx1cmFsOiBcInF1aW5kZWNlbm5pYVwiIH0sXHJcbiAgICBxdWlucXVlbm5pdW06IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjEuNTc3ODQ3NmUrMTdcIiksIGN1c3RvbVBsdXJhbDogXCJxdWlucXVlbm5pYVwiIH0sXHJcbiAgICBzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlKzlcIiksIHN5bWJvbDogXCJzXCIgfSxcclxuICAgIHNlcHRlbm5pdW06IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuMjA3NTJlKzE3XCIpLCBjdXN0b21QbHVyYWw6IFwic2VwdGVubmlhXCIgfSxcclxuICAgIHNoYWtlOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxMFwiKSB9LFxyXG4gICAgc2lkZXJlYWxEYXk6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjguNjE2NDA5ZSsxM1wiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBzaWRlcmVhbEhvdXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjMuNTkwMTcwNDE2NjY3ZSsxMlwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBzaWRlcmVhbE1pbnV0ZTogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiNS45ODM2MTczNjExMTFlKzEwXCIpLCBhcHByb3hpbWF0ZWQ6IHRydWUgfSxcclxuICAgIHNpZGVyZWFsTW9udGg6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjIuMzYwNTkxNDI0ZSsxNVwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBzaWRlcmVhbFNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiOS45NzI2OTU2MDE4NTJlKzhcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgc2lkZXJlYWxZZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1NTgxNDk1NGUrMTZcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgc29sYXJEYXk6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjguNjRlKzEzXCIpIH0sXHJcbiAgICBzb2xhclllYXI6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjMuMTU1NjkzZSsxNlwiKSwgYXBwcm94aW1hdGVkOiB0cnVlIH0sXHJcbiAgICBzdmVkYmVyZzogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMWUtNFwiKSwgc3ltYm9sOiBcIlN2XCIgfSxcclxuICAgIHN5bm9kaWNNb250aDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMi41NTE0NDM4NGUrMTVcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgdGViaXNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMS4wOTk1MTE2Mjc3NzZlKzIxXCIpLCBzeW1ib2w6IFwiVGlzXCIgfSxcclxuICAgIHRlcmFzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlKzIxXCIpLCBzeW1ib2w6IFwiVHNcIiB9LFxyXG4gICAgdGltZVVuaXQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjEuMDI0ZSs2XCIpLCBzeW1ib2w6IFwiVFVcIiB9LFxyXG4gICAgdHJvcGljYWxZZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1NTY5M2UrMTZcIiksIGFwcHJveGltYXRlZDogdHJ1ZSB9LFxyXG4gICAgd2VlazogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiNi4wNDhlKzE0XCIpLCBzeW1ib2w6IFwid1wiIH0sXHJcbiAgICB5ZWFyOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIzLjE1NTY5NTJlKzE2XCIpLCBzeW1ib2w6IFwieVwiIH0sXHJcbiAgICB5b2Jpc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxLjIwODkyNTgxOTYxNDYyOTE3NDcwNjE3NmUrMzNcIiksIHN5bWJvbDogXCJZaXNcIiB9LFxyXG4gICAgeW9jdG9zZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlLTE1XCIpLCBzeW1ib2w6IFwieXNcIiB9LFxyXG4gICAgeW90dGFzZWNvbmQ6IHsgZmFjdG9yOiBuZXcgRGVjaW1hbChcIjFlKzMzXCIpLCBzeW1ib2w6IFwiWXNcIiB9LFxyXG4gICAgemViaXNlY29uZDogeyBmYWN0b3I6IG5ldyBEZWNpbWFsKFwiMS4xODA1OTE2MjA3MTc0MTEzMDM0MjRlKzMwXCIpLCBzeW1ib2w6IFwiWmlzXCIgfSxcclxuICAgIHplcHRvc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZS0xMlwiKSwgc3ltYm9sOiBcInpzXCIgfSxcclxuICAgIHpldHRhc2Vjb25kOiB7IGZhY3RvcjogbmV3IERlY2ltYWwoXCIxZSszMFwiKSwgc3ltYm9sOiBcIlpzXCIgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyB0byBbVGltZVVuaXRzXSgjdGltZXVuaXRzLTEpLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBJbmNvcnJlY3QgbmFtaW5nLCBhbGwgZXhwb3J0ZWQgY29uc3RhbnRzIGFyZSBub3cgY2FwaXRhbGl6ZWQgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGltZVVuaXRzID0gVGltZVVuaXRzO1xyXG5cclxuLy8jZW5kcmVnaW9uXHJcblxyXG4vLyNyZWdpb24gRXhwb3J0ZWQgVHlwZXNcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIGJhc2UgdGltZSB1bml0IGRlZmluaXRpb24sIGNvbnNpc3Rpbmcgb2YgbGluZ3Vpc3RpYy1yZWxhdGVkIHByb3BlcnRpZXMgcGVydGFpbmluZyB0byB0aGUgdGltZVxyXG4gKiB1bml0IGJlaW5nIGRlc2NyaWJlZC5cclxuICpcclxuICogTWF0aGVtYXRpY2FsIHByb3BlcnRpZXMgYXJlIGxlZnQgb3V0IG9mIHRoaXMgaW50ZXJmYWNlIGluIG9yZGVyIHRvIGFsbG93IGJldHRlciBjb250cm9sIG92ZXIgY29uZmlndXJhdGlvbnMgKGFuZFxyXG4gKiBzaW5jZSB0aW1lIHVuaXRzIGhhdmUgdGhlIHNhbWUgbWF0aGVtYXRpY2FsIGNvbnN0YW50cyByZWdhcmRsZXNzIG9mIGxhbmd1YWdlKS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVRpbWVVbml0IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBjdXN0b20gcGx1cmFsaXplZCBuYW1lIGZvciB0aGUgdGltZSB1bml0OyBpdCBjYW4gYmUgYSBzdHJpbmcg4oCUIHVzZWQgd2hlbmV2ZXIgdGhlIHF1YW50aXR5IG9mIHRpbWUgaXNcclxuICAgICAqIGdyZWF0ZXIgdGhhbiBvbmUg4oCUIG9yIGEgZnVuY3Rpb24sIGFibGUgdG8gcmV0cmlldmUgZGlmZmVyZW50IHdvcmRzIGFjY29yZGluZyB0byBhIGdpdmVuIHF1YW50aXR5LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHdvcmRzIGFyZSBwbHVyYWxpemVkIGJ5IGFkZGluZyBhbiBcInNcIiB0byB0aGUgZW5kIG9mIHRoZWlyIFtyZWFkYWJsZSBuYW1lXSgjcmVhZGFibGVuYW1lKS5cclxuICAgICAqL1xyXG4gICAgY3VzdG9tUGx1cmFsPzogc3RyaW5nIHwgTnVtZXJpY1dyaXRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgdGltZSB1bml0IHNob3VsZCBiZSBwbHVyYWxpemVkOiBieSBkZWZhdWx0LCB3b3JkcyBhcmUgcGx1cmFsaXplZCBieSBhZGRpbmcgYW4gXCJzXCIgdG8gdGhlXHJcbiAgICAgKiBlbmQgb2YgdGhlaXIgW3JlYWRhYmxlIG5hbWVdKCNyZWFkYWJsZW5hbWUpLCBidXQgdGhpcyBjYW4gYmUgY2hhbmdlZCB2aWEgW2N1c3RvbVBsdXJhbF0oI2N1c3RvbXBsdXJhbCkuXHJcbiAgICAgKlxyXG4gICAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGlzIHdpbGwgcHJldmVudCB0aGUgdGltZSB1bml0IGZyb20gZXZlciBiZWluZyBwbHVyYWxpemVkICh1bmxlc3MgdGhpcyBjb25maWd1cmF0aW9uIGlzXHJcbiAgICAgKiBvdmVyd3JpdHRlbikuXHJcbiAgICAgKi9cclxuICAgIHBsdXJhbGl6ZT86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSB0aW1lIHVuaXQgcHJlc2VudGVkIGluIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEZvciB0aW1lY291bnQncyBkZWZhdWx0IGxhbmd1YWdlIOKAlCBFbmdsaXNoIChVUykg4oCUIHRoaXMgaXMgcGFyc2VkIGZyb20gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlXHJcbiAgICAgKiB0aW1lIHVuaXQsIHRha2luZyBhZHZhbnRhZ2Ugb2YgaXRzIFttZWRpYWwgY2FwaXRhbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsX2Nhc2UpIHRvIHNlcGFyYXRlXHJcbiAgICAgKiBjb21wb3VuZCBuYW1lcyAoYGdhbGFjdGljWWVhcmAgcGFyc2VzIGFzIFwiZ2FsYWN0aWMgeWVhclwiKS5cclxuICAgICAqXHJcbiAgICAgKiBJbiBzb21lIGNhc2VzLCBob3dldmVyLCBhIGN1c3RvbSByZWFkYWJsZSBuYW1lIGlzIHJlcXVpcmVkIGV2ZW4gaW4gRW5nbGlzaCAoVVMpIChgcGxhbmNrVGltZWAsIGZvciBleGFtcGxlLCB3b3VsZFxyXG4gICAgICogbm90IGJlIGNvcnJlY3RseSBjYXBpdGFsaXplZCBhcyBcIlBsYW5jayB0aW1lXCIpLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIElmIHlvdSB3aXNoIHRvIGhlbHAgdGltZWNvdW50IHdpdGggYSB0cmFuc2xhdGlvbiwgcGxlc2UgY29uc3VsdFxyXG4gICAgICogW0NvbnRyaWJ1dGluZzogVHJhbnNsYXRpbmddKGh0dHBzOi8vZ2l0aHViLmNvbS9wamJhdGlzdGEvdGltZWNvdW50L2Jsb2IvbWFzdGVyL0NPTlRSSUJVVElORy5tZCN0cmFuc2xhdGluZykuXHJcbiAgICAgKi9cclxuICAgIHJlYWRhYmxlTmFtZT86IHN0cmluZztcclxuXHJcbiAgICAvKiogQSBzeW1ib2wgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHVuaXQgKGUuZy4gXCJzXCIgZm9yIHNlY29uZHMpLiAqL1xyXG4gICAgc3ltYm9sPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBpbnRlcm5hbGx5IGluIG9yZGVyIHRvIG1hcCB0aGUgW3RpbWUgdW5pdCBkYXRhYmFzZV0oLi4vbW9kdWxlcy9faW5kZXhfLmh0bWwjdGltZV91bml0KSB1c2luZ1xyXG4gKiBpdHMgcHJvcGVydGllcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmFtZWRUaW1lVW5pdCBleHRlbmRzIFRpbWVVbml0IHtcclxuXHJcbiAgICAvKiogVGhpcyBuYW1lIGlzIHBhcnNlZCBmcm9tIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSB0aW1lIHVuaXQgb2JqZWN0LiAqL1xyXG4gICAgbmFtZToga2V5b2YgVGltZVVuaXREYXRhYmFzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIHJlcHJlc2VudHMgYSBuYW5vc2Vjb25kLWJhc2VkIHRpbWUgdmFsdWUuXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEuMCAtIFVubmVjZXNzYXJ5IGludGVyZmFjZSAod2lsbCBiZSByZW1vdmVkIGluIHYyKS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmFub3NlY29uZEJhc2VkVGltZSB7XHJcblxyXG4gICAgLyoqIEdldHMgdGhlIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWUgbGVuZ3RoIGluIG5hbm9zZWNvbmRzLiAqL1xyXG4gICAgcmVhZG9ubHkgbmFub3NlY29uZHM6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgdHlwZSBjb250YWlucyBhbGwgdmFsdWVzIGFjY2VwdGVkIHdoZW4gY29uZmlndXJpbmdcclxuICogW251bWVyaWMgbm90YXRpb25zXSguLi9pbnRlcmZhY2VzL19pbmRleF8udHlwZXdyaXRlcnNldHRpbmdzI251bWVyaWNub3RhdGlvbikuXHJcbiAqXHJcbiAqIC0gKipcImRlY2ltYWxcIjoqKiBzdGFuZGFyZCBfSGluZHXigJNBcmFiaWMgbnVtZXJhbCBzeXN0ZW1fIHVzaW5nIGJhc2UgdGVuO1xyXG4gKiAtICoqXCJyb21hblwiOioqIF9BbmNpZW50IFJvbWVfIG51bWVyYWwgc3lzdGVtLCBpZ25vcmluZyBmcmFjdGlvbnM7XHJcbiAqIC0gKipcInJvbWFuLWZyYWN0aW9uc1wiOioqIF9BbmNpZW50IFJvbWVfIG51bWVyYWwgc3lzdGVtLCB1c2luZ1xyXG4gKiAgIFtjb21tb24gZnJhY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb21hbl9udW1lcmFscyNGcmFjdGlvbnMpO1xyXG4gKiAtICoqXCJzY2llbnRpZmljXCI6KiogRXhwb25lbnQgbm90YXRpb247IHdyaXRlcyB2ZXJ5IHNtYWxsIGFuZCB2ZXJ5IGxhcmdlIG51bWJlcnMgdXNpbmcgcG93ZXJzIG9mIDEwLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgTnVtZXJpY05vdGF0aW9uID0gXCJkZWNpbWFsXCIgfCBcInJvbWFuXCIgfCBcInJvbWFuLWZyYWN0aW9uc1wiIHwgXCJzY2llbnRpZmljXCI7XHJcblxyXG4vKipcclxuICogVGhpcyB0eXBlIGRlZmluZXMgZnVuY3Rpb25zIHVzZWQgYnkgW3RpbWUgd3JpdGVyc10oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCkgaW4gb3JkZXIgdG8gZXhwcmVzcyBhIG51bWVyaWNcclxuICogdmFsdWUgaW4gdGhlIGZvcm0gb2YgdGV4dC5cclxuICpcclxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIG5hdGl2ZSBudW1iZXIgYW5kIHRoZSBzZWNvbmQsIG9wdGlvbmFsLCBpcyBhXHJcbiAqIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBOdW1lcmljV3JpdGVyID0gKHZhbHVlOiBudW1iZXIsIGJpZ1ZhbHVlPzogRGVjaW1hbCkgPT4gc3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZW51bWVyYXRpb24gY29udGFpbnMgYWxsIFtyb3VuZGluZyBtb2Rlc10oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI3JvdW5kaW5nbW9kZSkgYXZhaWxhYmxlLFxyXG4gKiBleHRyYWN0ZWQgZnJvbSB0aGUgW2RlY2ltYWwuanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9taWtlbWNsLmdpdGh1Yi5pby9kZWNpbWFsLmpzKS5cclxuICovXHJcbmV4cG9ydCBlbnVtIFJvdW5kaW5nTW9kZSB7XHJcblxyXG4gICAgLyoqIFJvdW5kcyBhd2F5IGZyb20gemVyby4gKi9cclxuICAgIFJvdW5kVXAgPSAwLFxyXG5cclxuICAgIC8qKiBSb3VuZHMgdG93YXJkcyB6ZXJvLiAqL1xyXG4gICAgUm91bmREb3duLFxyXG5cclxuICAgIC8qKiBSb3VuZHMgdG93YXJkcyBfSW5maW5pdHlfLiAqL1xyXG4gICAgUm91bmRDZWlsLFxyXG5cclxuICAgIC8qKiBSb3VuZHMgdG93YXJkcyBfLUluZmluaXR5Xy4gKi9cclxuICAgIFJvdW5kRmxvb3IsXHJcblxyXG4gICAgLyoqIFJvdW5kcyB0b3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyOyBpZiBlcXVpZGlzdGFudCwgcm91bmRzIGF3YXkgZnJvbSB6ZXJvLiAqL1xyXG4gICAgUm91bmRIYWxmVXAsXHJcblxyXG4gICAgLyoqIFJvdW5kcyB0b3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyOyBpZiBlcXVpZGlzdGFudCwgcm91bmRzIHRvd2FyZHMgemVyby4gKi9cclxuICAgIFJvdW5kSGFsZkRvd24sXHJcblxyXG4gICAgLyoqIFJvdW5kcyB0b3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyOyBpZiBlcXVpZGlzdGFudCwgcm91bmRzIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuICovXHJcbiAgICBSb3VuZEhhbGZFdmVuLFxyXG5cclxuICAgIC8qKiBSb3VuZHMgdG93YXJkcyBuZWFyZXN0IG5laWdoYm91cjsgaWYgZXF1aWRpc3RhbnQsIHJvdW5kcyB0b3dhcmRzIF9JbmZpbml0eV8uICovXHJcbiAgICBSb3VuZEhhbGZDZWlsLFxyXG5cclxuICAgIC8qKiBSb3VuZHMgdG93YXJkcyBuZWFyZXN0IG5laWdoYm91cjsgaWYgZXF1aWRpc3RhbnQsIHJvdW5kcyB0b3dhcmRzIF8tSW5maW5pdHlfLiAqL1xyXG4gICAgUm91bmRIYWxmRmxvb3IsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgYSBuYW5vc2Vjb25kLWJhc2VkIHRpbWUgdmFsdWUuXHJcbiAqXHJcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjYXBhYmxlIG9mIGJlaW5nIGNvbnZlcnRlZCBbZnJvbV0oI2Zyb20pIGFuZCBbdG9dKCN0bykgLyBbdG8gYmlnIGRlY2ltYWxdKCN0b0JpZykgb3RoZXJcclxuICogW3RpbWUgdW5pdHNdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ldW5pdGRhdGFiYXNlLmh0bWwpIGFuZCBhbHNvIHBlcmZvcm0gYmFzaWMgYXJpdGhtZXRpY3MuXHJcbiAqXHJcbiAqIFRpbWVzIGNhbiBhbHNvIGJlIFthcHByb3hpbWF0ZWRdKCNpc0FwcHJveGltYXRlZCksIGFuZCBvcGVyYXRpb25zIGRlcml2aW5nIGZyb20gdGhlaXIgdXNlIHdpbGwgYWxzbyBiZSBhcHByb3hpbWF0ZWQuXHJcbiAqIFRoaXMgZG9lc24ndCBhZmZlY3QgdGhlIHRpbWUgb2JqZWN0IHZhbHVlIGluIGFueSB3YXksIGJ1dCBpcyB1c2VkIGJ5IFtUaW1lV3JpdGVyXShfaW5kZXhfLnRpbWV3cml0ZXIuaHRtbCkgdG9cclxuICogZGVtb25zdHJhdGUgYXBwcm94aW1hdGlvbnMuXHJcbiAqXHJcbiAqIEFsbCBpbnN0YW5jZXMgYXJlIF9pbW11dGFibGVfLCB0aHVzIG5vdCBhZmZlY3RlZCBieSBtZXRob2RzIChuZXcgaW5zdGFuY2VzIGFyZSBhbHdheXMgY3JlYXRlZCBpbnN0ZWFkKS4gQWxzbywgYWxsXHJcbiAqIHRpbWUgdmFsdWVzIGFyZSBuZWNlc3NhcmlseSBwb3NpdGl2ZSAobmVnYXRpdmUgdGltZXMgYXJlIG5vdCBhIHRoaW5nKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUaW1lIHtcclxuXHJcbiAgICBwcml2YXRlIF9hcHByb3hpbWF0ZWQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9uYW5vc2Vjb25kczogRGVjaW1hbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWUgbGVuZ3RoLCBpblxyXG4gICAgICogbmFub3NlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYmlnVmFsdWUoKSB7IHJldHVybiB0aGlzLl9uYW5vc2Vjb25kczsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSB2YWx1ZSBvZiB0aGlzIGlzIGFuIGFwcHJveGltYXRpb24uIFRoaXMgaXMgZGV0ZXJtaW5lZCBhdCBjb25zdHJ1Y3Rpb24gYW5kIGl0IHJlbWFpbnMgaW4gYWxsXHJcbiAgICAgKiBvcGVyYXRpb25zIHdpdGggdGhhdCB0aGlzIHRpbWUgaXMgaW52b2x2ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNBcHByb3hpbWF0ZWQoKSB7IHJldHVybiB0aGlzLl9hcHByb3hpbWF0ZWQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWUgbGVuZ3RoIGluIG5hbm9zZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEuMCAtIEluIGZhdm9yIG9mIGBiaWdWYWx1ZWAgYW5kIGB2YWx1ZWAgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbmFub3NlY29uZHMoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMuX25hbm9zZWNvbmRzLnRvU3RyaW5nKCkpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aW1lIGxlbmd0aCwgaW4gbmFub3NlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdmFsdWUoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMuX25hbm9zZWNvbmRzLnRvU3RyaW5nKCkpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBjbGFzcyB1c2luZyB0aGUgZ2l2ZW4gdGltZSB2YWx1ZSBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiAgIEEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdGltZSwgYWNjZXB0ZWQgYXMgYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvclxyXG4gICAgICogICBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXy5cclxuICAgICAqIEBwYXJhbSBhcHByb3hpbWF0ZWRcclxuICAgICAqICAgV2hldGhlciB0aGUgZ2l2ZW4gaXMgYW4gYXBwcm94aW1hdGlvbiBvciBub3QuIFRoZSByZXN1bHQgb2YgYW55IGFyaXRobWV0aWMgb3BlcmF0aW9ucyBpbnZvbHZpbmcgdGhpcyB0aW1lIHdpbGxcclxuICAgICAqICAgYWxzbyBiZSBhcHByb3hpbWF0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcih2YWx1ZTogVGltZVZhbHVlU291cmNlLCBhcHByb3hpbWF0ZWQ/OiBib29sZWFuKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIGNsYXNzIHVzaW5nIHRoZSBnaXZlbiB0aW1lIHZhbHVlIHBhcmFtZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQW5vdGhlciBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIGluc3RhbmNlIHRvIGJlIHJlcGxpY2F0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcih2YWx1ZTogVGltZSk7XHJcblxyXG4gICAgLy8gQWN0dWFsIGBjb25zdHJ1Y3RvcmAgaW1wbGVtZW50YXRpb25cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcih2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgYXBwcm94aW1hdGVkOiBib29sZWFuID0gZmFsc2UpIHtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZSkge1xyXG4gICAgICAgICAgICBhcHByb3hpbWF0ZWQgPSB2YWx1ZS5fYXBwcm94aW1hdGVkO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl9uYW5vc2Vjb25kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERlY2ltYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudCAke3ZhbHVlfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEZWNpbWFsKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2FwcHJveGltYXRlZCA9IGFwcHJveGltYXRlZDtcclxuICAgICAgICB0aGlzLl9uYW5vc2Vjb25kcyA9IHZhbHVlLmFicygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSB0aW1lIHZhbHVlLCBtZWFzdXJpbmcgaXQgd2l0aCB0aGUgc3BlY2lmaWVkIHRpbWUgdW5pdCwgYW5kIGNyZWF0ZXMgYSBuZXdcclxuICAgICAqIFtUaW1lXSguLi9jbGFzc2VzL19pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB3aXRoIGFuIGVxdWl2YWxlbnQgbGVuZ3RoIG9mIHRpbWUsIGJ1dCBtZWFzdXJlZCBpbiBuYW5vc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aW1lLCBhY2NlcHRlZCBhcyBhIF9zdHJpbmdfIHRoYXQgcGFyc2VzIHRvIGEgbnVtYmVyIChlLmcuIFwiMTAwMFwiIG9yXHJcbiAgICAgKiAgIFwiMWUtMTBcIiksIGEgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSBvciBhIF9udW1iZXJfLlxyXG4gICAgICogQHBhcmFtIHRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB1c2VkIGFzIHNvdXJjZSBmb3IgdGhlIGNvbnZlcnNpb24uXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIEEgbmFub3NlY29uZC1iYXNlZCB0aW1lIG9idGFpbmVkIGZyb20gdGhlIGNvbnZlcnNpb24gb2YgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbSh2YWx1ZTogVGltZVZhbHVlU291cmNlLCB0aW1lVW5pdDogVGltZVVuaXRTb3VyY2UpOiBUaW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSB0aW1lIHZhbHVlLCBtZWFzdXJpbmcgaXQgd2l0aCB0aGUgc3BlY2lmaWVkIHRpbWUgdW5pdCwgYW5kIGNyZWF0ZXMgYSBuZXdcclxuICAgICAqIFtUaW1lXSguLi9jbGFzc2VzL19pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB3aXRoIGFuIGVxdWl2YWxlbnQgbGVuZ3RoIG9mIHRpbWUsIGJ1dCBtZWFzdXJlZCBpbiBuYW5vc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aW1lLCBhY2NlcHRlZCBhcyBhIF9zdHJpbmdfIHRoYXQgcGFyc2VzIHRvIGEgbnVtYmVyIChlLmcuIFwiMTAwMFwiIG9yXHJcbiAgICAgKiAgIFwiMWUtMTBcIiksIGEgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSBvciBhIF9udW1iZXJfLlxyXG4gICAgICogQHBhcmFtIHRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB1c2VkIGFzIHNvdXJjZSBmb3IgdGhlIGNvbnZlcnNpb24uIEFjY2VwdHMgcGx1cmFscyBhbmQgY2FzZSB2YXJpYXRpb25zLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIG5hbm9zZWNvbmQtYmFzZWQgdGltZSBvYnRhaW5lZCBmcm9tIHRoZSBjb252ZXJzaW9uIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkIC1vci0gdGhlIHRpbWUgdW5pdCBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb20odmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSwgdGltZVVuaXQ6IHN0cmluZyB8IFRpbWVVbml0KTogVGltZTtcclxuXHJcbiAgICAvLyBBY3R1YWwgYGZyb21gIGltcGxlbWVudGF0aW9uXHJcbiAgICBwdWJsaWMgc3RhdGljIGZyb20odmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSwgdGltZVVuaXQ6IFRpbWVVbml0U291cmNlIHwgc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERlY2ltYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcmd1bWVudCAke3ZhbHVlfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEZWNpbWFsKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRpbWVVbml0ID0gdGltZVVuaXRGcm9tU291cmNlKHRpbWVVbml0KTtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWUodmFsdWUudGltZXModGltZVVuaXQuZmFjdG9yKSwgdGltZVVuaXQuYXBwcm94aW1hdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHZhbHVlIG9mIHRoaXMgdGltZSB3aXRoIHRoZSB2YWx1ZSBvZiBhbm90aGVyIHRpbWUuIElmIGVpdGhlciBhcmUgW2FwcHJveGltYXRpb25zXSgjaXNBcHByb3hpbWF0ZWQpLCB0aGVcclxuICAgICAqIHJlc3VsdCB3aWxsIGFsc28gYmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiAgIEEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdGltZSwgYWNjZXB0ZWQgYXMgYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvclxyXG4gICAgICogICBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXyAtb3ItIGFub3RoZXJcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB1c2VkIHRvIGJlIGFkZGVkIHRvIHRoaXMgdGltZS5cclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgdXNlZCBhcyBzb3VyY2UgZm9yIHRoZSBjb252ZXJzaW9uIG9mIGB2YWx1ZWAuIFRoaXMgZGVmYXVsdHMgdG8gXCJuYW5vc2Vjb25kXCIgYW5kIGlzIGlnbm9yZWQgd2hlbiBhXHJcbiAgICAgKiAgIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IGlzIHByb3ZpZGVkLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IHdpdGggdGhlIHZhbHVlcyBvZiBib3RoIHRpbWVzIGFkZGVkIHRvIGVhY2ggb3RoZXIuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQodmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSB8IFRpbWUsIHRpbWVVbml0PzogVGltZVVuaXRTb3VyY2UpOiBUaW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgdmFsdWUgb2YgdGhpcyB0aW1lIHdpdGggdGhlIHZhbHVlIG9mIGFub3RoZXIgdGltZS4gSWYgZWl0aGVyIGFyZSBbYXBwcm94aW1hdGlvbnNdKCNpc0FwcHJveGltYXRlZCksIHRoZVxyXG4gICAgICogcmVzdWx0IHdpbGwgYWxzbyBiZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aW1lLCBhY2NlcHRlZCBhcyBhIF9zdHJpbmdfIHRoYXQgcGFyc2VzIHRvIGEgbnVtYmVyIChlLmcuIFwiMTAwMFwiIG9yXHJcbiAgICAgKiAgIFwiMWUtMTBcIiksIGEgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSBvciBhIF9udW1iZXJfIC1vci0gYW5vdGhlclxyXG4gICAgICogICBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIGluc3RhbmNlIHVzZWQgdG8gYmUgYWRkZWQgdG8gdGhpcyB0aW1lLlxyXG4gICAgICogQHBhcmFtIHRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB1c2VkIGFzIHNvdXJjZSBmb3IgdGhlIGNvbnZlcnNpb24gb2YgYHZhbHVlYC4gVGhpcyBkZWZhdWx0cyB0byBcIm5hbm9zZWNvbmRcIiBhbmQgaXMgaWdub3JlZCB3aGVuIGFcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgaXMgcHJvdmlkZWQuIEFjY2VwdHMgcGx1cmFscyBhbmQgY2FzZSB2YXJpYXRpb25zLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IHdpdGggdGhlIHZhbHVlcyBvZiBib3RoIHRpbWVzIGFkZGVkIHRvIGVhY2ggb3RoZXIuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQodmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSB8IFRpbWUsIHRpbWVVbml0Pzogc3RyaW5nIHwgVGltZVVuaXQpOiBUaW1lO1xyXG5cclxuICAgIC8vIEFjdHVhbCBgYWRkYCBpbXBsZW1lbnRhdGlvblxyXG4gICAgcHVibGljIGFkZCh2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgdGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSkge1xyXG5cclxuICAgICAgICBsZXQgYXBwcm94aW1hdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fbmFub3NlY29uZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGltZVVuaXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udmVydGVkID0gVGltZS5mcm9tKHZhbHVlLCB0aW1lVW5pdCk7XHJcbiAgICAgICAgICAgIGFwcHJveGltYXRlZCA9IGNvbnZlcnRlZC5fYXBwcm94aW1hdGVkO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlZC5fbmFub3NlY29uZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRpbWUodGhpcy5fbmFub3NlY29uZHMuYWRkKHZhbHVlKSwgYXBwcm94aW1hdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgdGltZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWUgb2YgdGhpcyB0aW1lLCBob3dldmVyIHdpdGggdGhlIGFwcHJveGltYXRlZCBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKiAgIEFwcHJveGltYXRlZCB0aW1lIGluIHJlbGF0aW9uIHRvIHRoaXMgdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcHJveGltYXRlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZSh0aGlzLl9uYW5vc2Vjb25kcywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXZpZGVzIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUgYnkgdGhlIHZhbHVlIG9mIGFub3RoZXIgdGltZS4gSWYgZWl0aGVyIGFyZSBbYXBwcm94aW1hdGlvbnNdKCNpc0FwcHJveGltYXRlZCksIHRoZVxyXG4gICAgICogcmVzdWx0IHdpbGwgYWxzbyBiZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aW1lLCBhY2NlcHRlZCBhcyBhIF9zdHJpbmdfIHRoYXQgcGFyc2VzIHRvIGEgbnVtYmVyIChlLmcuIFwiMTAwMFwiIG9yXHJcbiAgICAgKiAgIFwiMWUtMTBcIiksIGEgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSBvciBhIF9udW1iZXJfIC1vci0gYW5vdGhlclxyXG4gICAgICogICBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIGluc3RhbmNlIHVzZWQgdG8gZGl2aWRlIHRoaXMgdGltZS5cclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgdXNlZCBhcyBzb3VyY2UgZm9yIHRoZSBjb252ZXJzaW9uIG9mIGB2YWx1ZWAuIFRoaXMgZGVmYXVsdHMgdG8gXCJuYW5vc2Vjb25kXCIgYW5kIGlzIGlnbm9yZWQgd2hlbiBhXHJcbiAgICAgKiAgIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IGlzIHByb3ZpZGVkLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IHdpdGggdGhlIHZhbHVlIG9mIHRoaXMgdGltZSBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZiB0aGUgb3RoZXIgdGltZS5cclxuICAgICAqIEB0aHJvd3MgRXJyb3JcclxuICAgICAqICAgV2hlbiB0aGUgdmFsdWUgaXMgaW52YWxpZCAtb3ItIHRoZSB0aW1lIHVuaXQgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpdmlkZSh2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgdGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSk6IFRpbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXZpZGVzIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUgYnkgdGhlIHZhbHVlIG9mIGFub3RoZXIgdGltZS4gSWYgZWl0aGVyIGFyZSBbYXBwcm94aW1hdGlvbnNdKCNpc0FwcHJveGltYXRlZCksIHRoZVxyXG4gICAgICogcmVzdWx0IHdpbGwgYWxzbyBiZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqICAgQSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB0aW1lLCBhY2NlcHRlZCBhcyBhIF9zdHJpbmdfIHRoYXQgcGFyc2VzIHRvIGEgbnVtYmVyIChlLmcuIFwiMTAwMFwiIG9yXHJcbiAgICAgKiAgIFwiMWUtMTBcIiksIGEgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSBvciBhIF9udW1iZXJfIC1vci0gYW5vdGhlclxyXG4gICAgICogICBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIGluc3RhbmNlIHVzZWQgdG8gZGl2aWRlIHRoaXMgdGltZS5cclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgdXNlZCBhcyBzb3VyY2UgZm9yIHRoZSBjb252ZXJzaW9uIG9mIGB2YWx1ZWAuIFRoaXMgZGVmYXVsdHMgdG8gXCJuYW5vc2Vjb25kXCIgYW5kIGlzIGlnbm9yZWQgd2hlbiBhXHJcbiAgICAgKiAgIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IGlzIHByb3ZpZGVkLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhc2UgdmFyaWF0aW9ucy5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2YgdGhlIG90aGVyIHRpbWUuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXZpZGUodmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSB8IFRpbWUsIHRpbWVVbml0Pzogc3RyaW5nIHwgVGltZVVuaXQpOiBUaW1lO1xyXG5cclxuICAgIC8vIEFjdHVhbCBgZGl2aWRlYCBpbXBsZW1lbnRhdGlvblxyXG4gICAgcHVibGljIGRpdmlkZSh2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgdGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSkge1xyXG5cclxuICAgICAgICBsZXQgYXBwcm94aW1hdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fbmFub3NlY29uZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGltZVVuaXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udmVydGVkID0gVGltZS5mcm9tKHZhbHVlLCB0aW1lVW5pdCk7XHJcbiAgICAgICAgICAgIGFwcHJveGltYXRlZCA9IGNvbnZlcnRlZC5fYXBwcm94aW1hdGVkO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlZC5fbmFub3NlY29uZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRpbWUodGhpcy5fbmFub3NlY29uZHMuZGl2aWRlZEJ5KHZhbHVlKSwgYXBwcm94aW1hdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdGhlIHZhbHVlIG9mIHRoaXMgdGltZSB3aXRoIHRoZSB2YWx1ZSBvZiBhbm90aGVyIHRpbWUuIElmIGVpdGhlciBhcmVcclxuICAgICAqIFthcHByb3hpbWF0aW9uc10oI2lzQXBwcm94aW1hdGVkKSwgdGhlIHJlc3VsdCB3aWxsIGFsc28gYmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiAgIEEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdGltZSwgYWNjZXB0ZWQgYXMgYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvclxyXG4gICAgICogICBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXyAtb3ItIGFub3RoZXJcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB1c2VkIHRvIGJlIG11bHRpcGxpZWQgYnkgdGhpcyB0aW1lLlxyXG4gICAgICogQHBhcmFtIHRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB1c2VkIGFzIHNvdXJjZSBmb3IgdGhlIGNvbnZlcnNpb24gb2YgYHZhbHVlYC4gVGhpcyBkZWZhdWx0cyB0byBcIm5hbm9zZWNvbmRcIiBhbmQgaXMgaWdub3JlZCB3aGVuIGFcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgaXMgcHJvdmlkZWQuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIEEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3Qgd2l0aCB0aGUgdmFsdWUgb2YgYm90aCB0aW1lcyBtdWx0aXBsaWVkIGJ5IGVhY2ggb3RoZXIuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseSh2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgdGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSk6IFRpbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUgd2l0aCB0aGUgdmFsdWUgb2YgYW5vdGhlciB0aW1lLiBJZiBlaXRoZXIgYXJlXHJcbiAgICAgKiBbYXBwcm94aW1hdGlvbnNdKCNpc0FwcHJveGltYXRlZCksIHRoZSByZXN1bHQgd2lsbCBhbHNvIGJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogICBBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgbGVuZ3RoIG9mIHRpbWUsIGFjY2VwdGVkIGFzIGEgX3N0cmluZ18gdGhhdCBwYXJzZXMgdG8gYSBudW1iZXIgKGUuZy4gXCIxMDAwXCIgb3JcclxuICAgICAqICAgXCIxZS0xMFwiKSwgYSBbYmlnIGRlY2ltYWxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2RlY2ltYWwuanMpIG9yIGEgX251bWJlcl8gLW9yLSBhbm90aGVyXHJcbiAgICAgKiAgIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgaW5zdGFuY2UgdXNlZCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoaXMgdGltZS5cclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgdXNlZCBhcyBzb3VyY2UgZm9yIHRoZSBjb252ZXJzaW9uIG9mIGB2YWx1ZWAuIFRoaXMgZGVmYXVsdHMgdG8gXCJuYW5vc2Vjb25kXCIgYW5kIGlzIGlnbm9yZWQgd2hlbiBhXHJcbiAgICAgKiAgIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IGlzIHByb3ZpZGVkLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhc2UgdmFyaWF0aW9ucy5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiBib3RoIHRpbWVzIG11bHRpcGxpZWQgYnkgZWFjaCBvdGhlci5cclxuICAgICAqIEB0aHJvd3MgRXJyb3JcclxuICAgICAqICAgV2hlbiB0aGUgdmFsdWUgaXMgaW52YWxpZCAtb3ItIHRoZSB0aW1lIHVuaXQgaXMgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KHZhbHVlOiBUaW1lVmFsdWVTb3VyY2UgfCBUaW1lLCB0aW1lVW5pdD86IHN0cmluZyB8IFRpbWVVbml0KTogVGltZTtcclxuXHJcbiAgICAvLyBBY3R1YWwgYG11bHRpcGx5YCBpbXBsZW1lbnRhdGlvblxyXG4gICAgcHVibGljIG11bHRpcGx5KHZhbHVlOiBUaW1lVmFsdWVTb3VyY2UgfCBUaW1lLCB0aW1lVW5pdD86IFRpbWVVbml0U291cmNlKSB7XHJcblxyXG4gICAgICAgIGxldCBhcHByb3hpbWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl9uYW5vc2Vjb25kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aW1lVW5pdCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWQgPSBUaW1lLmZyb20odmFsdWUsIHRpbWVVbml0KTtcclxuICAgICAgICAgICAgYXBwcm94aW1hdGVkID0gY29udmVydGVkLl9hcHByb3hpbWF0ZWQ7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydGVkLl9uYW5vc2Vjb25kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVGltZSh0aGlzLl9uYW5vc2Vjb25kcy50aW1lcyh2YWx1ZSksIGFwcHJveGltYXRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIHZhbHVlIG9mIGFub3RoZXIgdGltZSBmcm9tIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUuIElmIGVpdGhlciBhcmUgW2FwcHJveGltYXRpb25zXSgjaXNBcHByb3hpbWF0ZWQpLFxyXG4gICAgICogdGhlIHJlc3VsdCB3aWxsIGFsc28gYmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiAgIEEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdGltZSwgYWNjZXB0ZWQgYXMgYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvclxyXG4gICAgICogICBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXyAtb3ItIGFub3RoZXJcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB1c2VkIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGlzIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gdGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHVzZWQgYXMgc291cmNlIGZvciB0aGUgY29udmVyc2lvbiBvZiBgdmFsdWVgLiBUaGlzIGRlZmF1bHRzIHRvIFwibmFub3NlY29uZFwiIGFuZCBpcyBpZ25vcmVkIHdoZW4gYVxyXG4gICAgICogICBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBpcyBwcm92aWRlZC5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2YgdGhlIG90aGVyIHRpbWUuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHZhbHVlIGlzIGludmFsaWQgLW9yLSB0aGUgdGltZSB1bml0IGlzIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdCh2YWx1ZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgdGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSk6IFRpbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIHZhbHVlIG9mIGFub3RoZXIgdGltZSBmcm9tIHRoZSB2YWx1ZSBvZiB0aGlzIHRpbWUuIElmIGVpdGhlciBhcmUgW2FwcHJveGltYXRpb25zXSgjaXNBcHByb3hpbWF0ZWQpLFxyXG4gICAgICogdGhlIHJlc3VsdCB3aWxsIGFsc28gYmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiAgIEEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdGltZSwgYWNjZXB0ZWQgYXMgYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvclxyXG4gICAgICogICBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXyAtb3ItIGFub3RoZXJcclxuICAgICAqICAgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBpbnN0YW5jZSB1c2VkIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGlzIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gdGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHVzZWQgYXMgc291cmNlIGZvciB0aGUgY29udmVyc2lvbiBvZiBgdmFsdWVgLiBUaGlzIGRlZmF1bHRzIHRvIFwibmFub3NlY29uZFwiIGFuZCBpcyBpZ25vcmVkIHdoZW4gYVxyXG4gICAgICogICBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBpcyBwcm92aWRlZC4gQWNjZXB0cyBwbHVyYWxzIGFuZCBjYXNlIHZhcmlhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIEEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3Qgd2l0aCB0aGUgdmFsdWUgb2YgdGhpcyB0aW1lIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mIHRoZSBvdGhlciB0aW1lLlxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkIC1vci0gdGhlIHRpbWUgdW5pdCBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QodmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSB8IFRpbWUsIHRpbWVVbml0Pzogc3RyaW5nIHwgVGltZVVuaXQpOiBUaW1lO1xyXG5cclxuICAgIC8vIEFjdHVhbCBgc3VidHJhY3RgIGltcGxlbWVudGF0aW9uXHJcbiAgICBwdWJsaWMgc3VidHJhY3QodmFsdWU6IFRpbWVWYWx1ZVNvdXJjZSB8IFRpbWUsIHRpbWVVbml0PzogVGltZVVuaXRTb3VyY2UpICB7XHJcblxyXG4gICAgICAgIGxldCBhcHByb3hpbWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGltZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl9uYW5vc2Vjb25kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aW1lVW5pdCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWQgPSBUaW1lLmZyb20odmFsdWUsIHRpbWVVbml0KTtcclxuICAgICAgICAgICAgYXBwcm94aW1hdGVkID0gY29udmVydGVkLl9hcHByb3hpbWF0ZWQ7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydGVkLl9uYW5vc2Vjb25kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVGltZSh0aGlzLl9uYW5vc2Vjb25kcy5taW51cyh2YWx1ZSksIGFwcHJveGltYXRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgdGhpcyBuYW5vc2Vjb25kLWJhc2VkIHRpbWUgaW50byBhbnkgb3RoZXIgdGltZSB1bml0LlxyXG4gICAgICpcclxuICAgICAqIEZvciB0aGUgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSByZXByZXNlbnRhdGlvbiwgc2VlIFt0b0JpZ10oI3RvYmlnKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHVzZWQgYXMgdGFyZ2V0IGZvciB0aGUgY29udmVyc2lvbi5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udmVydGVkIHRpbWUsIG1lYXN1cmVkIHVzaW5nIHRoZSBnaXZlbiB0aW1lIHVuaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0byh0aW1lVW5pdDogVGltZVVuaXRTb3VyY2UpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgdGhpcyBuYW5vc2Vjb25kLWJhc2VkIHRpbWUgaW50byBhbnkgb3RoZXIgdGltZSB1bml0LlxyXG4gICAgICpcclxuICAgICAqIEZvciB0aGUgW2JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSByZXByZXNlbnRhdGlvbiwgc2VlIFt0b0JpZ10oI3RvYmlnKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHVzZWQgYXMgdGFyZ2V0IGZvciB0aGUgY29udmVyc2lvbi4gQWNjZXB0cyBwbHVyYWxzIGFuZCBjYXNlIHZhcmlhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIE51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnZlcnRlZCB0aW1lLCBtZWFzdXJlZCB1c2luZyB0aGUgZ2l2ZW4gdGltZSB1bml0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG8odGltZVVuaXQ6IHN0cmluZyB8IFRpbWVVbml0KTogbnVtYmVyO1xyXG5cclxuICAgIC8vIEFjdHVhbCBgdG9gIGltcGxlbWVudGF0aW9uXHJcbiAgICBwdWJsaWMgdG8odGltZVVuaXQ6IFRpbWVVbml0U291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CaWcodGltZVVuaXQpLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgdGhpcyBuYW5vc2Vjb25kLWJhc2VkIHRpbWUgaW50byBhbnkgb3RoZXIgdGltZSB1bml0LCB1c2luZ1xyXG4gICAgICogW2JpZyBkZWNpbWFsc10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB1c2VkIGFzIHRhcmdldCBmb3IgdGhlIGNvbnZlcnNpb24uXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIFtCaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnZlcnRlZCB0aW1lLCBtZWFzdXJlZCB1c2luZ1xyXG4gICAgICogICB0aGUgICBnaXZlbiB0aW1lIHVuaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0JpZyh0aW1lVW5pdDogVGltZVVuaXRTb3VyY2UpOiBEZWNpbWFsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIHZhbHVlIG9mIHRoaXMgbmFub3NlY29uZC1iYXNlZCB0aW1lIGludG8gYW55IG90aGVyIHRpbWUgdW5pdCwgdXNpbmdcclxuICAgICAqIFtiaWcgZGVjaW1hbHNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2RlY2ltYWwuanMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgdXNlZCBhcyB0YXJnZXQgZm9yIHRoZSBjb252ZXJzaW9uLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhcmUgdmFyaWF0aW9ucy5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgW0JpZyBkZWNpbWFsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZWNpbWFsLmpzKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udmVydGVkIHRpbWUsIG1lYXN1cmVkIHVzaW5nXHJcbiAgICAgKiAgIHRoZSAgIGdpdmVuIHRpbWUgdW5pdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQmlnKHRpbWVVbml0OiBzdHJpbmcgfCBUaW1lVW5pdCk6IERlY2ltYWw7XHJcblxyXG4gICAgLy8gQWN0dWFsIGB0b0JpZ2AgaW1wbGVtZW50YXRpb25cclxuICAgIHB1YmxpYyB0b0JpZyh0aW1lVW5pdDogVGltZVVuaXRTb3VyY2UpIHtcclxuXHJcbiAgICAgICAgdGltZVVuaXQgPSB0aW1lVW5pdEZyb21Tb3VyY2UodGltZVVuaXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW5vc2Vjb25kcy5kaXZpZGVkQnkodGltZVVuaXQuZmFjdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvZiB2YWx1ZSBvZiB0aGlzIHRpbWUsIGluIG5hbm9zZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgTnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGltZSBsZW5ndGggcGx1cyB0aGUgc3ltYm9sIFwibnNcIi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9hcHByb3hpbWF0ZWQgPyBcIuKJiFwiIDogXCJcIn0ke3RoaXMuX25hbm9zZWNvbmRzLnRvU3RyaW5nKCl9IG5zYDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdGltZSB1bml0IGlzIGFueSBwYXJ0aWN1bGFyIHRpbWUgaW50ZXJ2YWwsIHVzZWQgYXMgYSBzdGFuZGFyZCB3YXkgb2YgbWVhc3VyaW5nIG9yIGV4cHJlc3NpbmcgZHVyYXRpb24uXHJcbiAqXHJcbiAqIEV4dGVuZGluZyBmcm9tIGl0cyBwcmVjdXJzb3IsIFtCYXNlVGltZVVuaXRdKF9pbmRleF8uYmFzZXRpbWV1bml0Lmh0bWwpLCBhbiBvYmplY3Qgb2YgdGhpcyB0eXBlIGNvbnRhaW5zIGJvdGggdGhlXHJcbiAqIG1hdGhlbWF0aWNhbCBhbmQgbGluZ3Vpc3RpYyBwcm9wZXJ0aWVzIG9mIHRoZSB0aW1lIHVuaXQgaXQgZGVzY3JpYmVzLlxyXG4gKlxyXG4gKiAtLS1cclxuICpcclxuICogU2VlIFtUaW1lVW5pdERhdGFiYXNlXShfaW5kZXhfLnRpbWV1bml0ZGF0YWJhc2UuaHRtbCkgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGltZSB1bml0cy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGltZVVuaXQgZXh0ZW5kcyBCYXNlVGltZVVuaXQge1xyXG5cclxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyB0aW1lIHVuaXQgaXMgYW4gYXBwcm94aW1hdGlvbi4gKi9cclxuICAgIGFwcHJveGltYXRlZD86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIE11bHRpcGxpY2F0aXZlIGZhY3RvciAoY29lZmZpY2llbnQpIG9mIHRoaXMgdGltZSB1bml0IGluIHJlbGF0aW9uIHRvIGEgbmFub3NlY29uZC4gKi9cclxuICAgIGZhY3RvcjogRGVjaW1hbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY2VudHJhbGl6ZWQgY2F0YWxvZyBvZiBbdGltZSB1bml0XShfaW5kZXhfLnRpbWV1bml0Lmh0bWwpIGRlZmluaXRpb25zLlxyXG4gKlxyXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIGNvbGxlY3Rpb24gb2Ygc3VtbWFyaWVzIGV4dHJhY3RlZCBmcm9tIHRoZSB3ZWIsIHdpdGggaW5mb3JtYXRpb24gZm9yIHRoZSB0aW1lIHVuaXRzIGF2YWlsYWJsZSBpblxyXG4gKiB0aW1lY291bnQuIEl0IHdhcyBjcmVhdGVkIHdpdGggdGhlIGludGVudCB0byBlbmNvcmFnZSBpdHMgdXNlcnMgdG8gZXhwbG9yZSBhbmQgcGxheSB3aXRoIHRpbWUgY29udmVyc2lvbnMuXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVFxyXG4gKiAgIFRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVmaW5lcyB3aGljaCBraW5kIG9mIHRpbWUgdW5pdCBpbnRlcmZhY2UgaXRzIG9iamVjdCBpcyBkZXNjcmliaW5nLiBJdCBtYXkgYmUgYVxyXG4gKiAgIFtiYXNlIHRpbWUgdW5pdF0oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCkgd2hpY2ggY29udGFpbnMgb25seSBsaW5ndWlzdGljIHByb3BlcnRpZXMgb3IgYVxyXG4gKiAgIFt0aW1lIHVuaXRdKF9pbmRleF8udGltZXVuaXQuaHRtbCkgd2l0aCBhcHByb3hpbWF0aW9uIGZsYWcgYW5kIG5hbm9zZWNvbmQgY29lZmZpY2llbnRzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUaW1lVW5pdERhdGFiYXNlPFQgZXh0ZW5kcyBCYXNlVGltZVVuaXQgPSBCYXNlVGltZVVuaXQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBNb29uJ3Mgb3JiaXQgYXBwcm94aW1hdGVzIGFuIGVsbGlwc2UgcmF0aGVyIHRoYW4gYSBjaXJjbGUuIEhvd2V2ZXIsIHRoZSBvcmllbnRhdGlvbiAoYXMgd2VsbCBhcyB0aGUgc2hhcGUpIG9mXHJcbiAgICAgKiB0aGlzIG9yYml0IGlzIG5vdCBmaXhlZC4gSW4gcGFydGljdWxhciwgdGhlIHBvc2l0aW9uIG9mIHRoZSBleHRyZW1lIHBvaW50cyAodGhlIGxpbmUgb2YgdGhlIGFwc2lkZXM6ICoqcGVyaWdlZSoqXHJcbiAgICAgKiBhbmQgKiphcG9nZWUqKiksIHJvdGF0ZXMgb25jZSAoKiphcHNpZGFsIHByZWNlc3Npb24qKikgaW4gYWJvdXQgMywyMzMgZGF5cyAoOC44NSB5ZWFycykuIEl0IHRha2VzIHRoZSBNb29uIGxvbmdlclxyXG4gICAgICogdG8gcmV0dXJuIHRvIHRoZSBzYW1lIGFwc2lzIGJlY2F1c2UgaXQgaGFzIG1vdmVkIGFoZWFkIGR1cmluZyBvbmUgcmV2b2x1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGxvbmdlciBwZXJpb2QgaXMgY2FsbGVkIHRoZSAqKmFub21hbGlzdGljIG1vbnRoKiogYW5kIGhhcyBhbiBhdmVyYWdlIGxlbmd0aCBvZlxyXG4gICAgICogXzI3IGRheXMsIDEzIGhvdXJzLCAxOCBtaW51dGVzLCAzMy4yIHNlY29uZHNfIG9yIGAyMzgwNzEzMTIwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGFub21hbGlzdGljTW9udGg6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKiphbm9tYWxpc3RpYyB5ZWFyKiogaXMgdGhlIHRpbWUgdGFrZW4gZm9yIHRoZSBFYXJ0aCB0byBjb21wbGV0ZSBvbmUgcmV2b2x1dGlvbiB3aXRoIHJlc3BlY3QgdG8gaXRzIGFwc2lkZXMuXHJcbiAgICAgKiBJdCBpcyB1c3VhbGx5IGRlZmluZWQgYXMgdGhlIHRpbWUgYmV0d2VlbiAqKnBlcmloZWxpb24qKiBwYXNzYWdlcy5cclxuICAgICAqXHJcbiAgICAgKiBJdHMgYXZlcmFnZSBkdXJhdGlvbiBpcyBfMzY1IGRheXMsIDYgaG91cnMsIDEzIG1pbnV0ZXMsIDUyLjYgc2Vjb25kc18gb3IgYDMxNTU4NDMyNTUwNDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGFub21hbGlzdGljWWVhcjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuICoqYXR0b3NlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8wLjAwMDAwMDAwMDAwMDAwMDAwMSBzZWNvbmRfIG9yIGAwLjAwMDAwMDAwMSBuYW5vc2Vjb25kYC5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udGV4dCwgYW4gYXR0b3NlY29uZCBpcyB0byBhIHNlY29uZCB3aGF0IGEgc2Vjb25kIGlzIHRvIGFib3V0IDMxLjcxIGJpbGxpb24geWVhcnMuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBhdHRvc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmJpZW5uaXVtKiogKHBsdXJhbCBfYmllbm5pYV8pIGlzIGEgcGVyaW9kIG9mIF8yIHllYXJzXyBvciBgMzE1MzYwMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgd29yZCBpcyBib3Jyb3dlZCBmcm9tIHRoZSBMYXRpbiBfYmllbm5pdW1fLCBmcm9tIF9iaS1fIChvY2N1cmluZyB0d2ljZSkgKyBfYW5udXNfICh5ZWFyKS5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGJpZW5uaXVtOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmNlbnR1cnkqKiBpcyBhIHBlcmlvZCBvZiBfMTAwIHllYXJzXyBvciBgMzE1MzYwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogQ2VudHVyaWVzIGFyZSBudW1iZXJlZCBvcmRpbmFsbHkgaW4gRW5nbGlzaCBhbmQgbWFueSBvdGhlciBsYW5ndWFnZXMuIEFjY29yZGluZyB0byB0aGUgc3RyaWN0IGNvbnN0cnVjdGlvbiBvZiB0aGVcclxuICAgICAqIEdyZWdvcmlhbiBjYWxlbmRhciwgdGhlIDHLouG1lyBjZW50dXJ5IGJlZ2FuIHdpdGggMSBBRCBhbmQgZW5kZWQgd2l0aCAxMDAgQUQsIHdpdGggdGhlIHNhbWUgcGF0dGVybiBjb250aW51aW5nXHJcbiAgICAgKiBvbndhcmQuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBjZW50dXJ5OiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGEgW2dhbGFjdGljIHllYXJdKCNnYWxhY3RpY3llYXIpLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGVxdWl2YWxlbnQsIGluIGF2ZXJhZ2UsIHRvIF8yMzcsNSBtaWxsaW9uIHllYXJzXyBvciBgNzQ4OTgwMDAwMDAwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBjb3NtaWNZZWFyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmRheSoqIGlzIGFwcHJveGltYXRlbHkgdGhlIHBlcmlvZCBvZiB0aW1lIGR1cmluZyB3aGljaCB0aGUgRWFydGggY29tcGxldGVzIG9uZSByb3RhdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlXHJcbiAgICAgKiBTdW4gKGFrYSBbc29sYXIgZGF5XSgjc29sYXJkYXkpKS4gSXQgaXMgY29tbW9ubHkgZGVzaWduYXRlZCBhcyBhIHBlcmlvZCBvZiBfMjQgaG91cnNfIG9yXHJcbiAgICAgKiBgODY0MDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZGF5OiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmRlY2FkZSoqIGlzIGEgcGVyaW9kIG9mIF8xMCB5ZWFyc18gb3IgYDMxNTM2MDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHdvcmQgaXMgZGVyaXZlZCBmcm9tIHRoZSBBbmNpZW50IEdyZWVrOiDOtM61zrrOrM+CIChkZWthcyksIHdoaWNoIG1lYW5zIGEgZ3JvdXAgb2YgdGVuLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZGVjYWRlOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmRyYWNvbmljIG1vbnRoKiogb3IgW25vZGljYWwgbW9udGhdKCNub2RpY2FsbW9udGgpIGlzIHRoZSBhdmVyYWdlIGludGVydmFsIGJldHdlZW4gdHdvIHN1Y2Nlc3NpdmUgdHJhbnNpdHMgb2ZcclxuICAgICAqIHRoZSBNb29uIHRocm91Z2ggdGhlIHNhbWUgbm9kZS4gQmVjYXVzZSBvZiB0aGUgdG9ycXVlIGV4ZXJ0ZWQgYnkgdGhlIFN1bidzIGdyYXZpdHkgb24gdGhlIGFuZ3VsYXIgbW9tZW50dW0gb2YgdGhlXHJcbiAgICAgKiBFYXJ0aOKAk01vb24gc3lzdGVtLCB0aGUgcGxhbmUgb2YgdGhlIE1vb24ncyBvcmJpdCBncmFkdWFsbHkgcm90YXRlcyB3ZXN0d2FyZCwgd2hpY2ggbWVhbnMgdGhlIG5vZGVzIGdyYWR1YWxseVxyXG4gICAgICogcm90YXRlIGFyb3VuZCBFYXJ0aC5cclxuICAgICAqXHJcbiAgICAgKiBBcyBhIHJlc3VsdCwgdGhlIHRpbWUgaXQgdGFrZXMgdGhlIE1vb24gdG8gcmV0dXJuIHRvIHRoZSBzYW1lIG5vZGUgaXMgc2hvcnRlciB0aGFuIGFcclxuICAgICAqIFtzaWRlcmVhbCBtb250aF0oI3NpZGVyZWFsbW9udGgpLCB3aXRoIGFuIGF2ZXJhZ2UgZHVyYXRpb24gb2YgXzI3IGRheXMsIDUgaG91cnMsIDUgbWludXRlcywgMzUuOCBzZWNvbmRzXyBvclxyXG4gICAgICogYDIzNTExMzU4MDgwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZHJhY29uaWNNb250aDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSAqKmRyYWNvbmljIHllYXIqKiBvciBbZWNsaXB0aWMgeWVhcl0oI2VjbGlwdGljeWVhcikgaXMgdGhlIHRpbWUgdGFrZW4gZm9yIHRoZSBTdW4gKGFzIHNlZW4gZnJvbSB0aGUgRWFydGgpIHRvXHJcbiAgICAgKiBjb21wbGV0ZSBvbmUgcmV2b2x1dGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIHNhbWUgbHVuYXIgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYXZlcmFnZSBkdXJhdGlvbiBvZiB0aGUgZWNsaXBzZSB5ZWFyIGlzIF8zNDYgZGF5cywgMTQgaG91cnMsIDUyIG1pbnV0ZXMsIDU0IHNlY29uZHNfIG9yXHJcbiAgICAgKiBgMjk5NDc5NzQ1NTYyOTAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZHJhY29uaWNZZWFyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGEgW2RyYWNvbmljIHllYXJdKCNkcmFjb25pY3llYXIpLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGVxdWl2YWxlbnQsIGluIGF2ZXJhZ2UsIHRvIF8zNDYgZGF5cywgMTQgaG91cnMsIDUyIG1pbnV0ZXMsIDU0IHNlY29uZHNfIG9yIGAyOTk0Nzk3NDU1NjI5MDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBlY2xpcHRpY1llYXI6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiAqKmV4YXNlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8xMDAwMDAwMDAwMDAwMDAwMDAwIHNlY29uZHNfIG9yXHJcbiAgICAgKiBgMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZWZpeCBfZXhhXyBtZWFucyAxMMK54oG4LlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZXhhc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gKipleGFzZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMTE1MjkyMTUwNDYwNjg0Njk3NiBzZWNvbmRzXyBvclxyXG4gICAgICogYDExNTI5MjE1MDQ2MDY4NDY5NzYwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX2V4YmlfIG1lYW5zIDLigbbigbAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBleGJpc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmZlbXRvc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzAuMDAwMDAwMDAwMDAwMDAxIHNlY29uZF8gb3IgYDAuMDAwMDAxIG5hbm9zZWNvbmRgLlxyXG4gICAgICpcclxuICAgICAqIEZvciBjb250ZXh0LCBhIGZlbXRvc2Vjb25kIGlzIHRvIGEgc2Vjb25kIGFzIGEgc2Vjb25kIGlzIHRvIGFib3V0IDMxLjcxIG1pbGxpb24geWVhcnMuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBmZW10b3NlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZm9ydG5pZ2h0IGlzIGEgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8xNCBkYXlzXyBvciBgMTIwOTYwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHdvcmQgZGVyaXZlcyBmcm9tIHRoZSBPbGQgRW5nbGlzaDogX2bEk293ZXJ0eW5lIG5paHRfLCBtZWFuaW5nIGZvdXJ0ZWVuIG5pZ2h0cy5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGZvcnRuaWdodDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSAqKmdhbGFjdGljIHllYXIqKiwgYWxzbyBrbm93biBhcyBbY29zbWljIHllYXJdKCNjb3NtaWN5ZWFyKSwgaXMgdGhlIGR1cmF0aW9uIG9mIHRpbWUgcmVxdWlyZWQgZm9yIHRoZSBTdW4gdG9cclxuICAgICAqIG9yYml0IG9uY2UgYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIE1pbGt5IFdheSBHYWxheHkuXHJcbiAgICAgKlxyXG4gICAgICogRXN0aW1hdGVzIG9mIHRoZSBsZW5ndGggb2Ygb25lIG9yYml0IHJhbmdlIGZyb20gMjI1IHRvIDI1MCBtaWxsaW9uIHRlcnJlc3RyaWFsIHllYXJzLCBhdmVyYWdpbmcgXzIzNyw1IG1pbGxpb25cclxuICAgICAqIHllYXJzXyBvciBgNzQ4OTgwMDAwMDAwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBnYWxhY3RpY1llYXI6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYSBbeWVhcl0oI3llYXIpLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGVxdWl2YWxlbnQgdG8gXzM2NSBkYXlzLCA1IGhvdXJzLCA0OSBtaW51dGVzLCAxMiBzZWNvbmRzXyBvciBgMzE1NTY5NTIwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZ3JlZ29yaWFuWWVhcjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipnaWJpc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzEwNzM3NDE4MjQgc2Vjb25kc18gb3IgYDEwNzM3NDE4MjQwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX2dpYmlfIG1lYW5zIDLCs+KBsC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGdpYmlzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqZ2lnYXNlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIDEwMDAwMDAwMDAgc2Vjb25kc18gb3IgYDEwMDAwMDAwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX2dpZ2FfIG1lYW5zIDEw4oG5LlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgZ2lnYXNlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuICoqaG91cioqIGlzIGEgdW5pdCBvZiB0aW1lIGNvbnZlbnRpb25hbGx5IHJlY2tvbmVkIGFzIDHigYQyNCBvZiBhIGRheSBhbmQgc2NpZW50aWZpY2FsbHkgcmVja29uZWQgaW5iZXR3ZWVuXHJcbiAgICAgKiAzNTk5IGFuZCAzNjAxIHNlY29uZHMsIGRlcGVuZGluZyBvbiBzcGVjaWFsIGNvbmRpdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHByYWN0aWNhbCBwdXJwb3NlcywgYW4gaG91ciBpcyBfMzYwMCBzZWNvbmRzXyBvciBgMzYwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBob3VyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKmppZmZ5KiogaXMgdGhlIGFtb3VudCBvZiB0aW1lIGxpZ2h0IHRha2VzIHRvIHRyYXZlbCBvbmUgX2Zlcm1pXyAod2hpY2ggaXMgYWJvdXQgdGhlIHNpemUgb2YgYSBudWNsZW9uKSBpbiBhXHJcbiAgICAgKiB2YWN1dW0uXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgZXF1aXZhbGVudCB0byBgMC4wMDAwMDAwMDAwMDAwMDMgbmFub3NlY29uZGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBqaWZmeTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluIGFzdHJvbm9teSwgYSAqKkp1bGlhbiB5ZWFyKiogaXMgYSB1bml0IG9mIG1lYXN1cmVtZW50IG9mIHRpbWUgZGVmaW5lZCBhcyBleGFjdGx5IF8zNjUuMjUgZGF5c18gb2ZcclxuICAgICAqIF84NjQwMCBzZWNvbmRzXyBlYWNoLCBvciBgODY0MDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBfSnVsaWFuIGNhbGVuZGFyXyB3aGljaCBoYXMgc3RhcnRlZCBvbiBkaWZmZXJlbnQgZGF5cywgYXQgZGlmZmVyZW50IHRpbWVzLCBpbiBkaWZmZXJlbnQgY291bnRyaWVzIGlzIGVxdWFsIHRvXHJcbiAgICAgKiBlaXRoZXIgMzY1IG9yIDM2NiBkYXlzLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkganVsaWFuWWVhcjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipraWJpc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzEwMjQgc2Vjb25kc18gb3IgYDEwMjQwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX2tpYmlfIG1lYW5zIDLCueKBsC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGtpYmlzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqa2lsb3NlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8xMDAwIHNlY29uZHNfIG9yIGAxMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJlZml4IF9raWxvXyBtZWFucyAxMMKzLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkga2lsb3NlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIGZvciBhIFttaWxsZW5pdW1dKCNtaWxsZW5pdW0pLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGVxdWl2YWxlbnQgdG8gXzEwMDAgeWVhcnNfIG9yIGAzMTUzNjAwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBraWxveWVhcjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipsZWFwIHllYXIqKiAoYWxzbyBrbm93biBhcyBhbiBpbnRlcmNhbGFyeSB5ZWFyIG9yIGJpc3NleHRpbGUgeWVhcikgaXMgYSBjYWxlbmRhciB5ZWFyIGNvbnRhaW5pbmcgb25lXHJcbiAgICAgKiBhZGRpdGlvbmFsIGRheSBhZGRlZCB0byBrZWVwIHRoZSBjYWxlbmRhciB5ZWFyIHN5bmNocm9uaXplZCB3aXRoIHRoZSBfYXN0cm9ub21pY2FsXyBvciBfc2Vhc29uYWwgeWVhcl8uXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBsZWFwIHllYXIgaGFzIF8zNjYgZGF5c18gb3IgYDMxNjIyNDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGxlYXBZZWFyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGEgW2RyYWNvbmljIG1vbnRoXSgjZHJhY29uaWNtb250aCkuXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgZXF1aXZhbGVudCwgaW4gYXZlcmFnZSwgdG8gXzI3IGRheXMsIDUgaG91cnMsIDUgbWludXRlcywgMzUuOCBzZWNvbmRzXyBvciBgMjM1MTEzNTgwODAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBub2RpY2FsTW9udGg6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqbm9uLWxlYXAgeWVhcioqIG9jY3VycyBldmVyeSB0aHJlZSBvdXQgb2YgZm91ciB5ZWFycywgdGhlIHJlbWFpbmluZyBvbmUgYmVpbmcgYSBbbGVhcCB5ZWFyXSgjbGVhcHllYXIpLlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggbm9uLWxlYXAgeWVhciBoYXMgXzM2NSBkYXlzXyBvciBgMzE1MzYwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbm9uTGVhcFllYXI6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqbHVzdHJ1bSoqIChwbHVyYWwgX2x1c3RyYV8pIHdhcyBhIHRlcm0gZm9yIGEgZml2ZS15ZWFyIHBlcmlvZCBpbiBBbmNpZW50IFJvbWUgYW5kIGlzIGVxdWl2YWxlbnQgdG8gYVxyXG4gICAgICogW3F1aW5xdWVubml1bV0oI3F1aW5xdWVubml1bSksIHdoaWNoIGlzIF81IHllYXJzXyBvciBgMTU3NjgwMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgX2x1c3RyYXRpb25fIHdhcyBvcmlnaW5hbGx5IGEgc2FjcmlmaWNlIGZvciBleHBpYXRpb24gYW5kIHB1cmlmaWNhdGlvbiBvZmZlcmVkIGJ5IG9uZSBvZiB0aGUgY2Vuc29ycyBpbiB0aGVcclxuICAgICAqIG5hbWUgb2YgdGhlIFJvbWFuIHBlb3BsZSBhdCB0aGUgY2xvc2Ugb2YgdGhlIHRha2luZyBvZiB0aGUgY2Vuc3VzLiBUaGUgc2FjcmlmaWNlIHdhcyBvZnRlbiBpbiB0aGUgZm9ybSBvZiBhblxyXG4gICAgICogYW5pbWFsIHNhY3JpZmljZSwga25vd24gYXMgYSBfc3VvdmV0YXVyaWxpYV8uXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBsdXN0cnVtOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKm1lYmlzZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMTA0ODU3NiBzZWNvbmRzXyBvciBgMTA0ODU3NjAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZWZpeCBfbWViaV8gbWVhbnMgMsKy4oGwLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbWViaXNlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKiptZWdhc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzEwMDAwMDAgc2Vjb25kc18gb3IgYDEwMDAwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX21lZ2FfIG1lYW5zIDEw4oG2LlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbWVnYXNlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKiptaWNyb3NlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8wLjAwMDAwMSBzZWNvbmRfIG9yIGAxMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJlZml4IF9taWNyb18gbWVhbnMgMTDigbvigbYuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBtaWNyb3NlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKiptaWxpc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzAuMDAxIHNlY29uZF8gb3IgYDEwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX21pbGlfIG1lYW5zIDEw4oG7wrMuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBtaWxpc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKm1pbGxlbm5pdW0qKiAocGx1cmFsIF9taWxsZW5uaWFfKSBpcyBhIHBlcmlvZCBlcXVhbCB0byBfMTAwMCB5ZWFyc18gb3IgYDMxNTM2MDAwMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYCxcclxuICAgICAqIGFsc28ga25vd24gYXMgW2tpbG95ZWFyXSgja2lsb3llYXIpLlxyXG4gICAgICpcclxuICAgICAqIFNvbWV0aW1lcywgaXQgaXMgdXNlZCBzcGVjaWZpY2FsbHkgZm9yIHBlcmlvZHMgb2YgYSB0aG91c2FuZCB5ZWFycyB0aGF0IGJlZ2luIGF0IHRoZSBzdGFydGluZyBwb2ludCAoaW5pdGlhbFxyXG4gICAgICogcmVmZXJlbmNlIHBvaW50KSBvZiB0aGUgY2FsZW5kYXIgaW4gY29uc2lkZXJhdGlvbiAodHlwaWNhbGx5IHRoZSB5ZWFyIFwiMVwiKSwgb3IgaW4gbGF0ZXIgeWVhcnMgdGhhdCBhcmUgd2hvbGVcclxuICAgICAqIG51bWJlciBtdWx0aXBsZXMgb2YgYSB0aG91c2FuZCB5ZWFycyBhZnRlciBpdC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IG1pbGxlbml1bTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbWludXRlIGlzIGVxdWFsIHRvIDHigYQ2MCAodGhlIGZpcnN0IHNleGFnZXNpbWFsIGZyYWN0aW9uKSBvZiBhbiBob3VyLCBfNjAgc2Vjb25kc18gb3IgYDYwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgVVRDIHRpbWUgc3RhbmRhcmQsIGEgbWludXRlIG9uIHJhcmUgb2NjYXNpb25zIGhhcyA2MSBzZWNvbmRzLCBhIGNvbnNlcXVlbmNlIG9mIF9sZWFwIHNlY29uZHNfLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbWludXRlOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKm1vbnRoKiogaXMgYW4gdW5pdCBvZiB0aW1lIHVzZWQgd2l0aCBjYWxlbmRhcnMsIHdoaWNoIGlzIGFwcHJveGltYXRlbHkgYXMgbG9uZyBhcyBhIG5hdHVyYWwgcGVyaW9kIHJlbGF0ZWQgdG9cclxuICAgICAqIHRoZSBtb3Rpb24gb2YgdGhlIE1vb24uXHJcbiAgICAgKlxyXG4gICAgICogSW4gR3JlZ29yaWFuIGNhbGVuZGFycywgYSBtb250aCBpcyBpbiBhdmVyYWdlIF8zMC40MTY2NjY2NjY2NyBkYXlzXyBvciBgMjYyODAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBtb250aDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipuYW5vc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzAuMDAwMDAwMDAxIHNlY29uZF8uIFRoaXMgaXMgdGhlICoqc3RhbmRhcmQgdW5pdCoqIG9mIHRpbWVjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJlZml4IF9uYW5vXyBtZWFucyAxMOKBu+KBuS4gVGltZSB1bml0cyBvZiB0aGlzIGdyYW51bGFyaXR5IGFyZSBjb21tb25seSBlbmNvdW50ZXJlZCBpbiB0ZWxlY29tbXVuaWNhdGlvbnMsXHJcbiAgICAgKiBwdWxzZWQgbGFzZXJzLCBhbmQgcmVsYXRlZCBhc3BlY3RzIG9mIGVsZWN0cm9uaWNzLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbmFub3NlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipub3Zlbm5pdW0qKiAocGx1cmFsIF9ub3Zlbm5pYV8pIGlzIGEgcGVyaW9kIGVxdWl2YWxlbnQgdG8gXzkgeWVhcnNfIG9yIGAyODM4MjQwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgbm92ZW5uaXVtOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gKipvY3Rlbm5pdW0qKiAocGx1cmFsIF9vY3Rlbm5pYV8pIGlzIGEgcGVyaW9kIGVxdWl2YWxlbnQgdG8gXzggeWVhcnNfIG9yIGAyNTIyODgwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgb2N0ZW5uaXVtOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnBlYmlzZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMTEyNTg5OTkwNjg0MjYyNCBzZWNvbmRzXyBvclxyXG4gICAgICogYDExMjU4OTk5MDY4NDI2MjQwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3BlYmlfIG1lYW5zIDLigbXigbAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBwZWJpc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnBldGFzZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMTAwMDAwMDAwMDAwMDAwMCBzZWNvbmRzXyBvclxyXG4gICAgICogYDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3BldGFfIG1lYW5zIDEwwrnigbUuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBwZXRhc2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnBpY29zZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMC4wMDAwMDAwMDAwMDEgc2Vjb25kXyBvciBgMC4wMDEgbmFub3NlY29uZGAuXHJcbiAgICAgKlxyXG4gICAgICogQSBwaWNvc2Vjb25kIGlzIHRvIG9uZSBzZWNvbmQgYXMgb25lIHNlY29uZCBpcyB0byBhcHByb3hpbWF0ZWx5IDMxLDY4OSB5ZWFycy5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHBpY29zZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKipQbGFuY2sgdGltZSoqIGlzIHRoZSB1bml0IG9mIHRpbWUgaW4gdGhlIHN5c3RlbSBvZiBuYXR1cmFsIHVuaXRzIGtub3duIGFzIF9QbGFuY2sgdW5pdHNfLiBBIFBsYW5jayB1bml0IGlzXHJcbiAgICAgKiB0aGUgdGltZSByZXF1aXJlZCBmb3IgbGlnaHQgdG8gdHJhdmVsIGluIGEgdmFjdXVtIGEgZGlzdGFuY2Ugb2YgMSBfUGxhbmNrIGxlbmd0aF8uXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgZXF1aXZhbGVudCB0byBfNS4zOTA1NiDDlyAxMOKBu+KBtOKBtCBzZWNvbmRfIG9yIGAwLjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA1MzkwNTYgbmFub3NlY29uZGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBwbGFuY2tUaW1lOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnF1YWRyZW5uaXVtKiogKHBsdXJhbCBfcXVhZHJlbm5pYV8pIGlzIGEgcGVyaW9kIG9mIF80IHllYXJzXyBvciBgNjMwNzIwMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgaW4gcmVmZXJlbmNlIHRvIHRoZSBmb3VyLXllYXIgcGVyaW9kIGJldHdlZW4gZWFjaCBPbHltcGljIEdhbWVzLiBJdCBpcyBhbHNvIHVzZWQgaW5cclxuICAgICAqIHJlZmVyZW5jZSB0byB0aGUgZm91ci15ZWFyIGludGVydmFsIGJldHdlZW4gW2xlYXAgeWVhcnNdKCNsZWFweWVhcikuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBxdWFkcmVubml1bTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipxdWluZGVjZW5uaXVtKiogKHBsdXJhbCBfcXVpbmRlY2VubmlhXykgaXMgYSBwZXJpb2QgZXF1aXZhbGVudCB0byBfMTUgeWVhcnNfIG9yXHJcbiAgICAgKiBgNDczMDQwMDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHF1aW5kZWNlbm5pdW06IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqcXVpbnF1ZW5uaXVtKiogKHBsdXJhbCBfcXVpbnF1ZW5uaWFfKSBpcyBhIHBlcmlvZCBlcXVpdmFsZW50IHRvIF81IHllYXJzXywgYSBbbHVzdHJ1bV0oI2x1c3RydW0pLCBvclxyXG4gICAgICogYDE1NzY4MDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBxdWlucXVlbm5pdW06IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKipzZWNvbmQqKiBpcyB0aGUgU0kgYmFzZSB1bml0IG9mIHRpbWUsIGNvbW1vbmx5IHVuZGVyc3Rvb2QgYW5kIGhpc3RvcmljYWxseSBkZWZpbmVkIGFzIMK5L+KCiOKChuKChOKCgOKCgCBvZiBhIGRheSDigJNcclxuICAgICAqIHRoaXMgZmFjdG9yIGRlcml2ZWQgZnJvbSB0aGUgZGl2aXNpb24gb2YgdGhlIGRheSBmaXJzdCBpbnRvIDI0IGhvdXJzLCB0aGVuIHRvIDYwIG1pbnV0ZXMgYW5kIGZpbmFsbHkgdG8gNjBcclxuICAgICAqIHNlY29uZHMgZWFjaC5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBlcXVpdmFsZW50IHRvIGAxMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHNlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKipzZXB0ZW5uaXVtKiogKHBsdXJhbCBfc2VwdGVubmlhXykgaXMgYSBwZXJpb2QgZXF1aXZhbGVudCB0byBfNyB5ZWFyc18gb3IgYDIyMDc1MjAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBzZXB0ZW5uaXVtOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnNoYWtlKiogaXMgYW4gaW5mb3JtYWwgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIGAxMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogSXQgaGFzIGFwcGxpY2F0aW9ucyBpbiBfbnVjbGVhciBwaHlzaWNzXywgaGVscGluZyB0byBjb252ZW5pZW50bHkgZXhwcmVzcyB0aGUgdGltaW5nIG9mIHZhcmlvdXMgZXZlbnRzIGluIGFcclxuICAgICAqIG51Y2xlYXIgZXhwbG9zaW9uLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgc2hha2U6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBfU2lkZXJlYWwgdGltZV8gaXMgYSB0aW1la2VlcGluZyBzeXN0ZW0gdGhhdCBhc3Ryb25vbWVycyB1c2UgdG8gbG9jYXRlIGNlbGVzdGlhbCBvYmplY3RzLiBJdCBpcyB0aGUgYW5nbGUsXHJcbiAgICAgKiBtZWFzdXJlZCBhbG9uZyB0aGUgY2VsZXN0aWFsIGVxdWF0b3IsIGZyb20gdGhlIG9ic2VydmVyJ3MgbWVyaWRpYW4gdG8gdGhlIGdyZWF0IGNpcmNsZSB0aGF0IHBhc3NlcyB0aHJvdWdoIHRoZVxyXG4gICAgICogTWFyY2ggZXF1aW5veCBhbmQgYm90aCBjZWxlc3RpYWwgcG9sZXMsIGFuZCBpcyB1c3VhbGx5IGV4cHJlc3NlZCBpbiBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogVXNpbmcgc2lkZXJlYWwgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gZWFzaWx5IHBvaW50IGEgdGVsZXNjb3BlIHRvIHRoZSBwcm9wZXIgY29vcmRpbmF0ZXMgaW4gdGhlIG5pZ2h0IHNreS5cclxuICAgICAqXHJcbiAgICAgKiBBICoqc2lkZXJlYWwgZGF5KiogaXMgYXBwcm94aW1hdGVseSBfMjMgaG91cnMsIDU2IG1pbnV0ZXMsIDQuMDkwNSBzZWNvbmRzXyBvciBgODYxNjQwOTAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgc2lkZXJlYWxEYXk6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBfU2lkZXJlYWwgdGltZV8gaXMgYSB0aW1la2VlcGluZyBzeXN0ZW0gdGhhdCBhc3Ryb25vbWVycyB1c2UgdG8gbG9jYXRlIGNlbGVzdGlhbCBvYmplY3RzLiBJdCBpcyB0aGUgYW5nbGUsXHJcbiAgICAgKiBtZWFzdXJlZCBhbG9uZyB0aGUgY2VsZXN0aWFsIGVxdWF0b3IsIGZyb20gdGhlIG9ic2VydmVyJ3MgbWVyaWRpYW4gdG8gdGhlIGdyZWF0IGNpcmNsZSB0aGF0IHBhc3NlcyB0aHJvdWdoIHRoZVxyXG4gICAgICogTWFyY2ggZXF1aW5veCBhbmQgYm90aCBjZWxlc3RpYWwgcG9sZXMsIGFuZCBpcyB1c3VhbGx5IGV4cHJlc3NlZCBpbiBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogVXNpbmcgc2lkZXJlYWwgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gZWFzaWx5IHBvaW50IGEgdGVsZXNjb3BlIHRvIHRoZSBwcm9wZXIgY29vcmRpbmF0ZXMgaW4gdGhlIG5pZ2h0IHNreS5cclxuICAgICAqXHJcbiAgICAgKiBBICoqc2lkZXJlYWwgaG91cioqIGlzIGFwcHJveGltYXRlbHkgXzU5IG1pbnV0ZXMsIDUwLjE3MDQxNjY2NjcyIHNlY29uZHNfIG9yIGAzNTkwMTcwNDE2NjY3IG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHNpZGVyZWFsSG91cjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIF9TaWRlcmVhbCB0aW1lXyBpcyBhIHRpbWVrZWVwaW5nIHN5c3RlbSB0aGF0IGFzdHJvbm9tZXJzIHVzZSB0byBsb2NhdGUgY2VsZXN0aWFsIG9iamVjdHMuIEl0IGlzIHRoZSBhbmdsZSxcclxuICAgICAqIG1lYXN1cmVkIGFsb25nIHRoZSBjZWxlc3RpYWwgZXF1YXRvciwgZnJvbSB0aGUgb2JzZXJ2ZXIncyBtZXJpZGlhbiB0byB0aGUgZ3JlYXQgY2lyY2xlIHRoYXQgcGFzc2VzIHRocm91Z2ggdGhlXHJcbiAgICAgKiBNYXJjaCBlcXVpbm94IGFuZCBib3RoIGNlbGVzdGlhbCBwb2xlcywgYW5kIGlzIHVzdWFsbHkgZXhwcmVzc2VkIGluIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBVc2luZyBzaWRlcmVhbCB0aW1lLCBpdCBpcyBwb3NzaWJsZSB0byBlYXNpbHkgcG9pbnQgYSB0ZWxlc2NvcGUgdG8gdGhlIHByb3BlciBjb29yZGluYXRlcyBpbiB0aGUgbmlnaHQgc2t5LlxyXG4gICAgICpcclxuICAgICAqIEEgKipzaWRlcmVhbCBtaW51dGUqKiBpcyBhcHByb3hpbWF0ZWx5IF81OS45ODM2MTczNjExMTEgc2Vjb25kc18gb3IgYDU5OTgzNjE3MzYxMS4xMSBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBzaWRlcmVhbE1pbnV0ZTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwZXJpb2Qgb2YgdGhlIE1vb24ncyBvcmJpdCBhcyBkZWZpbmVkIHdpdGggcmVzcGVjdCB0byB0aGUgY2VsZXN0aWFsIHNwaGVyZSBvZiBhcHBhcmVudGx5IGZpeGVkIHN0YXJzXHJcbiAgICAgKiAobm93YWRheXMgdGhlIF9JbnRlcm5hdGlvbmFsIENlbGVzdGlhbCBSZWZlcmVuY2UgRnJhbWVfKSBpcyBrbm93biBhcyBhICoqc2lkZXJlYWwgbW9udGgqKiBiZWNhdXNlIGl0IGlzIHRoZSB0aW1lXHJcbiAgICAgKiBpdCB0YWtlcyB0aGUgTW9vbiB0byByZXR1cm4gdG8gYSBzaW1pbGFyIHBvc2l0aW9uIGFtb25nIHRoZSBzdGFycy5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBhcHByb3hpbWF0ZWx5IF8yNyBkYXlzLCA3IGhvdXJzLCA0MyBtaW51dGVzLCAxMS42IHNlY29uZHNfIG9yIGAyMzYwNTkxNDI0MDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHNpZGVyZWFsTW9udGg6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBfU2lkZXJlYWwgdGltZV8gaXMgYSB0aW1la2VlcGluZyBzeXN0ZW0gdGhhdCBhc3Ryb25vbWVycyB1c2UgdG8gbG9jYXRlIGNlbGVzdGlhbCBvYmplY3RzLiBJdCBpcyB0aGUgYW5nbGUsXHJcbiAgICAgKiBtZWFzdXJlZCBhbG9uZyB0aGUgY2VsZXN0aWFsIGVxdWF0b3IsIGZyb20gdGhlIG9ic2VydmVyJ3MgbWVyaWRpYW4gdG8gdGhlIGdyZWF0IGNpcmNsZSB0aGF0IHBhc3NlcyB0aHJvdWdoIHRoZVxyXG4gICAgICogTWFyY2ggZXF1aW5veCBhbmQgYm90aCBjZWxlc3RpYWwgcG9sZXMsIGFuZCBpcyB1c3VhbGx5IGV4cHJlc3NlZCBpbiBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogVXNpbmcgc2lkZXJlYWwgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gZWFzaWx5IHBvaW50IGEgdGVsZXNjb3BlIHRvIHRoZSBwcm9wZXIgY29vcmRpbmF0ZXMgaW4gdGhlIG5pZ2h0IHNreS5cclxuICAgICAqXHJcbiAgICAgKiBBICoqc2lkZXJlYWwgc2Vjb25kKiogaXMgYXBwcm94aW1hdGVseSBfMC45OTcyNjk1NjAxODUyIHNlY29uZF8gb3IgYDk5NzI2OTU2MC4xODUyIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHNpZGVyZWFsU2Vjb25kOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnNpZGVyZWFsIHllYXIqKiBpcyB0aGUgdGltZSB0YWtlbiBieSB0aGUgRWFydGggdG8gb3JiaXQgdGhlIFN1biBvbmNlIHdpdGggcmVzcGVjdCB0byB0aGUgZml4ZWQgc3RhcnMuIEhlbmNlXHJcbiAgICAgKiBpdCBpcyBhbHNvIHRoZSB0aW1lIHRha2VuIGZvciB0aGUgU3VuIHRvIHJldHVybiB0byB0aGUgc2FtZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIGZpeGVkIHN0YXJzIGFmdGVyXHJcbiAgICAgKiBhcHBhcmVudGx5IHRyYXZlbGxpbmcgb25jZSBhcm91bmQgdGhlIGVjbGlwdGljLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGFwcHJveGltYXRlbHkgXzM2NSBkYXlzLCA2IGhvdXJzLCA5IG1pbnV0ZXMsIDkuNTA0IHNlY29uZHNfIG9yIGAzMTU1ODE0OTU0MDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBzaWRlcmVhbFllYXI6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYSBbZGF5XSgjZGF5KS5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBlcXVpdmFsZW50LCBpbiBhdmVyYWdlLCB0byBfODY0MDAgc2Vjb25kc18gb3IgYDg2NDAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHNvbGFyRGF5OiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGEgW3Ryb3BpY2FsIHllYXJdKCN0cm9waWNhbHllYXIpLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIGVxdWl2YWxlbnQsIGluIGF2ZXJhZ2UsIHRvIF8zMTU1NjkzMCBzZWNvbmRzXyBvciBgMzE1NTY5MzAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgc29sYXJZZWFyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlICoqU3ZlZGJlcmcqKiBpcyBhIHRpbWUgdW5pdCB1c2VkIGZvciBzZWRpbWVudGF0aW9uIHJhdGVzICh1c3VhbGx5IG9mIHByb3RlaW5zKS5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBkZWZpbmVkIGFzIF8xMDAgZmVtdG9zZWNvbmRzXyBvciBgMC4wMDAxIG5hbm9zZWNvbmRgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgc3ZlZGJlcmc6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKipzeW5vZGljIG1vbnRoKiogaXMgdGhlIGF2ZXJhZ2UgcGVyaW9kIG9mIHRoZSBNb29uJ3Mgb3JiaXQgd2l0aCByZXNwZWN0IHRvIHRoZSBsaW5lIGpvaW5pbmcgdGhlIFN1biBhbmRcclxuICAgICAqIEVhcnRoLiBJdCBpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBlY2xpcHNlIGN5Y2xlcy5cclxuICAgICAqXHJcbiAgICAgKiBJdHMgbG9uZy10ZXJtIGF2ZXJhZ2UgZHVyYXRpb24gaXMgXzI5IGRheXMsIDEyIGhvdXJzLCA0NCBtaW51dGVzLCAyLjgwMTYgc2Vjb25kc18gb3JcclxuICAgICAqIGAyNTUxNDQzODQwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHN5bm9kaWNNb250aDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKip0ZWJpc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gMTA5OTUxMTYyNzc3NiBzZWNvbmRzXyBvciBgMTA5OTUxMTYyNzc3NjAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZWZpeCBfdGViaV8gbWVhbnMgMuKBtOKBsC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHRlYmlzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqdGVyYXNlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIDEwMDAwMDAwMDAwMDAgc2Vjb25kc18gb3IgYDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3RlcmFfIG1lYW5zIDEwwrnCsi5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHRlcmFzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqdGltZSB1bml0KiogKFRVKSBpcyBhbiB1bml0IG9mIHRpbWUgZGVmaW5lZCBhcyBfMTAyNCBtaWNyb3NlY29uZHNfIG9yIGAxMDI0MDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgdW5pdCBhbGxvd3MgZm9yIG1haW50YWluaW5nIGludGVydmFscyB0aGF0IGFyZSBlYXN5IHRvIGltcGxlbWVudCBpbiBoYXJkd2FyZSB0aGF0IGhhcyBhIDEgTUh6IGNsb2NrLiBPbmUgVGltZVxyXG4gICAgICogVW5pdCBpcyBlcXVhbCB0byBvbmUgbWlsbGlvbnRoIG9mIGEgW2tpYmlzZWNvbmRdKCNraWJpc2Vjb25kKS5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHRpbWVVbml0OiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKnRyb3BpY2FsIHllYXIqKiAoYWxzbyBrbm93biBhcyBhIFtzb2xhciB5ZWFyXSgjc29sYXJ5ZWFyKSkgaXMgdGhlIHRpbWUgdGhhdCB0aGUgU3VuIHRha2VzIHRvIHJldHVybiB0byB0aGVcclxuICAgICAqIHNhbWUgcG9zaXRpb24gaW4gdGhlIGN5Y2xlIG9mIHNlYXNvbnMsIGFzIHNlZW4gZnJvbSBFYXJ0aDsgZm9yIGV4YW1wbGUsIHRoZSB0aW1lIGZyb20gdmVybmFsIGVxdWlub3ggdG8gdmVybmFsXHJcbiAgICAgKiBlcXVpbm94LCBvciBmcm9tIHN1bW1lciBzb2xzdGljZSB0byBzdW1tZXIgc29sc3RpY2UuXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgYXBwcm94aW1ldGFseSBfMzY1IGRheXMsIDUgaG91cnMsIDQ4IG1pbnV0ZXMsIDQzLjQ4OCBzZWNvbmRzXyBvciBgMzE1NTY5MzAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgdHJvcGljYWxZZWFyOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAqKndlZWsqKiBpcyBhIHRpbWUgdW5pdCBlcXVhbCB0byBfNyBkYXlzXyBvciBgNjA0ODAwMDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyB0aGUgc3RhbmRhcmQgdGltZSBwZXJpb2QgdXNlZCBmb3IgY3ljbGVzIG9mIHJlc3QgZGF5cyBpbiBtb3N0IHBhcnRzIG9mIHRoZSB3b3JsZCwgbW9zdGx5IGFsb25nc2lkZSDigJRcclxuICAgICAqIGFsdGhvdWdoIG5vdCBzdHJpY3RseSBwYXJ0IG9mIOKAlCB0aGUgR3JlZ29yaWFuIGNhbGVuZGFyLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgd2VlazogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciB0aGUgR3JlZ29yaWFuIGNhbGVuZGFyLCB0aGUgYXZlcmFnZSBsZW5ndGggb2YgdGhlIGNhbGVuZGFyIHllYXIgKHRoZSBtZWFuIHllYXIpIGFjcm9zcyB0aGUgY29tcGxldGUgbGVhcFxyXG4gICAgICogY3ljbGUgb2YgNDAwIHllYXJzIGlzIF8zNjUgZGF5cywgNSBob3VycywgNDkgbWludXRlcywgMTIgc2Vjb25kc18gKDM2NS4yNDI1IGRheXMpIG9yXHJcbiAgICAgKiBgMzE1NTY5NTIwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgeWVhcjogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKip5b2Jpc2Vjb25kKiogaXMgYSBTSSB1bml0IG9mIHRpbWUgZXF1YWwgdG8gXzEyMDg5MjU4MTk2MTQ2MjkxNzQ3MDYxNzYgc2Vjb25kc18gb3JcclxuICAgICAqIGAxMjA4OTI1ODE5NjE0NjI5MTc0NzA2MTc2MDAwMDAwMDAwIG5hbm9zZWNvbmRzYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJlZml4IF95b2JpXyBtZWFucyAy4oG44oGwLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgeW9iaXNlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKip5b2N0b3NlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8wLjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSBzZWNvbmRfIG9yXHJcbiAgICAgKiBgMC4wMDAwMDAwMDAwMDAwMDAxIG5hbm9zZWNvbmRgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3lvY3RvXyBtZWFucyAxMOKBu8Ky4oG0LlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgeW9jdG9zZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqeW90dGFzZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBzZWNvbmRzXyBvclxyXG4gICAgICogYDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgbmFub3NlY29uZHNgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3lvdHRhXyBtZWFucyAxMMKy4oG0LlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtCYWNrIHRvIHRvcF0oIylcclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgeW90dGFzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqemViaXNlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8xMTgwNTkxNjIwNzE3NDExMzAzNDI0IHNlY29uZHNfIG9yXHJcbiAgICAgKiBgMTE4MDU5MTYyMDcxNzQxMTMwMzQyNDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZWZpeCBfemViaV8gbWVhbnMgMuKBt+KBsC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHplYmlzZWNvbmQ6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBICoqemVwdG9zZWNvbmQqKiBpcyBhIFNJIHVuaXQgb2YgdGltZSBlcXVhbCB0byBfMC4wMDAwMDAwMDAwMDAwMDAwMDAwMDEgc2Vjb25kXyBvclxyXG4gICAgICogYDAuMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxIG5hbm9zZWNvbmRgLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcmVmaXggX3plcHRvXyBtZWFucyAxMOKBu8KywrkuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW0JhY2sgdG8gdG9wXSgjKVxyXG4gICAgICovXHJcbiAgICByZWFkb25seSB6ZXB0b3NlY29uZDogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgKip6ZXB0b3NlY29uZCoqIGlzIGEgU0kgdW5pdCBvZiB0aW1lIGVxdWFsIHRvIF8xMDAwMDAwMDAwMDAwMDAwMDAwMDAwIHNlY29uZHNfIG9yXHJcbiAgICAgKiBgMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCBuYW5vc2Vjb25kc2AuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZWZpeCBfemV0dGFfIG1lYW5zIDEwwrLCuS5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbQmFjayB0byB0b3BdKCMpXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHpldHRhc2Vjb25kOiBUO1xyXG59XHJcblxyXG4vKipcclxuICogQSB1bmlvbiB0eXBlLCB1c2VkIGJ5IHBhcmFtZXRlcnMgdGhhdCBhY2NlcHQgZWl0aGVyIHRoZSBuYW1lIG9mIGEgdGltZSB1bml0IG9yIGFcclxuICogW3RpbWUgdW5pdCBvYmplY3RdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ldW5pdC5odG1sKS5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gSW4gZmF2b3Igb2YgYFRpbWVVbml0U291cmNlYCAod2lsbCBiZSByZW1vdmVkIGluIHYyKS5cclxuICovXHJcbmV4cG9ydCB0eXBlIFRpbWVVbml0UGFyYW1ldGVyID0ga2V5b2YgVGltZVVuaXREYXRhYmFzZSB8IFRpbWVVbml0O1xyXG5cclxuLyoqXHJcbiAqIEEgdW5pb24gdHlwZSwgdXNlZCBieSBwYXJhbWV0ZXJzIHRoYXQgYWNjZXB0IGVpdGhlciB0aGUgbmFtZSBvZiBhIHRpbWUgdW5pdCBvciBhXHJcbiAqIFt0aW1lIHVuaXQgb2JqZWN0XSguLi9pbnRlcmZhY2VzL19pbmRleF8udGltZXVuaXQuaHRtbCkuXHJcbiAqXHJcbiAqIFRoZSBhY2NlcHRlZCBuYW1lcyBhcmUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBieSBbVGltZVVuaXREYXRhYmFzZV0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV1bml0ZGF0YWJhc2UuaHRtbCksIGJ1dFxyXG4gKiBjYXNlLWluc2Vuc2l0aXZlIGFuZCBwbHVyYWwgdmFyaWF0aW9ucyBhcmUgYWxzbyB2YWxpZCAoZXZlbiB0aG91Z2ggVHlwZVNjcmlwdCB3b3VsZCBub3QgYWxsb3cgaXQpLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGltZVVuaXRTb3VyY2UgPSBrZXlvZiBUaW1lVW5pdERhdGFiYXNlIHwgVGltZVVuaXQ7XHJcblxyXG4vKipcclxuICogVGhpcyB0eXBlIGlzIGEgdW5pb24gb2YgYWxsIGFjY2VwdGVkIHR5cGVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGEgdGltZSB2YWx1ZTogYSBfc3RyaW5nXyB0aGF0IHBhcnNlcyB0byBhXHJcbiAqIG51bWJlciAoZS5nLiBcIjEwMDBcIiBvciBcIjFlLTEwXCIpLCBhIFtiaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgb3IgYSBfbnVtYmVyXy5cclxuICovXHJcbmV4cG9ydCB0eXBlIFRpbWVWYWx1ZVNvdXJjZSA9IHN0cmluZyB8IG51bWJlciB8IERlY2ltYWw7XHJcblxyXG4vKipcclxuICogVGltZSB3cml0ZXJzIGFyZSBvYmplY3RzIHVzZWQgdG8gc3ludGhlc2l6ZSB0aW1lIHZhbHVlcyBpbnRvIHN0cmluZ3MsIGkuZS4gd3JpdGUgdGltZXMgdXNpbmcgZGlmZmVyZW50IGxleGljYWwgYW5kXHJcbiAqIG51bWVyaWNhbCBjb25maWd1cmF0aW9ucy4gKipbV3JpdGVdKCN3cml0ZSkqKiBpcyB1c2VkIHRvIGV4cHJlc3MgYSBzaW5nbGUgdGltZSB2YWx1ZSwgdXNpbmcgYSBzaW5nbGUgdGltZSB1bml0O1xyXG4gKiAqKltjb3VudGRvd25dKCNjb3VudGRvd24pKiogaXMgdXNlZCB0byBjbGFzc2lmeSB0aW1lIHZhbHVlcyBieSBzZWdtZW50aW5nIHRoZW0gaW50byBwYXJ0cyB3aXRoIGRpZmZlcmVudCB0aW1lIHVuaXRzLlxyXG4gKlxyXG4gKiBUaGVzZSBjb25maWd1cmF0aW9ucyBhcmUgbG9hZGVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XHJcbiAqIC0gRGVmYXVsdHMg4oCUIGhhcmRjb2RlZCBmb3IgRW5nbGlzaCAoVVMpO1xyXG4gKiAtIE9wdGlvbnMgZnJvbSB0aGUgY3VycmVudCBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCk7XHJcbiAqIC0gT3B0aW9ucyBmcm9tIHRoZSBpbnN0YW5jZSBbc2V0dGluZ3NdKCNzZXR0aW5ncyk7XHJcbiAqIC0gT3B0aW9ucyBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byBhIG1ldGhvZC5cclxuICpcclxuICogLS0tXHJcbiAqXHJcbiAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyLm1kXV1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUaW1lV3JpdGVyIHtcclxuXHJcbiAgICBwcml2YXRlIF9zaG91bGRBcHByb3hpbWF0ZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgW1RpbWVXcml0ZXJdKCMpIGNsYXNzIG9wdGlvbmFsbHkgdXNpbmcgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1xyXG4gICAgICogICBDb25maWd1cmF0aW9ucyBwZXJ0YWluaW5nIHRvIHRoaXMgaW5zdGFuY2UsIG92ZXJyaWRpbmcgdGhvc2Ugb2YgdGhlXHJcbiAgICAgKiAgIFtsb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sI3dyaXRlck9wdGlvbnMpLiBNYXkgYmUgb3ZlcnJpZGVuIHZpYSBwYXJhbWV0ZXIgb2YgW3dyaXRlXSgjd3JpdGUpIG9yXHJcbiAgICAgKiAgIFtjb3VudGRvd25dKCNjb3VudGRvd24pLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHNldHRpbmdzOiBUaW1lV3JpdGVyU2V0dGluZ3MgPSB7fSkgeyB9XHJcblxyXG4gICAgLy8jcmVnaW9uIENvdW50ZG93biBNZXRob2RcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgbGVuZ3RoIHNlZ21lbnRlZCBpbnRvIG11bHRpcGxlIHVuaXRzIHVzaW5nIGEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgYW5kLCBvcHRpb25hbGx5LFxyXG4gICAgICogY29uZmlndXJhdGlvbnMgdGhhdCBtYXkgb3ZlcnJpZGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlIGluc3RhbmNlLCBmb3IgdGhlXHJcbiAgICAgKiBkdXJhdGlvbiBvZiB0aGUgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgd2lsbCBwcm9kdWNlIGV4cGxhbmF0aW9ucyBvZiB0aW1lIGxlbmd0aHMgbXVjaCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB0aGFuIGFyYml0cmFyeSBmcmFjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBcIm92ZXJsb2FkXCIgd2lsbCBhbHdheXMgdXNlIFtUSU1FX1NFR01FTlRTX0NPTU1PTl0oLi4vbW9kdWxlcy9faW5kZXhfLmh0bWwjdGltZV9zZWdtZW50c19jb21tb24pIGFzIHNvdXJjZVxyXG4gICAgICogZm9yIGl0cyB0aW1lIHVuaXQgY29udmVyc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVcclxuICAgICAqICAgQW4gZW5jYXBzdWxhdGVkIG5hbm9zZWNvbmQtYmFzZWQgdGltZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYGNvdW50ZG93bmAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZSB0aHJvdWdoIHRoZSB1c2Ugb2YgbXVsdGlwbGUgdW5pdHMgb2YgdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvdW50ZG93bih0aW1lOiBUaW1lLCBvcHRpb25zPzogVGltZVdyaXRlclNldHRpbmdzKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdGltZSBsZW5ndGggc2VnbWVudGVkIGludG8gbXVsdGlwbGUgdW5pdHMgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksXHJcbiAgICAgKiBjb25maWd1cmF0aW9ucyB0aGF0IG1heSBvdmVycmlkZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGVcclxuICAgICAqIGR1cmF0aW9uIG9mIHRoZSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIHByb2R1Y2UgZXhwbGFuYXRpb25zIG9mIHRpbWUgbGVuZ3RocyBtdWNoIGVhc2llciB0byB1bmRlcnN0YW5kIHRoYW4gYXJiaXRyYXJ5IGZyYWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVxyXG4gICAgICogICBBbiBlbmNhcHN1bGF0ZWQgbmFub3NlY29uZC1iYXNlZCB0aW1lLlxyXG4gICAgICogQHBhcmFtIGFyZ3NcclxuICAgICAqICAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIHRpbWUgdW5pdHMgb3IgYXJyYXkgb2YgdGltZSB1bml0cyAoaWYgcmVwZXRpdGlvbnMgYXJlIGdpdmVuLCB0aGV5IHdpbGwgYmUgc2luZ2xlZCBvdXQpLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lIHRocm91Z2ggdGhlIHVzZSBvZiBtdWx0aXBsZSB1bml0cyBvZiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY291bnRkb3duKHRpbWU6IFRpbWUsIC4uLiBhcmdzOiBBcnJheTxUaW1lVW5pdFNvdXJjZSB8IFRpbWVVbml0U291cmNlW10+KTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdGltZSBsZW5ndGggc2VnbWVudGVkIGludG8gbXVsdGlwbGUgdW5pdHMgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksXHJcbiAgICAgKiBjb25maWd1cmF0aW9ucyB0aGF0IG1heSBvdmVycmlkZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGVcclxuICAgICAqIGR1cmF0aW9uIG9mIHRoZSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIHByb2R1Y2UgZXhwbGFuYXRpb25zIG9mIHRpbWUgbGVuZ3RocyBtdWNoIGVhc2llciB0byB1bmRlcnN0YW5kIHRoYW4gYXJiaXRyYXJ5IGZyYWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVxyXG4gICAgICogICBBbiBlbmNhcHN1bGF0ZWQgbmFub3NlY29uZC1iYXNlZCB0aW1lLlxyXG4gICAgICogQHBhcmFtIGFyZ3NcclxuICAgICAqICAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIHRpbWUgdW5pdHMgb3IgYXJyYXkgb2YgdGltZSB1bml0cyAoaWYgcmVwZXRpdGlvbnMgYXJlIGdpdmVuLCB0aGV5IHdpbGwgYmUgc2luZ2xlZCBvdXQpLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lIHRocm91Z2ggdGhlIHVzZSBvZiBtdWx0aXBsZSB1bml0cyBvZiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY291bnRkb3duKHRpbWU6IFRpbWUsIC4uLiBhcmdzOiBBcnJheTxzdHJpbmcgfCBUaW1lVW5pdCB8IHN0cmluZ1tdPik6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgbGVuZ3RoIHNlZ21lbnRlZCBpbnRvIG11bHRpcGxlIHVuaXRzIHVzaW5nIGEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgYW5kLCBvcHRpb25hbGx5LFxyXG4gICAgICogY29uZmlndXJhdGlvbnMgdGhhdCBtYXkgb3ZlcnJpZGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlIGluc3RhbmNlLCBmb3IgdGhlXHJcbiAgICAgKiBkdXJhdGlvbiBvZiB0aGUgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgd2lsbCBwcm9kdWNlIGV4cGxhbmF0aW9ucyBvZiB0aW1lIGxlbmd0aHMgbXVjaCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB0aGFuIGFyYml0cmFyeSBmcmFjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVcclxuICAgICAqICAgQW4gZW5jYXBzdWxhdGVkIG5hbm9zZWNvbmQtYmFzZWQgdGltZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYGNvdW50ZG93bmAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEBwYXJhbSBhcmdzXHJcbiAgICAgKiAgIEFjY2VwdHMgYW55IG51bWJlciBvZiB0aW1lIHVuaXRzIG9yIGFycmF5IG9mIHRpbWUgdW5pdHMgKGlmIHJlcGV0aXRpb25zIGFyZSBnaXZlbiwgdGhleSB3aWxsIGJlIHNpbmdsZWQgb3V0KS5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZSB0aHJvdWdoIHRoZSB1c2Ugb2YgbXVsdGlwbGUgdW5pdHMgb2YgdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvdW50ZG93bih0aW1lOiBUaW1lLCBvcHRpb25zPzogVGltZVdyaXRlclNldHRpbmdzLFxyXG4gICAgICAgIC4uLiBhcmdzOiBBcnJheTxzdHJpbmcgfCBUaW1lVW5pdCB8IHN0cmluZ1tdPik6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgbGVuZ3RoIHNlZ21lbnRlZCBpbnRvIG11bHRpcGxlIHVuaXRzIHVzaW5nIGEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgYW5kLCBvcHRpb25hbGx5LFxyXG4gICAgICogY29uZmlndXJhdGlvbnMgdGhhdCBtYXkgb3ZlcnJpZGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlIGluc3RhbmNlLCBmb3IgdGhlXHJcbiAgICAgKiBkdXJhdGlvbiBvZiB0aGUgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgd2lsbCBwcm9kdWNlIGV4cGxhbmF0aW9ucyBvZiB0aW1lIGxlbmd0aHMgbXVjaCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB0aGFuIGFyYml0cmFyeSBmcmFjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVcclxuICAgICAqICAgQW4gZW5jYXBzdWxhdGVkIG5hbm9zZWNvbmQtYmFzZWQgdGltZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYGNvdW50ZG93bmAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEBwYXJhbSBhcmdzXHJcbiAgICAgKiAgIEFjY2VwdHMgYW55IG51bWJlciBvZiB0aW1lIHVuaXRzIG9yIGFycmF5IG9mIHRpbWUgdW5pdHMgKGlmIHJlcGV0aXRpb25zIGFyZSBnaXZlbiwgdGhleSB3aWxsIGJlIHNpbmdsZWQgb3V0KS5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZSB0aHJvdWdoIHRoZSB1c2Ugb2YgbXVsdGlwbGUgdW5pdHMgb2YgdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvdW50ZG93bih0aW1lOiBUaW1lLCBvcHRpb25zPzogVGltZVdyaXRlclNldHRpbmdzLFxyXG4gICAgICAgIC4uLiBhcmdzOiBBcnJheTxUaW1lVW5pdFNvdXJjZSB8IFRpbWVVbml0U291cmNlW10+KTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdGltZSBsZW5ndGggc2VnbWVudGVkIGludG8gbXVsdGlwbGUgdW5pdHMgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksXHJcbiAgICAgKiBjb25maWd1cmF0aW9ucyB0aGF0IG1heSBvdmVycmlkZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGVcclxuICAgICAqIGR1cmF0aW9uIG9mIHRoZSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyB3aWxsIHByb2R1Y2UgZXhwbGFuYXRpb25zIG9mIHRpbWUgbGVuZ3RocyBtdWNoIGVhc2llciB0byB1bmRlcnN0YW5kIHRoYW4gYXJiaXRyYXJ5IGZyYWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVxyXG4gICAgICogICBBbiBlbmNhcHN1bGF0ZWQgbmFub3NlY29uZC1iYXNlZCB0aW1lLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqICAgV2hlbiBnaXZlbiwgdGhlc2UgY29uZmlndXJhdGlvbnMgd2lsbCBvdmVycmlkZSB0aGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlXHJcbiAgICAgKiAgIGluc3RhbmNlLCBmb3IgdGhpcyBzcGVjaWZpYyBgY291bnRkb3duYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHBhcmFtIGFyZ3NcclxuICAgICAqICAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIHRpbWUgdW5pdHMgb3IgYXJyYXkgb2YgdGltZSB1bml0cyAoaWYgcmVwZXRpdGlvbnMgYXJlIGdpdmVuLCB0aGV5IHdpbGwgYmUgc2luZ2xlZCBvdXQpLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lIHRocm91Z2ggdGhlIHVzZSBvZiBtdWx0aXBsZSB1bml0cyBvZiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY291bnRkb3duKHRpbWU6IFRpbWUsIG9wdGlvbnM/OiBUaW1lV3JpdGVyU2V0dGluZ3MgfCBUaW1lVW5pdFNvdXJjZSxcclxuICAgICAgICAuLi4gYXJnczogQXJyYXk8c3RyaW5nIHwgVGltZVVuaXQgfCBzdHJpbmdbXT4pOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gQWN0dWFsIGBjb3VudGRvd25gIGltcGxlbWVudGF0aW9uXHJcbiAgICBwdWJsaWMgY291bnRkb3duKHRpbWU6IFRpbWUsXHJcbiAgICAgICAgb3B0aW9uczogVGltZVdyaXRlclNldHRpbmdzIHwgVGltZVVuaXRTb3VyY2UgfCBUaW1lVW5pdFNvdXJjZVtdIHwgc3RyaW5nIHwgc3RyaW5nW10gPSB7fSxcclxuICAgICAgICAuLi4gYXJnczogQXJyYXk8VGltZVVuaXRTb3VyY2UgfCBUaW1lVW5pdFNvdXJjZVtdIHwgc3RyaW5nIHwgc3RyaW5nW10+KSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVVbml0TmFtZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgY29uc3QgdGltZVVuaXRPYmplY3RzOiBOYW1lZFRpbWVVbml0W10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gXCJzdHJpbmdcIiB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KFwiZmFjdG9yXCIpKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBbb3B0aW9ucyBhcyBUaW1lVW5pdFNvdXJjZV0uY29uY2F0KGFyZ3MgYXMgVGltZVVuaXRTb3VyY2VbXSk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgYXJncyA9IChvcHRpb25zIGFzIGFueSkuY29uY2F0KGFyZ3MpO1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBubyB0aW1lIHVuaXRzIHdlcmUgZ2l2ZW4sIHVzZSB0aGUgXCJjb21tb25cIiBjb25zdGFudFxyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBhcmdzID0gVGltZVNlZ21lbnRzLmNvbW1vbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNlbGVjdHMgYWxsIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRcclxuICAgICAgICBjb25zdCBhcnJheUFyZ3MgPSBhcmdzLmZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBBcnJheSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBhcmdzLmZpbHRlcihlID0+ICEoZSBpbnN0YW5jZW9mIEFycmF5KSk7XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2VzIGFycmF5cyBieSB0aGVpciBlbGVtZW50cyBvbiBhcmdzXHJcbiAgICAgICAgYXJyYXlBcmdzLmZvckVhY2goYXJyYXkgPT4geyBmaWx0ZXJlZC5wdXNoLmFwcGx5KGZpbHRlcmVkLCBhcnJheSk7IH0pO1xyXG4gICAgICAgIGFyZ3MgPSBmaWx0ZXJlZDtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBhcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVVbml0ID0gdGltZVVuaXRGcm9tU291cmNlKGFyZ3VtZW50IGFzIFRpbWVVbml0U291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIHJlcGVhdGVkIHVuaXRzXHJcbiAgICAgICAgICAgIGlmICh0aW1lVW5pdE5hbWVzLmluZGV4T2YodGltZVVuaXQubmFtZSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRpbWVVbml0TmFtZXMucHVzaCh0aW1lVW5pdC5uYW1lKTtcclxuICAgICAgICAgICAgdGltZVVuaXRPYmplY3RzLnB1c2godGltZVVuaXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX2NvbWJpbmVPcHRpb25zKG9wdGlvbnMgYXMgVGltZVdyaXRlclNldHRpbmdzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY291bnRkb3duVGltZSh0aW1lLCB0aW1lVW5pdE9iamVjdHMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBXcml0ZSBNZXRob2RcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlXHJcbiAgICAgKiB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHdpbGwgdXNlIHRoZSBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpICh3aGljaCBmYWxsc1xyXG4gICAgICogYmFjayB0byBcIm5hbm9zZWNvbmRzXCIpIGFzIGJvdGggaW5wdXQgKHdoZW4gdGltZSBpcyBudW1lcmljKSBhbmQgb3V0cHV0IHRpbWUgdW5pdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVxyXG4gICAgICogICBBIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgYSB0aW1lIHZhbHVlIC1vci0gYW4gZW5jYXBzdWxhdGVkIG5hbm9zZWNvbmQtYmFzZWQgdGltZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYHdyaXRlYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdGUodGltZTogVGltZVZhbHVlU291cmNlIHwgVGltZSwgb3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGEgdGltZSB1bml0IHRvIHRyYW5zZm9ybSBpdCBhbmRcclxuICAgICAqIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZSBpbnN0YW5jZSwgZm9yIHRoZVxyXG4gICAgICogZHVyYXRpb24gb2YgdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVxyXG4gICAgICogICBBbiBlbmNhcHN1bGF0ZWQgbmFub3NlY29uZC1iYXNlZCB0aW1lLlxyXG4gICAgICogQHBhcmFtIHRvVGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHRvIHdoaWNoIHRoZSBnaXZlbiB0aW1lIHdpbGwgYmUgY29udmVydGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBpdCBmYWxsYmFja3MgdG8gdGhlXHJcbiAgICAgKiAgIFtkZWZhdWx0IHRpbWUgdW5pdF0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI2RlZmF1bHR0aW1ldW5pdCkgYW5kIHVsdGltYXRlbHkgdG9cclxuICAgICAqICAgXCJuYW5vc2Vjb25kc1wiLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqICAgV2hlbiBnaXZlbiwgdGhlc2UgY29uZmlndXJhdGlvbnMgd2lsbCBvdmVycmlkZSB0aGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlXHJcbiAgICAgKiAgIGluc3RhbmNlLCBmb3IgdGhpcyBzcGVjaWZpYyBgd3JpdGVgLiBJdCBkb2VzIG5vdCBjaGFuZ2UgdGhlIG9iamVjdCBpbiBhbnkgd2F5IHdoYXRzb2V2ZXIuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSBzeW50aGV0aWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3cml0ZSh0aW1lOiBUaW1lLCB0b1RpbWVVbml0PzogVGltZVVuaXRTb3VyY2UsIG9wdGlvbnM/OiBUaW1lV3JpdGVyU2V0dGluZ3MpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB0aW1lIHZhbHVlIHVzaW5nIGEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgYW5kLCBvcHRpb25hbGx5LCBhIHRpbWUgdW5pdCB0byB0cmFuc2Zvcm0gaXQgYW5kXHJcbiAgICAgKiBjb25maWd1cmF0aW9ucyB0aGF0IG1heSBvdmVycmlkZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGVcclxuICAgICAqIGR1cmF0aW9uIG9mIHRoZSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVcclxuICAgICAqICAgQW4gZW5jYXBzdWxhdGVkIG5hbm9zZWNvbmQtYmFzZWQgdGltZS5cclxuICAgICAqIEBwYXJhbSB0b1RpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB0byB3aGljaCB0aGUgZ2l2ZW4gdGltZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvIHRoZVxyXG4gICAgICogICBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi4gQWNjZXB0cyBwbHVyYWxzIGFuZCBjYXNlIHZhcmlhdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogICBXaGVuIGdpdmVuLCB0aGVzZSBjb25maWd1cmF0aW9ucyB3aWxsIG92ZXJyaWRlIHRoZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGVcclxuICAgICAqICAgaW5zdGFuY2UsIGZvciB0aGlzIHNwZWNpZmljIGB3cml0ZWAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHdyaXRlKHRpbWU6IFRpbWUsIHRvVGltZVVuaXQ/OiBzdHJpbmcgfCBUaW1lVW5pdCwgb3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGEgdGltZSB1bml0IHRvIHRyYW5zZm9ybSBpdCBhbmRcclxuICAgICAqIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZSBpbnN0YW5jZSwgZm9yIHRoZVxyXG4gICAgICogZHVyYXRpb24gdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVZhbHVlXHJcbiAgICAgKiAgIEEgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gdGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IGZyb20gd2hpY2ggdGhlIGdpdmVuIHRpbWUgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdCBwYXNzZWQsIGl0IGZhbGxiYWNrcyB0b1xyXG4gICAgICogICB0aGUgW2RlZmF1bHQgdGltZSB1bml0XSguLi9pbnRlcmZhY2VzL19pbmRleF8udGltZXdyaXRlcnNldHRpbmdzLmh0bWwjZGVmYXVsdHRpbWV1bml0KSBhbmQgdWx0aW1hdGVseSB0b1xyXG4gICAgICogICBcIm5hbm9zZWNvbmRzXCIuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogICBXaGVuIGdpdmVuLCB0aGVzZSBjb25maWd1cmF0aW9ucyB3aWxsIG92ZXJyaWRlIHRoZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGVcclxuICAgICAqICAgaW5zdGFuY2UsIGZvciB0aGlzIHNwZWNpZmljIGB3cml0ZWAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHdyaXRlKHRpbWVWYWx1ZTogVGltZVZhbHVlU291cmNlLCB0aW1lVW5pdD86IFRpbWVVbml0U291cmNlLCBvcHRpb25zPzogVGltZVdyaXRlclNldHRpbmdzKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdGltZSB2YWx1ZSB1c2luZyBhIFtUaW1lXShfaW5kZXhfLnRpbWUuaHRtbCkgb2JqZWN0IGFuZCwgb3B0aW9uYWxseSwgYSB0aW1lIHVuaXQgdG8gdHJhbnNmb3JtIGl0IGFuZFxyXG4gICAgICogY29uZmlndXJhdGlvbnMgdGhhdCBtYXkgb3ZlcnJpZGUgdGhvc2Ugb2YgdGhlIFtMb2NhbGVdKF9sb2NhbGl6YXRpb25fLmxvY2FsZS5odG1sKSBhbmQgdGhlIGluc3RhbmNlLCBmb3IgdGhlXHJcbiAgICAgKiBkdXJhdGlvbiB0aGUgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aW1lVmFsdWVcclxuICAgICAqICAgQSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIGEgdGltZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB0aW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgZnJvbSB3aGljaCB0aGUgZ2l2ZW4gdGltZSB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvXHJcbiAgICAgKiAgIHRoZSBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYHdyaXRlYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdGUodGltZVZhbHVlOiBUaW1lVmFsdWVTb3VyY2UsIHRpbWVVbml0Pzogc3RyaW5nIHwgVGltZVVuaXQsIG9wdGlvbnM/OiBUaW1lV3JpdGVyU2V0dGluZ3MpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB0aW1lIHZhbHVlIHVzaW5nIGEgW1RpbWVdKF9pbmRleF8udGltZS5odG1sKSBvYmplY3QgYW5kLCBvcHRpb25hbGx5LCBhIHRpbWUgdW5pdCB0byB0cmFuc2Zvcm0gaXQgYW5kXHJcbiAgICAgKiBjb25maWd1cmF0aW9ucyB0aGF0IG1heSBvdmVycmlkZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGUgaW5zdGFuY2UsIGZvciB0aGVcclxuICAgICAqIGR1cmF0aW9uIHRoZSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbWVWYWx1ZVxyXG4gICAgICogICBBIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgYSB0aW1lIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIGZyb21UaW1lVW5pdFxyXG4gICAgICogICBUaW1lIHVuaXQgZnJvbSB3aGljaCB0aGUgZ2l2ZW4gdGltZSB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvXHJcbiAgICAgKiAgIHRoZSBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi5cclxuICAgICAqIEBwYXJhbSB0b1RpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB0byB3aGljaCB0aGUgZ2l2ZW4gdGltZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvIHRoZVxyXG4gICAgICogICBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYHdyaXRlYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdGUodGltZVZhbHVlOiBUaW1lVmFsdWVTb3VyY2UsIGZyb21UaW1lVW5pdD86IFRpbWVVbml0U291cmNlLCB0b1RpbWVVbml0PzogVGltZVVuaXRTb3VyY2UsXHJcbiAgICAgICAgb3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGEgdGltZSB1bml0IHRvIHRyYW5zZm9ybSBpdCBhbmRcclxuICAgICAqIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZSBpbnN0YW5jZSwgZm9yIHRoZVxyXG4gICAgICogZHVyYXRpb24gdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVZhbHVlXHJcbiAgICAgKiAgIEEgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCBmcm9tIHdoaWNoIHRoZSBnaXZlbiB0aW1lIHZhbHVlIHdpbGwgYmUgY29udmVydGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBpdCBmYWxsYmFja3MgdG9cclxuICAgICAqICAgdGhlIFtkZWZhdWx0IHRpbWUgdW5pdF0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI2RlZmF1bHR0aW1ldW5pdCkgYW5kIHVsdGltYXRlbHkgdG9cclxuICAgICAqICAgXCJuYW5vc2Vjb25kc1wiLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhc2UgdmFyaWF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB0b1RpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB0byB3aGljaCB0aGUgZ2l2ZW4gdGltZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvIHRoZVxyXG4gICAgICogICBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYHdyaXRlYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdGUodGltZVZhbHVlOiBUaW1lVmFsdWVTb3VyY2UsIGZyb21UaW1lVW5pdD86IHN0cmluZyB8IFRpbWVVbml0LCB0b1RpbWVVbml0PzogVGltZVVuaXRTb3VyY2UsXHJcbiAgICAgICAgb3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGEgdGltZSB1bml0IHRvIHRyYW5zZm9ybSBpdCBhbmRcclxuICAgICAqIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZSBpbnN0YW5jZSwgZm9yIHRoZVxyXG4gICAgICogZHVyYXRpb24gdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVZhbHVlXHJcbiAgICAgKiAgIEEgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCBmcm9tIHdoaWNoIHRoZSBnaXZlbiB0aW1lIHZhbHVlIHdpbGwgYmUgY29udmVydGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBpdCBmYWxsYmFja3MgdG9cclxuICAgICAqICAgdGhlIFtkZWZhdWx0IHRpbWUgdW5pdF0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI2RlZmF1bHR0aW1ldW5pdCkgYW5kIHVsdGltYXRlbHkgdG9cclxuICAgICAqICAgXCJuYW5vc2Vjb25kc1wiLlxyXG4gICAgICogQHBhcmFtIHRvVGltZVVuaXRcclxuICAgICAqICAgVGltZSB1bml0IHRvIHdoaWNoIHRoZSBnaXZlbiB0aW1lIHdpbGwgYmUgY29udmVydGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBpdCBmYWxsYmFja3MgdG8gdGhlXHJcbiAgICAgKiAgIFtkZWZhdWx0IHRpbWUgdW5pdF0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI2RlZmF1bHR0aW1ldW5pdCkgYW5kIHVsdGltYXRlbHkgdG9cclxuICAgICAqICAgXCJuYW5vc2Vjb25kc1wiLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhc2UgdmFyaWF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiAgIFdoZW4gZ2l2ZW4sIHRoZXNlIGNvbmZpZ3VyYXRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZVxyXG4gICAgICogICBpbnN0YW5jZSwgZm9yIHRoaXMgc3BlY2lmaWMgYHdyaXRlYC4gSXQgZG9lcyBub3QgY2hhbmdlIHRoZSBvYmplY3QgaW4gYW55IHdheSB3aGF0c29ldmVyLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHN0cmluZyBjb250YWluaW5nIGEgc3ludGhldGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgd3JpdGUodGltZVZhbHVlOiBUaW1lVmFsdWVTb3VyY2UsIGZyb21UaW1lVW5pdD86IFRpbWVVbml0U291cmNlLCB0b1RpbWVVbml0Pzogc3RyaW5nIHwgVGltZVVuaXQsXHJcbiAgICAgICAgb3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncyk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHRpbWUgdmFsdWUgdXNpbmcgYSBbVGltZV0oX2luZGV4Xy50aW1lLmh0bWwpIG9iamVjdCBhbmQsIG9wdGlvbmFsbHksIGEgdGltZSB1bml0IHRvIHRyYW5zZm9ybSBpdCBhbmRcclxuICAgICAqIGNvbmZpZ3VyYXRpb25zIHRoYXQgbWF5IG92ZXJyaWRlIHRob3NlIG9mIHRoZSBbTG9jYWxlXShfbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCkgYW5kIHRoZSBpbnN0YW5jZSwgZm9yIHRoZVxyXG4gICAgICogZHVyYXRpb24gdGhlIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGltZVZhbHVlXHJcbiAgICAgKiAgIEEgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVRpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCBmcm9tIHdoaWNoIHRoZSBnaXZlbiB0aW1lIHZhbHVlIHdpbGwgYmUgY29udmVydGVkLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBpdCBmYWxsYmFja3MgdG9cclxuICAgICAqICAgdGhlIFtkZWZhdWx0IHRpbWUgdW5pdF0oLi4vaW50ZXJmYWNlcy9faW5kZXhfLnRpbWV3cml0ZXJzZXR0aW5ncy5odG1sI2RlZmF1bHR0aW1ldW5pdCkgYW5kIHVsdGltYXRlbHkgdG9cclxuICAgICAqICAgXCJuYW5vc2Vjb25kc1wiLiBBY2NlcHRzIHBsdXJhbHMgYW5kIGNhc2UgdmFyaWF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB0b1RpbWVVbml0XHJcbiAgICAgKiAgIFRpbWUgdW5pdCB0byB3aGljaCB0aGUgZ2l2ZW4gdGltZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZCwgaXQgZmFsbGJhY2tzIHRvIHRoZVxyXG4gICAgICogICBbZGVmYXVsdCB0aW1lIHVuaXRdKC4uL2ludGVyZmFjZXMvX2luZGV4Xy50aW1ld3JpdGVyc2V0dGluZ3MuaHRtbCNkZWZhdWx0dGltZXVuaXQpIGFuZCB1bHRpbWF0ZWx5IHRvXHJcbiAgICAgKiAgIFwibmFub3NlY29uZHNcIi4gQWNjZXB0cyBwbHVyYWxzIGFuZCBjYXNlIHZhcmlhdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogICBXaGVuIGdpdmVuLCB0aGVzZSBjb25maWd1cmF0aW9ucyB3aWxsIG92ZXJyaWRlIHRoZSB0aG9zZSBvZiB0aGUgW0xvY2FsZV0oX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwpIGFuZCB0aGVcclxuICAgICAqICAgaW5zdGFuY2UsIGZvciB0aGlzIHNwZWNpZmljIGB3cml0ZWAuIEl0IGRvZXMgbm90IGNoYW5nZSB0aGUgb2JqZWN0IGluIGFueSB3YXkgd2hhdHNvZXZlci5cclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQSBzdHJpbmcgY29udGFpbmluZyBhIHN5bnRoZXRpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHdyaXRlKHRpbWVWYWx1ZTogVGltZVZhbHVlU291cmNlLCBmcm9tVGltZVVuaXQ/OiBzdHJpbmcgfCBUaW1lVW5pdCwgdG9UaW1lVW5pdD86IHN0cmluZyB8IFRpbWVVbml0LFxyXG4gICAgICAgIG9wdGlvbnM/OiBUaW1lV3JpdGVyU2V0dGluZ3MpOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gQWN0dWFsIGB3cml0ZWAgaW1wbGVtZW50YXRpb25cclxuICAgIHB1YmxpYyB3cml0ZSh0aW1lOiBUaW1lVmFsdWVTb3VyY2UgfCBUaW1lLCBmcm9tVGltZVVuaXQ/OiBUaW1lVW5pdFNvdXJjZSB8IFRpbWVXcml0ZXJTZXR0aW5ncyB8IHN0cmluZyxcclxuICAgICAgICB0b1RpbWVVbml0PzogVGltZVVuaXRTb3VyY2UgfCBUaW1lV3JpdGVyU2V0dGluZ3MgfCBzdHJpbmcsIG9wdGlvbnM/OiBUaW1lV3JpdGVyU2V0dGluZ3MpIHtcclxuXHJcbiAgICAgICAgY29uc3QgaXNPcHRpb25zID0gKG9iamVjdDogYW55KSA9PiB0eXBlb2Yob2JqZWN0KSA9PT0gXCJvYmplY3RcIiAmJiAhb2JqZWN0Lmhhc093blByb3BlcnR5KFwiZmFjdG9yXCIpO1xyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMgJiYgaXNPcHRpb25zKGZyb21UaW1lVW5pdCkpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGZyb21UaW1lVW5pdCBhcyBUaW1lV3JpdGVyU2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGZyb21UaW1lVW5pdCA9IHRvVGltZVVuaXQ7XHJcbiAgICAgICAgICAgIHRvVGltZVVuaXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMgJiYgaXNPcHRpb25zKHRvVGltZVVuaXQpKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0b1RpbWVVbml0IGFzIFRpbWVXcml0ZXJTZXR0aW5ncztcclxuICAgICAgICAgICAgdG9UaW1lVW5pdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jb21iaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuXHJcbiAgICAgICAgZnJvbVRpbWVVbml0ID0gKGZyb21UaW1lVW5pdCB8fCBvcHRpb25zLmRlZmF1bHRUaW1lVW5pdCB8fCBcIm5hbm9zZWNvbmRcIikgYXMgVGltZVVuaXRTb3VyY2U7XHJcbiAgICAgICAgdG9UaW1lVW5pdCA9ICh0b1RpbWVVbml0IHx8IGZyb21UaW1lVW5pdCkgYXMgVGltZVVuaXRTb3VyY2U7XHJcblxyXG4gICAgICAgIGlmICghKHRpbWUgaW5zdGFuY2VvZiBUaW1lKSkge1xyXG4gICAgICAgICAgICB0aW1lID0gVGltZS5mcm9tKHRpbWUsIGZyb21UaW1lVW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVUaW1lKHRpbWUsIG9wdGlvbnMsIHRvVGltZVVuaXQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gR2V0cyB0aGUgb3B0aW9ucyBvdmVycmlkZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXJcclxuICAgIHByaXZhdGUgX2NvbWJpbmVPcHRpb25zKG9wdGlvbnM6IFRpbWVXcml0ZXJTZXR0aW5ncyB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdFNldHRpbmdzLCBMb2NhbGUuc2V0dGluZ3Mud3JpdGVyT3B0aW9ucywgdGhpcy5zZXR0aW5ncywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlbW92ZWQgb24gbmV4dCBtYWpvciByZWxlYXNlLCBidXQgZm9yIG5vdywgcGFyc2UgdGhlbVxyXG5cclxuICAgICAgICBvcHRpb25zLmRlY2ltYWxQbGFjZXMgPSB0eXBlb2Yob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSA9PT0gXCJudW1iZXJcIlxyXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1xyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZnJhY3Rpb25EaWdpdHM7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVVbml0U2VwYXJhdG9yID09PSBkZWZhdWx0U2V0dGluZ3MudGltZVVuaXRTZXBhcmF0b3IgJiYgb3B0aW9ucy5zcGFjZVRpbWVVbml0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnRpbWVVbml0U2VwYXJhdG9yID0gXCJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRlcm1zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVybUFwcHJveGltYXRlbHkgPSBvcHRpb25zLnRlcm1BcHByb3hpbWF0ZWx5IHx8IG9wdGlvbnMudGVybXMuYXBwcm94aW1hdGVseTtcclxuICAgICAgICAgICAgb3B0aW9ucy50ZXJtSW5maW5pdGUgPSBvcHRpb25zLnRlcm1JbmZpbml0ZSB8fCBvcHRpb25zLnRlcm1zLmluZmluaXRlO1xyXG4gICAgICAgICAgICBvcHRpb25zLnRlcm1OYU4gPSBvcHRpb25zLnRlcm1OYU4gfHwgb3B0aW9ucy50ZXJtcy5uYW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3VudCBhbmQgd3JpdGVzIHRpbWVzIHVuaXQtYnktdW5pdFxyXG4gICAgcHJpdmF0ZSBfY291bnRkb3duVGltZSh0aW1lOiBUaW1lLCB0aW1lVW5pdExpc3Q6IE5hbWVkVGltZVVuaXRbXSwgb3B0aW9uczogVGltZVdyaXRlclNldHRpbmdzKSB7XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZTogRGVjaW1hbCA9IG5ldyBEZWNpbWFsKDApO1xyXG4gICAgICAgIGxldCBpbnRlZ2VyOiBEZWNpbWFsID0gbmV3IERlY2ltYWwoMCk7XHJcbiAgICAgICAgbGV0IGZyYWN0aW9uOiBEZWNpbWFsID0gbmV3IERlY2ltYWwoMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9ICh0b3RhbDogRGVjaW1hbCkgPT4geyB2YWx1ZSA9IHRvdGFsLCBpbnRlZ2VyID0gdmFsdWUudHJ1bmMoKSwgZnJhY3Rpb24gPSB2YWx1ZS5taW51cyhpbnRlZ2VyKTsgfTtcclxuXHJcbiAgICAgICAgLy8gU29ydHMgdGhlIHRpbWUgdW5pdHMgZnJvbSBsYXJnZXN0IGZhY3RvciB0byBzbWFsbGVzdFxyXG4gICAgICAgIHRpbWVVbml0TGlzdC5zb3J0KChhLCBiKSA9PiBiLmZhY3Rvci5jb21wYXJlZFRvKGEuZmFjdG9yKSk7XHJcblxyXG4gICAgICAgIC8vIFNldHMgdGhlIHZhbHVlIHRvIHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmlyc3QgdGltZSB1bml0XHJcbiAgICAgICAgdXBkYXRlKHRpbWUudG9CaWcodGltZVVuaXRMaXN0WzBdKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aW1lVW5pdExpc3QubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUaW1lVW5pdCA9IHRpbWVVbml0TGlzdFtpIC0gMV07XHJcblxyXG4gICAgICAgICAgICBpZiAoKGludGVnZXIuY29tcGFyZWRUbygwKSAhPT0gMCB8fCBvcHRpb25zLmhpZGVaZXJvU2VnbWVudHMgPT09IGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgKCFpbnRlZ2VyLmlzTmFOKCkgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gdGltZS5pc0FwcHJveGltYXRlZCB8fCBwcmV2aW91c1RpbWVVbml0LmFwcHJveGltYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgID8gVGltZS5mcm9tKGludGVnZXIsIHByZXZpb3VzVGltZVVuaXQpLmFwcHJveGltYXRlKClcclxuICAgICAgICAgICAgICAgICAgICA6IFRpbWUuZnJvbShpbnRlZ2VyLCBwcmV2aW91c1RpbWVVbml0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhlIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy53cml0ZShwYXJzZWRUaW1lLCBwcmV2aW91c1RpbWVVbml0LCBvcHRpb25zKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudGluZyBgd3JpdGVgIGZyb20gd3JpdHRpbmcgdGhlIGFwcHJveGltYXRpb24gc3ltYm9sIC8gbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUuaXNBcHByb3hpbWF0ZWQgfHwgcHJldmlvdXNUaW1lVW5pdC5hcHByb3hpbWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG91bGRBcHByb3hpbWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cGRhdGUoVGltZS5mcm9tKGZyYWN0aW9uLCBwcmV2aW91c1RpbWVVbml0KS50b0JpZyh0aW1lVW5pdExpc3RbaV0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVVbml0ID0gdGltZVVuaXRMaXN0W3RpbWVVbml0TGlzdC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgaWYgKCh2YWx1ZS5jb21wYXJlZFRvKDApICE9PSAwIHx8IG9wdGlvbnMuaGlkZVplcm9TZWdtZW50cyA9PT0gZmFsc2UpICYmXHJcbiAgICAgICAgICAgICghdmFsdWUuaXNOYU4oKSB8fCByZXN1bHQubGVuZ3RoID09PSAwKSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRpbWVVbml0LmZhY3Rvci5lcXVhbHMoXCI1LjM5MDU2ZS0zNVwiKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGxhbmNrIHRpbWUgaXMgdGVvcmV0aWNhbGx5IGluZGl2aXNpYmxlXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLndyaXRlKHZhbHVlLnJvdW5kKCksIHRpbWVVbml0LCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGRzIHRoZSBsYXN0IHNlZ21lbnQgaW4gaXRzIGVudGlyZXR5IChubyBpbnRlZ2VyLW9ubHkpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLndyaXRlKHZhbHVlLCB0aW1lVW5pdCwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zaG91bGRBcHByb3hpbWF0ZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKG9wdGlvbnMuc2VnbWVudFNlcGFyYXRvciB8fCBcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZXMgbnVtZXJpYyBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBudW1lcmljIHN0cmluZ1xyXG4gICAgcHJpdmF0ZSBfd3JpdGVOdW1iZXIodmFsdWU6IERlY2ltYWwsIG9wdGlvbnM6IFRpbWVXcml0ZXJTZXR0aW5ncykge1xyXG5cclxuICAgICAgICBpZiAodmFsdWUuaXNOYU4oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMudmVyYm9zZSA/IG9wdGlvbnMudGVybU5hTiA6IG9wdGlvbnMuc3ltYm9sTmFOKSB8fCBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF2YWx1ZS5pc0Zpbml0ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy52ZXJib3NlID8gb3B0aW9ucy50ZXJtSW5maW5pdGUgOiBvcHRpb25zLnN5bWJvbEluZmluaXRlKSB8fCBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMubnVtZXJpY05vdGF0aW9uID09PSBcInJvbWFuXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlUm9tYW4odmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMubnVtZXJpY05vdGF0aW9uID09PSBcInJvbWFuLWZyYWN0aW9uc1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVJvbWFuKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbb3B0aW9ucy5kZWNpbWFsUGxhY2VzLCBvcHRpb25zLnJvdW5kaW5nTW9kZV07XHJcbiAgICAgICAgbGV0IHN0cmluZ1ZhbHVlOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25pZmljYW50RGlnaXRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHZhbHVlLnRydW5jKCkucHJlY2lzaW9uKHRydWUpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU2lnbmlmaWNhbnREaWdpdHMob3B0aW9ucy5zaWduaWZpY2FudERpZ2l0cyArIG9mZnNldCwgb3B0aW9ucy5yb3VuZGluZ01vZGUgYXMgYW55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLm51bWVyaWNOb3RhdGlvbiA9PT0gXCJzY2llbnRpZmljXCIpIHtcclxuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSB2YWx1ZS50b0V4cG9uZW50aWFsLmFwcGx5KHZhbHVlLCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvRml4ZWQuYXBwbHkodmFsdWUsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFyc2luZyB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciBvbmx5IGZvciBkZWNpbWFscyBhbmQgdmFsdWVzID49IDEwMDBcclxuICAgICAgICBpZiAob3B0aW9ucy5udW1lcmljTm90YXRpb24gPT09IFwiZGVjaW1hbFwiICYmIG9wdGlvbnMudGhvdXNhbmRzU2VwYXJhdG9yICYmIHZhbHVlLmNvbXBhcmVkVG8oMTAwMCkgPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0cmluZ1ZhbHVlLnNwbGl0KGxvY2FsZURlY2ltYWxTZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIG9wdGlvbnMudGhvdXNhbmRzU2VwYXJhdG9yKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gcGFydHMuam9pbihsb2NhbGVEZWNpbWFsU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gcGFydHNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Yob3B0aW9ucy5kZWNpbWFsU2VwYXJhdG9yKSA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLmRlY2ltYWxTZXBhcmF0b3IgIT09IGxvY2FsZURlY2ltYWxTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSByZXBsYWNlTGFzdChzdHJpbmdWYWx1ZSwgbG9jYWxlRGVjaW1hbFNlcGFyYXRvciwgb3B0aW9ucy5kZWNpbWFsU2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZXMgdGltZS1yZWxhdGVkIG9wdGlvbnMgYW5kIHJldHVybiB0aGUgdGltZSBzdHJpbmdcclxuICAgIHByaXZhdGUgX3dyaXRlVGltZSh0aW1lOiBUaW1lLCBvcHRpb25zOiBUaW1lV3JpdGVyU2V0dGluZ3MsIHRhcmdldFRpbWVVbml0OiBzdHJpbmcgfCBUaW1lVW5pdCkge1xyXG5cclxuICAgICAgICBjb25zdCBuYW1lZFRpbWVVbml0ID0gdGltZVVuaXRGcm9tU291cmNlKHRhcmdldFRpbWVVbml0IHx8IG9wdGlvbnMuZGVmYXVsdFRpbWVVbml0IHx8IFwibmFub3NlY29uZFwiKTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IExvY2FsZS5zZXR0aW5ncy50aW1lVW5pdHMgPyBMb2NhbGUuc2V0dGluZ3MudGltZVVuaXRzW25hbWVkVGltZVVuaXQubmFtZV0gOiB7fTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRpbWUudG9CaWcodGFyZ2V0VGltZVVuaXQpO1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lVW5pdCA9IG1lcmdlKG5hbWVkVGltZVVuaXQsIHRyYW5zbGF0aW9uKSBhcyBOYW1lZFRpbWVVbml0O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAgICAgLy8gUGFydCAxOiBhcHByb3hpbWF0aW9uIHRlcm0vc3ltYm9sXHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEFwcHJveGltYXRlICYmICh0aW1lLmlzQXBwcm94aW1hdGVkIHx8IG5hbWVkVGltZVVuaXQuYXBwcm94aW1hdGVkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBhcHByb3hpbWF0ZWx5ID0gISFvcHRpb25zLnZlcmJvc2VcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50ZXJtQXBwcm94aW1hdGVseSA/IG9wdGlvbnMudGVybUFwcHJveGltYXRlbHkgKyBcIiBcIiA6IFwiXCJcclxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5zeW1ib2xBcHByb3hpbWF0ZWx5O1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXBwcm94aW1hdGVseSB8fCBcIlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnQgMjogbnVtYmVyXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLm51bWVyaWNXcml0ZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fd3JpdGVOdW1iZXIodmFsdWUsIG9wdGlvbnMpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHRpb25zLm51bWVyaWNXcml0ZXIodmFsdWUudG9OdW1iZXIoKSwgdmFsdWUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnQgMzogc2VwYXJhdG9yXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmhpZGVUaW1lVW5pdCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHRpb25zLnRpbWVVbml0U2VwYXJhdG9yIHx8IFwiXCIpO1xyXG5cclxuICAgICAgICAvLyBQYXJ0IDQ6IHRpbWUgdW5pdFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFbXB0eShyZXN1bHQpLmpvaW4oXCJcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwbHVyYWxpemUgPSB0aW1lVW5pdC5wbHVyYWxpemUgIT09IGZhbHNlICYmICghdmFsdWUuaXNGaW5pdGUoKSB8fCB2YWx1ZS5jb21wYXJlZFRvKDEpID4gMCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fd3JpdGVUaW1lVW5pdCh2YWx1ZSwgdGltZVVuaXQsIG9wdGlvbnMsIHBsdXJhbGl6ZSkpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJFbXB0eShyZXN1bHQpLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2VzIHRpbWUgdW5pdC1yZWxhdGVkIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIHRpbWUgdW5pdCBzdHJpbmdcclxuICAgIHByaXZhdGUgX3dyaXRlVGltZVVuaXQodmFsdWU6IERlY2ltYWwsIHRpbWVVbml0OiBOYW1lZFRpbWVVbml0LCBvcHRpb25zOiBUaW1lV3JpdGVyU2V0dGluZ3MsIHBsdXJhbDogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnZlcmJvc2UgJiYgdGltZVVuaXQuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpbWVVbml0LnN5bWJvbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFbXB0eShyZXN1bHQpLmpvaW4oXCJcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGltZVVuaXROYW1lID0gdGltZVVuaXQucmVhZGFibGVOYW1lO1xyXG5cclxuICAgICAgICBpZiAocGx1cmFsICYmIHR5cGVvZih0aW1lVW5pdC5jdXN0b21QbHVyYWwpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGltZVVuaXROYW1lID0gdGltZVVuaXQuY3VzdG9tUGx1cmFsKHZhbHVlLnRvTnVtYmVyKCksIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwbHVyYWwgJiYgdHlwZW9mKHRpbWVVbml0LmN1c3RvbVBsdXJhbCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGltZVVuaXROYW1lID0gdGltZVVuaXQuY3VzdG9tUGx1cmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZih0aW1lVW5pdE5hbWUpID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHRpbWVVbml0TmFtZSA9IHRpbWVVbml0Lm5hbWUucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMSAkMlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBsdXJhbCAmJiAhdGltZVVuaXQuY3VzdG9tUGx1cmFsKSB7XHJcbiAgICAgICAgICAgIHRpbWVVbml0TmFtZSArPSBcInNcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHRpbWVVbml0TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckVtcHR5KHJlc3VsdCkuam9pbihcIlwiKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgYmVoYXZpb3Igb2YgW3RpbWUgd3JpdGVyc10oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCkuXHJcbiAqXHJcbiAqIFVzaW5nIHRoZXNlIG9iamVjdHMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBsZXhpY2FsIGFuZCBudW1lcmljYWwgb3V0cHV0IHRvIGZpdCBtYW55IGRpZmZlcmVudCBzY2VuYXJpb3MuIFNlZVxyXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGltZVdyaXRlclNldHRpbmdzIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE51bWVyIG9mIGRlY2ltYWwgcGxhY2VzIHJlc3VsdGluZyBmcm9tIHRpbWUgY29udmVyc2lvbnMuIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbcm91bmRpbmdNb2RlXSB0byB3cml0ZSBudW1lcmljXHJcbiAgICAgKiB2YWx1ZXNcclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0OiBgdW5kZWZpbmVkYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL2RlY2ltYWxQbGFjZXMubWRdXVxyXG4gICAgICovXHJcbiAgICBkZWNpbWFsUGxhY2VzPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nIHVzZWQgYXMgZGVjaW1hbCBzZXBhcmF0b3IsIHNwZWNpYWxseSB1c2VmdWwgd2hlbiB0cmFuc2xhdGluZyB0byBsYW5ndWFnZXMgYW5kIHJlZ2lvbnMgd2hlcmUgdGhlIFwiZG90XCJcclxuICAgICAqIG5vdGF0aW9uIGlzIG5vdCBzdGFuZGFyZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBub3Qgc2V0LCB0aW1lIHdyaXRlcnMgd2lsbCBmaXJzdCB0cnkgdG8gcGFyc2UgdGhlIGRlY2ltYWwgc2VwYXJhdG9yIGZvciB0aGUgbG9jYWxlIG9mIHRoZSBtYWNoaW5lIHdoZXJlIHRoZVxyXG4gICAgICogc2NyaXB0IGlzIHJ1bm5pbmcgYW5kIHdpbGwgdWx0aW1hdGVseSBmYWxsYmFjayB0byBgXCIuXCJgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyc2V0dGluZ3MvZGVjaW1hbFNlcGFyYXRvci5tZF1dXHJcbiAgICAgKi9cclxuICAgIGRlY2ltYWxTZXBhcmF0b3I/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRlZmF1bHQgdW5pdCB0byBjb252ZXJ0IHRvIHdoZW4gd3JpdGluZyB0aW1lIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0IGlzIFtuYW5vc2Vjb25kXShfaW5kZXhfLnRpbWV1bml0ZGF0YWJhc2UuaHRtbCNuYW5vc2Vjb25kKS5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL2RlZmF1bHRUaW1lVW5pdC5tZF1dXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRUaW1lVW5pdD86IFRpbWVVbml0U291cmNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogKipUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQhKiogV2hlbiBnaXZlbiwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpeGVkIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBJbiBmYXZvciBvZiBgc2lnbmlmaWNhbnREaWdpdHNgICh3aWxsIGJlIHJlbW92ZWQgaW4gdjIpLlxyXG4gICAgICovXHJcbiAgICBmcmFjdGlvbkRpZ2l0cz86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSwgaXQgd2lsbCBwcmV2ZW50IHRoZSB0aW1lIHdyaXRlciBmcm9tIHdyaXR0aW5nIGFueSBmb3JtIG9mIHRpbWUgdW5pdCwgYmUgaXRcclxuICAgICAqIHBsdXJhbCwgc3ltYm9sIG9yIHZlcmJvc2UuIEl0IHdpbGwgYWxzbyBwcmV2ZW50IHRoZSBvdXRwdXQgb2YgdGhlIFt0aW1lIHVuaXQgc2VwYXJhdG9yXSgjdGltZXVuaXRzZXBhcmF0b3IpLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYGZhbHNlYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL2hpZGVUaW1lVW5pdC5tZF1dXHJcbiAgICAgKi9cclxuICAgIGhpZGVUaW1lVW5pdD86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGhpZGUgW2NvdW50ZG93bl0oLi4vY2xhc3Nlcy9faW5kZXgudGltZXdyaXRlci5odG1sI2NvdW50ZG93bikgc2VnbWVudHMgd2l0aCBhIHZhbHVlIG9mIDAgKHplcm8pLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYHRydWVgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyc2V0dGluZ3MvaGlkZVplcm9TZWdtZW50cy5tZF1dXHJcbiAgICAgKi9cclxuICAgIGhpZGVaZXJvU2VnbWVudHM/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtZXJpYyBub3RhdGlvbiB1c2VkIHRvIHdyaXRlIHRpbWUgdmFsdWVzLiBBY2NlcHRlZCB2YWx1ZXMgYXJlOlxyXG4gICAgICogLSAqKlwiZGVjaW1hbFwiOioqIHN0YW5kYXJkIF9IaW5kdeKAk0FyYWJpYyBudW1lcmFsIHN5c3RlbV8gdXNpbmcgYmFzZSB0ZW47XHJcbiAgICAgKiAtICoqXCJyb21hblwiOioqIF9BbmNpZW50IFJvbWVfIG51bWVyYWwgc3lzdGVtLCBpZ25vcmluZyBmcmFjdGlvbnM7XHJcbiAgICAgKiAtICoqXCJyb21hbi1mcmFjdGlvbnNcIjoqKiBfQW5jaWVudCBSb21lXyBudW1lcmFsIHN5c3RlbSwgdXNpbmdcclxuICAgICAqICAgW2NvbW1vbiBmcmFjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbWFuX251bWVyYWxzI0ZyYWN0aW9ucyk7XHJcbiAgICAgKiAtICoqXCJzY2llbnRpZmljXCI6KiogRXhwb25lbnQgbm90YXRpb247IHdyaXRlcyB2ZXJ5IHNtYWxsIGFuZCB2ZXJ5IGxhcmdlIG51bWJlcnMgdXNpbmcgcG93ZXJzIG9mIDEwLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYFwiZGVjaW1hbFwiYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL251bWVyaWNOb3RhdGlvbi5tZF1dXHJcbiAgICAgKi9cclxuICAgIG51bWVyaWNOb3RhdGlvbj86IE51bWVyaWNOb3RhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2FuIGJlIHNldCB0byBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXBsYWNlIGFsbCBvdGhlciBmb3JtcyBvZiBudW1lcmljIHdyaXR0aW5nLCBpZ25vcmluZyB0aGVcclxuICAgICAqIFtudW1lcmljIG5vdGF0aW9uXSgjbnVtZXJpY25vdGF0aW9uKSBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBtYXkgcmVjZWl2ZSB0d28gcGFyYW1ldGVyczogYSBudW1iZXIgYW5kIGFuIG9wdGlvbmFsXHJcbiAgICAgKiBbYmlnIGRlY2ltYWxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2RlY2ltYWwuanMpLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy9udW1lcmljV3JpdGVyLm1kXV1cclxuICAgICAqL1xyXG4gICAgbnVtZXJpY1dyaXRlcj86IE51bWVyaWNXcml0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1lcmljIFtyb3VuZGluZyBtb2RlXSguLi9lbnVtcy9faW5kZXhfLnJvdW5kaW5nbW9kZS5odG1sKSB1c2VkIGJ5IHRoZSB3cml0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdCBpcyBgUm91bmRpbmdNb2RlLlJvdW5kSGFsZlVwYCBvciBgNGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy9yb3VuZGluZ01vZGUubWRdXVxyXG4gICAgICovXHJcbiAgICByb3VuZGluZ01vZGU/OiBSb3VuZGluZ01vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyB1c2VkIHRvIHNlcGFyYXRlIFtjb3VudGRvd25dKC4uL2NsYXNzZXMvX2luZGV4LnRpbWV3cml0ZXIuaHRtbCNjb3VudGRvd24pIHNlZ21lbnRzLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYFwiLCBcImAgKGNvbW1hIGFuZCBzcGFjZSkuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy9zZWdtZW50U2VwYXJhdG9yLm1kXV1cclxuICAgICAqL1xyXG4gICAgc2VnbWVudFNlcGFyYXRvcj86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqICoqVGhpcyBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkISoqIFdoZXRoZXIgdG8gc2VwYXJhdGUgdGhlIG51bWVyaWMgdmFsdWUgZnJvbSB0aGUgdGltZSB1bml0LlxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEuMCAtIEluIGZhdm9yIG9mIGB0aW1lVW5pdFNlcGFyYXRvcmAgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHNwYWNlVGltZVVuaXQ/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgZGVjaW1hbCBwYXJ0IG9mIG51bWVyaWMgdmFsdWVzLCBpbnRlbmRlZCB0byBtaW5pbWl6ZSB0aGUgcXVhbnRpdHkgb2Ygd3JpdHRlblxyXG4gICAgICogbnVtYmVycyBmb3IgdmVyeSBsYXJnZSBjb252ZXJzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBJdCB3aWxsIGVuZm9yY2UgYSBwcmVjaXNpb24gb2YgdGhlIHNwZWNpZmllZCBtYWduaXR1ZGUsIGJ1dCBvbmx5IGZvciB0aGUgZGVjaW1hbCBwYXJ0IG9mIHRoZSBudW1iZXIsIHVubGlrZVxyXG4gICAgICogW2RlY2ltYWwuanMgcHJlY2lzaW9uXShodHRwczovL21pa2VtY2wuZ2l0aHViLmlvL2RlY2ltYWwuanMvI3NkKS4gSXQgZG9lc24ndCBhcHBseSB0byBsZWFkaW5nIHplcm9zLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQ6IGAxMGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy9zaWduaWZpY2FudERpZ2l0cy5tZF1dXHJcbiAgICAgKi9cclxuICAgIHNpZ25pZmljYW50RGlnaXRzPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB3cml0dGluZyB0aW1lIHZhbHVlcyBvciB1bml0cyB3aGljaCBiYXNlZCBvbiBhcHByb3hpbWF0aW9ucywgdGhpcyBzeW1ib2wgd2lsbCBiZSBhZGRlZCBiZWZvcmUgdGhlIG51bWJlciB0b1xyXG4gICAgICogZGVtb25zdHJhdGUgdGhlIGFwcHJveGltYXRpb24sIHdoZW4gW3ZlcmJvc2VdKCN2ZXJib3NlKSBpcyBkaXNhYmxlZC4gT3RoZXJ3aXNlLCBpdHMgW3Rlcm1dKCN0ZXJtYXBwcm94aW1hdGVseSkgaXNcclxuICAgICAqIHVzZWQgaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0OiBgXCLiiYhcImAgKF9hbG1vc3QgZXF1YWwgdG9fIHN5bWJvbCkuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy9zeW1ib2xBcHByb3hpbWF0ZWx5Lm1kXV1cclxuICAgICAqL1xyXG4gICAgc3ltYm9sQXBwcm94aW1hdGVseT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gd3JpdHRpbmcgdGltZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gX0luZmluaXR5XywgdGhpcyBzeW1ib2wgd2lsbCBiZSB1c2VkIHRvIGV4cHJlc3MgaXQsIHdoZW5cclxuICAgICAqIFt2ZXJib3NlXSgjdmVyYm9zZSkgaXMgZGlzYWJsZWQuIE90aGVyd2lzZSwgaXRzIFt0ZXJtXSgjdGVybWluZmluaXRlKSBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdDogYFwi4oieXCJgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyc2V0dGluZ3Mvc3ltYm9sSW5maW5pdGUubWRdXVxyXG4gICAgICovXHJcbiAgICBzeW1ib2xJbmZpbml0ZT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gd3JpdHRpbmcgdGltZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgYSBfTmFOXyAobm90IGEgbnVtYmVyKSwgdGhpcyBzeW1ib2wgd2lsbCBiZSB1c2VkIHRvIGV4cHJlc3MgaXQsIHdoZW5cclxuICAgICAqIFt2ZXJib3NlXSgjdmVyYm9zZSkgaXMgZGlzYWJsZWQuIE90aGVyd2lzZSwgaXRzIFt0ZXJtXSgjdGVybW5hbikgaXMgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQ6IGBcIk5hTlwiYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL3N5bWJvbE5hTi5tZF1dXHJcbiAgICAgKi9cclxuICAgIHN5bWJvbE5hTj86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gd3JpdHRpbmcgdGltZSB2YWx1ZXMgb3IgdW5pdHMgd2hpY2ggYmFzZWQgb24gYXBwcm94aW1hdGlvbnMsIHRoaXMgc3RyaW5nIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoZSBudW1iZXIgdG9cclxuICAgICAqIGRlbW9uc3RyYXRlIHRoZSBhcHByb3hpbWF0aW9uLCB3aGVuIFt2ZXJib3NlXSgjdmVyYm9zZSkgaXMgZW5hYmxlZC4gT3RoZXJ3aXNlLCBpdHMgW3N5bWJvbF0oI3N5bWJvbGFwcHJveGltYXRlbHkpXHJcbiAgICAgKiBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdCBmb3IgRW5nbGlzaCAoVVMpOiBgXCJhcHByb3hpbWF0ZWx5XCJgLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyc2V0dGluZ3MvdGVybUFwcHJveGltYXRlbHkubWRdXVxyXG4gICAgICovXHJcbiAgICB0ZXJtQXBwcm94aW1hdGVseT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gd3JpdHRpbmcgdGltZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gX0luZmluaXR5XywgdGhpcyBzdHJpbmcgd2lsbCBiZSB1c2VkIHRvIGV4cHJlc3MgaXQsIHdoZW5cclxuICAgICAqIFt2ZXJib3NlXSgjdmVyYm9zZSkgaXMgZW5hYmxlZC4gT3RoZXJ3aXNlLCBpdHMgW3N5bWJvbF0oI3N5bWJvbGluZmluaXRlKSBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdCBmb3IgRW5nbGlzaCAoVVMpOiBgXCJpbmZpbml0ZVwiYC5cclxuICAgICAqXHJcbiAgICAgKiAtLS1cclxuICAgICAqXHJcbiAgICAgKiBbW2luY2x1ZGU6ZXhhbXBsZXMvdGltZXdyaXRlcnNldHRpbmdzL3Rlcm1JbmZpbml0ZS5tZF1dXHJcbiAgICAgKi9cclxuICAgIHRlcm1JbmZpbml0ZT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gd3JpdHRpbmcgdGltZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgYSBfTmFOXyAobm90IGEgbnVtYmVyKSwgdGhpcyBzdHJpbmcgd2lsbCBiZSB1c2VkIHRvIGV4cHJlc3MgaXQsIHdoZW5cclxuICAgICAqIFt2ZXJib3NlXSgjdmVyYm9zZSkgaXMgZW5hYmxlZC4gT3RoZXJ3aXNlLCBpdHMgW3N5bWJvbF0oI3N5bWJvbG5hbikgaXMgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIC0tLVxyXG4gICAgICpcclxuICAgICAqIFtbaW5jbHVkZTpleGFtcGxlcy90aW1ld3JpdGVyc2V0dGluZ3MvdGVybU5hTi5tZF1dXHJcbiAgICAgKi9cclxuICAgIHRlcm1OYU4/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqKlRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCEqKiBUaGlzIHdhcyB1c2VkIHRvIGRlZmluZSBhIGZldyBzcGVjaWFsIG51bWVyaWMgdGVybXMuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gSW4gZmF2b3Igb2YgYHZlcmJvc2VgICh3aWxsIGJlIHJlbW92ZWQgaW4gdjIpLlxyXG4gICAgICovXHJcbiAgICB0ZXJtcz86IHtcclxuICAgICAgICBhcHByb3hpbWF0ZWx5Pzogc3RyaW5nO1xyXG4gICAgICAgIGluZmluaXRlPzogc3RyaW5nO1xyXG4gICAgICAgIG5hbj86IHN0cmluZztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyB1c2VkIGFzIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIHdoZW4gdXNpbmcgZGVjaW1hbCBbbnVtZXJpYyBub3RhdGlvbnNdKCNudW1lcmljbm90YXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHQgaXMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy90aG91c2FuZHNTZXBhcmF0b3IubWRdXVxyXG4gICAgICovXHJcbiAgICB0aG91c2FuZHNTZXBhcmF0b3I/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyB0aGF0IHNlcGFyYXRlcyB0aGUgbnVtZXJpYyB2YWx1ZSBmcm9tIHRoZSB0aW1lIHVuaXQuXHJcbiAgICAgKlxyXG4gICAgICogRGVmYXVsdCBpcyBgXCIgXCJgIChzcGFjZSkuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy90aW1lVW5pdFNlcGFyYXRvci5tZF1dXHJcbiAgICAgKi9cclxuICAgIHRpbWVVbml0U2VwYXJhdG9yPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byB3cml0ZSBtb3JlIHNlbnRlbmNlcyB0byBkZXNjcmliZSBhIHRpbWUgdmFsdWUgaW5zdGVhZCBvZiB1c2luZyBzeW1ib2xzLiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSBlbmZvcmNlXHJcbiAgICAgKiBkZXNjcmlwdGl2ZSB0ZXh0IGZvciB0aW1lIHVuaXRzXHJcbiAgICAgKlxyXG4gICAgICogQWxsIHRpbWUgdW5pdHMgd2l0aG91dCBhIHN5bWJvbCBhcmUgYWxyZWFkeSB3cml0dGVuIGluIHZlcmJvc2UgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0IGlzIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICogLS0tXHJcbiAgICAgKlxyXG4gICAgICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWV3cml0ZXJzZXR0aW5ncy92ZXJib3NlLm1kXV1cclxuICAgICAqL1xyXG4gICAgdmVyYm9zZT86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqKlRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCEqKiBXaGV0aGVyIG9yIG5vdCB0byB3cml0ZSBkb3duIHRoZSBmdWxsIHVuaXQgcmVhZGFibGUgbmFtZSwgaW5zdGVhZCBvZlxyXG4gICAgICogaXRzIHN5bWJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBJbiBmYXZvciBvZiBgdmVyYm9zZWAgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHZlcmJvc2VUaW1lVW5pdD86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vI2VuZHJlZ2lvblxyXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAxOCBQZWRybyBKb3PDqSBCYXRpc3RhXHJcbk1JVCBMaWNlbnNlXHJcblxyXG5TZWUgdGhlIExJQ0VOU0UgZmlsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyoqIFtbaW5jbHVkZTpsb2NhbGl6YXRpb24ubWRdXSAqLyAvKiogKi9cclxuaW1wb3J0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5pbXBvcnQgeyBCYXNlVGltZVVuaXQsIFRpbWVVbml0RGF0YWJhc2UsIFRpbWVXcml0ZXJTZXR0aW5ncyB9IGZyb20gXCIuXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgZGVzY3JpYmVzIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzIGJlbG9uZ2luZyB0byB0aGUgc3BlY2lmaWVkIHR5cGUgcGFyYW1ldGVyIGBUYC5cclxuICpcclxuICogQHR5cGVwYXJhbSBUXHJcbiAqICAgVHlwZSBvZiBlbGVtZW50IHN0b3JlZCBieSB0aGUgb2JqZWN0IChzdHJpbmcgYnkgZGVmYXVsdCkuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIERpY3Rpb25hcnk8VCA9IHN0cmluZz4ge1xyXG4gICAgW3Byb3BlcnR5TmFtZTogc3RyaW5nXTogVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyB0aGUgaW50ZXJuYXRpb25hbGl6YXRpb24gb2YgdGhlIG1vZHVsZSwgYWx0ZXJpbmcgdGhlIHJlc3VsdHMgc3ludGhlc2l6ZWQgYnlcclxuICogW3RpbWUgd3JpdGVyc10oX2luZGV4Xy50aW1ld3JpdGVyLmh0bWwpLlxyXG4gKlxyXG4gKiBUcmFuc2xhdGlvbnMgYXJlIHN0b3JlZCBpbiBmaWxlcyBsb2NhdGVkIGF0IGBzcmMvbG9jYWxlc2AuIFRoZXNlIGZpbGVzIGNvbnRhaW4gdGhlIHRyYW5zY3JpcHRpb24gZm9yIHRpbWUgdW5pdHMgYW5kXHJcbiAqIGxpbmd1aXN0aWMgY29uZmlndXJhdGlvbnMuXHJcbiAqXHJcbiAqIC0tLVxyXG4gKlxyXG4gKiBTZWUgW0NvbnRyaWJ1dGluZzogVHJhbnNsYXRpbmddKGh0dHBzOi8vZ2l0aHViLmNvbS9wamJhdGlzdGEvdGltZWNvdW50L2Jsb2IvbWFzdGVyL0NPTlRSSUJVVElORy5tZCN0cmFuc2xhdGluZykgaWZcclxuICogeW91IHdpc2ggdG8gY29udHJpYnV0ZSB3aXRoIGEgbmV3IHRyYW5zbGF0aW9uIGZvciB0aW1lY291bnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTG9jYWxlIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYXZhaWxhYmxlRmlsZXM6IERpY3Rpb25hcnk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYXZhaWxhYmxlSWRlbnRpZmllcnM6IHN0cmluZ1tdO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2F2YWlsYWJsZUxhbmd1YWdlczogRGljdGlvbmFyeTtcclxuICAgIHByaXZhdGUgc3RhdGljIF9jdXJyZW50SWRlbnRpZmllciA9IFwiZW4tdXNcIjtcclxuICAgIHByaXZhdGUgc3RhdGljIF9zZXR0aW5nczogTG9jYWxlU2V0dGluZ3MgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGlkZW50aWZpZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gSW4gZmF2b3Igb2YgYGdldGAgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGN1cnJlbnRJZGVudGlmaWVyKCkgeyByZXR1cm4gTG9jYWxlLl9jdXJyZW50SWRlbnRpZmllcjsgfVxyXG5cclxuICAgIC8qKiBHZXRzIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudCBsb2NhbGUgd2hpY2ggcmVwcmVzZW50cyB0aGUgdHJhbnNsYXRpb24gZmlsZSBjdXJyZW50bHkgbG9hZGVkLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgc2V0dGluZ3MoKSB7IHJldHVybiBMb2NhbGUuX3NldHRpbmdzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBpZGVudGlmaWVyIChlLmcuOiBcImZyXCIgcmVwcmVzZW50cyBGcmVuY2gg4oCUIHRoZSBpbnRlcm5hdGlvbmFsIHRyYW5zbGF0aW9uIGZvciB0aGUgbGFuZ3VhZ2VcclxuICAgICAqIGFzIGEgd2hvbGU7IFwiZnItY2FcIiBpcyBGcmVuY2ggKENhbmFkYSkg4oCUIHJlcHJlc2VudHMgYSBsb2NhbGl6ZWQgdmFyaWF0aW9uIG9mIHRoZSBGcmVuY2ggbGFuZ3VhZ2UgbWVhbnQgZm9yXHJcbiAgICAgKiBDYW5hZGEpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFwiZW4tdXNcIiwgd2hpY2ggcmVwcmVzZW50cyBFbmdsaXNoIChVbml0ZWQgU3RhdGVzKSwgYSBsYW5ndWFnZSBidWlsdCBpbnRvIHRoZSBtb2R1bGUgKGRvZXNuJ3RcclxuICAgICAqIHJlcXVpcmUgYW55IHRyYW5zbGF0aW9uIGZpbGUpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCgpIHsgcmV0dXJuIExvY2FsZS5fY3VycmVudElkZW50aWZpZXI7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgZ2l2ZW4gbG9jYWxlIGlkZW50aWZpZXIgaXMgYXZhaWxhYmxlIHRvIGB0aW1lY291bnRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2NhbGVJZGVudGlmaWVyXHJcbiAgICAgKiAgIEEgbGFuZ3VhZ2UgLyByZWdpb24gbG9jYWxlIHNwZWNpZmllciAoZS5nLiBcImVuLWF1XCIsIFwicHQtYnJcIikuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIFRydWUgaWYgYSB2YWxpZCBsb2NhbGUgd2FzIHByb3ZpZGVkOyBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUobG9jYWxlSWRlbnRpZmllcjogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIGlmICghTG9jYWxlLl9hdmFpbGFibGVJZGVudGlmaWVycykge1xyXG4gICAgICAgICAgICBMb2NhbGUuX2luaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxvY2FsZUlkZW50aWZpZXIgPSBsb2NhbGVJZGVudGlmaWVyLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBMb2NhbGUubGlzdEF2YWlsYWJsZSgpLmluZGV4T2YobG9jYWxlSWRlbnRpZmllcikgPiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaXN0IHdpdGggYWxsIGxvY2FsZSBpZGVudGlmaWVycyBhdmFpbGFibGUgdG8gdGltZWNvdW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQW4gYXJyYXkgd2l0aCBhbGwgYXZhaWxhYmxlIGxvY2FsZSBpZGVudGlmaWVycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsaXN0QXZhaWxhYmxlKCkge1xyXG5cclxuICAgICAgICBpZiAoIUxvY2FsZS5fYXZhaWxhYmxlSWRlbnRpZmllcnMpIHtcclxuICAgICAgICAgICAgTG9jYWxlLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9hdmFpbGFibGVMYW5ndWFnZXMpO1xyXG4gICAgICAgIHJldHVybiBMb2NhbGUuX2F2YWlsYWJsZUlkZW50aWZpZXJzLmNvbmNhdChbXCJlblwiLCBcImVuLXVzXCJdLCBsYW5ndWFnZXMpLnNvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdGltZWNvdW50IGxhbmd1YWdlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbG9jYWxlIGlkZW50aWZpZXIgKGUuZy46IFwicHRcIiByZXByZXNlbnRzIFBvcnR1Z3Vlc2Ug4oCUIHRoZVxyXG4gICAgICogaW50ZXJuYXRpb25hbCB0cmFuc2xhdGlvbiBmb3IgdGhlIGxhbmd1YWdlIGFzIGEgd2hvbGU7IFwicHQtYnJcIiBpcyBQb3J0dWd1ZXNlIChCcmF6aWxpYW4pIOKAlCByZXByZXNlbnRzIGEgbG9jYWxpemVkXHJcbiAgICAgKiB2YXJpYXRpb24gb2YgdGhlIFBvcnR1Z3Vlc2UgbGFuZ3VhZ2UgbWVhbnQgZm9yIEJyYXppbCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvY2FsZUlkZW50aWZpZXJcclxuICAgICAqICAgQSBzdHJpbmcgd2l0aCBhIDIgbGV0dGVyIGxhbmd1YWdlIGlkZW50aWZpZXIgKFwiZW5cIiwgXCJlc1wiLCBcInB0XCIsIGV0Yy4pIC1vci0gYSA1IGxldHRlciBsYW5ndWFnZSArIHJlZ2lvblxyXG4gICAgICogICBpZGVudGlmaWVyIChcImVuLWNhXCIsIFwicHQtYW9cIikuIFRoaXMgcGFyYW1ldGVyIGlzIGNhc2UtaW5zZW5zaXRpdmUuIElmIGVtcHR5LCBpdCB3aWxsIHJlc2V0IHRoZSBsb2NhbGUgdG8gXCJlblwiLlxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSBsb2NhbGUgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldChsb2NhbGVJZGVudGlmaWVyOiBzdHJpbmcgPSBcImVuXCIpIHtcclxuXHJcbiAgICAgICAgbG9jYWxlSWRlbnRpZmllciA9IGxvY2FsZUlkZW50aWZpZXIudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gRW5nbGlzaCAoVVMpIGlzIGhhcmRjb2RlZDsgbm8gdHJhbnNsYXRpb24gZmlsZSByZXF1aXJlZFxyXG4gICAgICAgIGlmIChsb2NhbGVJZGVudGlmaWVyID09PSBcImVuXCIgfHwgbG9jYWxlSWRlbnRpZmllciA9PT0gXCJlbi11c1wiKSB7XHJcbiAgICAgICAgICAgIExvY2FsZS5fY3VycmVudElkZW50aWZpZXIgPSBcImVuLXVzXCI7XHJcbiAgICAgICAgICAgIExvY2FsZS5fc2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaXNBdmFpbGFibGUgYWxyZWFkeSBjYWxscyBfaW5pdGlhbGl6ZVxyXG4gICAgICAgIGlmICghTG9jYWxlLmlzQXZhaWxhYmxlKGxvY2FsZUlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlIGlkZW50aWZpZXJcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobG9jYWxlSWRlbnRpZmllci5sZW5ndGggPT09IDIgJiYgTG9jYWxlLl9hdmFpbGFibGVMYW5ndWFnZXMuaGFzT3duUHJvcGVydHkobG9jYWxlSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgbG9jYWxlSWRlbnRpZmllciA9IExvY2FsZS5fYXZhaWxhYmxlTGFuZ3VhZ2VzW2xvY2FsZUlkZW50aWZpZXJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGF0aFRvTG9jYWxlRmlsZSA9IExvY2FsZS5fYXZhaWxhYmxlRmlsZXNbbG9jYWxlSWRlbnRpZmllcl07XHJcblxyXG4gICAgICAgIExvY2FsZS5fY3VycmVudElkZW50aWZpZXIgPSBsb2NhbGVJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzOiBMb2NhbGVTZXR0aW5ncyA9IHJlcXVpcmUoYC4vbG9jYWxlcy8ke3BhdGhUb0xvY2FsZUZpbGV9YCkuZGVmYXVsdDtcclxuICAgICAgICBMb2NhbGUuX3NldHRpbmdzID0gc2V0dGluZ3M7XHJcblxyXG4gICAgICAgIC8vIFBhcnNpbmcgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgc2V0dGluZ3MuZGVmYXVsdFRpbWVVbml0ID0gc2V0dGluZ3MuZGVmYXVsdFRpbWVVbml0IHx8IHNldHRpbmdzLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnRpbWVVbml0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y3VybHlcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVVbml0TmFtZSBpbiBzZXR0aW5ncy50aW1lVW5pdHMpIGlmIChzZXR0aW5ncy50aW1lVW5pdHMuaGFzT3duUHJvcGVydHkodGltZVVuaXROYW1lKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gRml4ZXMgdGhlIHBsdXJhbHMgd2hlbiB0cmFuc2xhdGluZzogbnVsbHMgYXJlIG5vdCBwYXJzZWQgbGlrZSB1bmRlZmluZWRzXHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVVbml0ID0gc2V0dGluZ3MudGltZVVuaXRzW3RpbWVVbml0TmFtZSBhcyBrZXlvZiBUaW1lVW5pdERhdGFiYXNlXTtcclxuICAgICAgICAgICAgdGltZVVuaXQuY3VzdG9tUGx1cmFsID0gdGltZVVuaXQuY3VzdG9tUGx1cmFsIHx8IG51bGwgYXMgYW55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9pbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUZpbGVzOiBEaWN0aW9uYXJ5ID0ge307XHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlSWRlbnRpZmllcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VzOiBEaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsZUZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgXCJsb2NhbGVzXCIpKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbGVGaWxlIG9mIGxvY2FsZUZpbGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZUlkZW50aWZpZXIgPSBsb2NhbGVGaWxlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdHMgdGhlIGZpbGUgcGF0aCBpbnRvIDMgZ3JvdXBzOiBwYXRoLCBsYW5ndWFnZSBhbmQgcmVnaW9uICh3aGljaCBpcyBvcHRpb25hbClcclxuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGFyc2VyID0gL14oW2Etel17Mn0pLT8ofFthLXpdezJ9KVxcLnRzLy5leGVjKGxvY2FsZUlkZW50aWZpZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvY2FsZVBhcnNlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXRpbmcgcmVnaW9ubGVzcyBsYW5ndWFnZXMgYW5kIHJlZ2lvbmFsaXphdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsb2NhbGVQYXJzZXJbMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IGxvY2FsZVBhcnNlclsyXTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGAke2xhbmd1YWdlfS0ke3JlZ2lvbi5sZW5ndGggPT09IDIgPyByZWdpb24gOiBcIlwifWA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWF2YWlsYWJsZUxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eShsYW5ndWFnZSkpIHtcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUxhbmd1YWdlc1tsYW5ndWFnZV0gPSBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhdmFpbGFibGVJZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBhdmFpbGFibGVGaWxlc1tpZGVudGlmaWVyXSA9IGxvY2FsZUZpbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMb2NhbGUuX2F2YWlsYWJsZUZpbGVzID0gYXZhaWxhYmxlRmlsZXM7XHJcbiAgICAgICAgTG9jYWxlLl9hdmFpbGFibGVJZGVudGlmaWVycyA9IGF2YWlsYWJsZUlkZW50aWZpZXJzO1xyXG4gICAgICAgIExvY2FsZS5fYXZhaWxhYmxlTGFuZ3VhZ2VzID0gYXZhaWxhYmxlTGFuZ3VhZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHN0YXRpYyBjbGFzcyBMb2NhbGVcIik7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgdGhlIGNvbmZpZ3VyYXRpb25zIG9mIHRyYW5zbGF0aW9uIGZpbGVzLlxyXG4gKlxyXG4gKiBBZnRlciBhIHRyYW5zbGF0aW9uIGhhcyBiZWVuIFtzZXRdKC4uL2NsYXNzZXMvX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwjc2V0KSwgdGhlc2UgY29uZmlndXJhdGlvbnMgd2lsbCBiZSBhdmFpbGFibGVcclxuICogYXQgW0xvY2FsZS5zZXR0aW5nc10oLi4vY2xhc3Nlcy9fbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCNzZXR0aW5ncykgdG8gYmUgdXNlZCBieSBpbnRlcmVzdGVkIG9iamVjdHMgKHN1Y2ggYXNcclxuICogW3RpbWUgd3JpdGVyc10oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCkpLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVTZXR0aW5ncyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGVzZSBvcHRpb25zIGFsbG93IGZvciBkZWZhdWx0IGxpbmd1aXN0aWMgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRpbWUgdW5pdHMgb2YgdGhlIGxvY2FsZS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBJbiBmYXZvciBvZiBgZGVmYXVsdFRpbWVVbml0YCAod2lsbCBiZSByZW1vdmVkIGluIHYyKS5cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBCYXNlVGltZVVuaXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgYWJsZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBsaW5ndWlzdGljIHBhcnNpbmcgb2YgdGltZSB1bml0cy5cclxuICAgICAqXHJcbiAgICAgKiBJdCBtYXkgYmUgdXNlZCB0byBzZXQgYSBbY3VzdG9tIHBsdXJhbCBmdW5jdGlvbl0oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNjdXN0b21wbHVyYWwpIG9yIHByZXZlbnQgdGltZSB1bml0c1xyXG4gICAgICogZnJvbSBiZWluZyBbcGx1cmFsaXplZF0oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNwbHVyYWxpemUpIGJ5IGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRUaW1lVW5pdD86IEJhc2VUaW1lVW5pdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERhdGFiYXNlIG9mIHRpbWUgdW5pdCB0cmFuc2xhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZXMgdGhlIGFiaWxpdHkgdG8gc2V0IFtyZWFkYWJsZSBuYW1lc10oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNyZWFkYWJsZW5hbWUpIGFuZFxyXG4gICAgICogW3BsdXJhbHNdKF9pbmRleF8uYmFzZXRpbWV1bml0Lmh0bWwjY3VzdG9tcGx1cmFsKSBvZiB0cmFuc2xhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHRpbWVVbml0cz86IFRpbWVVbml0RGF0YWJhc2U8QmFzZVRpbWVVbml0PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyYXRpb25zIGFzc2lnbmVkIHRvIFt0aW1lIHdyaXRlcnNdKC4uL2NsYXNzZXMvX2luZGV4Xy50aW1ld3JpdGVyLmh0bWwpLlxyXG4gICAgICpcclxuICAgICAqIENvbnRhaW5zIGxpbmd1aXN0aWMgYW5kIG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzIGFwcGxpZWQgdG8gYWxsXHJcbiAgICAgKiBbY291bnRkb3duXSguLi9jbGFzc2VzL19pbmRleF8udGltZXdyaXRlci5odG1sI2NvdW50ZG93bikgYW5kIFt3cml0ZV0oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCN3cml0ZSlcclxuICAgICAqIGNhbGxzICh1bmxlc3Mgb3ZlcnJpZGVuIGJ5IHRoZSBvYmplY3Qgb3IgbWV0aG9kKS5cclxuICAgICAqL1xyXG4gICAgd3JpdGVyT3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGV4dGVuZHMgZnJvbSBbQmFzZVRpbWVVbml0XShfaW5kZXhfLmJhc2V0aW1ldW5pdC5odG1sKSB3aXRoIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhhdCBpdCBlbmZvcmNlc1xyXG4gKiBpdHMgW3JlYWRhYmxlIG5hbWVdKCNyZWFkYWJsZW5hbWUpIHRvIGJlIG5vdC1vcHRpb25hbCwgaW4gb3JkZXIgdG8gYmV0dGVyIGNoYXJhY3Rlcml6ZSBhIHBhcnNlZCB0aW1lIHVuaXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBVbm5lY2Vzc2FyeSBpbnRlcmZhY2UgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsaXplZFRpbWVVbml0IGV4dGVuZHMgQmFzZVRpbWVVbml0IHtcclxuXHJcbiAgICAvKiogVGhpcyB2ZXJzaW9uIG9mIHRoZSBwcm9wZXJ0eSBpcyBub3Qgb3B0aW9uYWwuICovXHJcbiAgICByZWFkb25seSByZWFkYWJsZU5hbWU6IHN0cmluZztcclxufVxyXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAxOCBQZWRybyBKb3PDqSBCYXRpc3RhXHJcbk1JVCBMaWNlbnNlXHJcblxyXG5TZWUgdGhlIExJQ0VOU0UgZmlsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyoqIFtbaW5jbHVkZTp1dGlscy5tZF1dICovIC8qKiAqL1xyXG5pbXBvcnQgeyBEZWNpbWFsIH0gZnJvbSBcImRlY2ltYWwuanNcIjtcclxuaW1wb3J0IHsgVGltZSB9IGZyb20gXCIuXCI7XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWUgYWNjb3JkaW5nIHRvIGBwcm9jZXNzYC5cclxuICpcclxuICogQHJldHVyblxyXG4gKiAgIFtCaWcgZGVjaW1hbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVjaW1hbC5qcykgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgdGltZSwgaW4gbmFub3NlY29uZHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvY2Vzc1RpbWUoKSB7XHJcbiAgICBjb25zdCBwcmVjaXNlVGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcbiAgICByZXR1cm4gKG5ldyBEZWNpbWFsKHByZWNpc2VUaW1lWzBdKSkudGltZXMoXCIxZSs5XCIpLmFkZChwcmVjaXNlVGltZVsxXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb3VudHMgdGhlIGR1cmF0aW9uIG9mIHJ1bnRpbWUgb3BlcmF0aW9ucy5cclxuICpcclxuICogQW4gaW5zdGFuY2Ugb2YgW0Jhc2ljVGltZXJdKCMpIGlzIGFibGUgdG8gY291bnQgdGhlIGR1cmF0aW9uIGJldHdlZW4gaXRzIFtzdGFydF0oI3N0YXJ0KSBhbmQgW3N0b3BdKCNzdG9wKS5cclxuICogRXZlcnkgc3RhcnQtc3RvcCBjeWNsZSByZXNldHMgdGhlIG9iamVjdCB0byBpdHMgZGVmYXVsdCBzdGF0ZS5cclxuICpcclxuICogU2VlIFtUaW1lcl0oX3V0aWxzXy50aW1lci5odG1sKSBpZiB5b3UgbmVlZCBwYXVzaW5nIGFuZCBbU3RvcFdhdGNoXShfdXRpbHNfLnN0b3B3YXRjaC5odG1sKSBmb3IgdGltZSBzZWdtZW50YXRpb25cclxuICogKGxhcHMpLlxyXG4gKlxyXG4gKiAtLS1cclxuICpcclxuICogW1tpbmNsdWRlOmV4YW1wbGVzL2Jhc2ljdGltZXIubWRdXVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJhc2ljVGltZXIge1xyXG5cclxuICAgIC8qKiBQcm90ZWN0ZWQgZmllbGQgd2l0aCB0aGUgdGltZSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG1vbWVudCB0aGUgdGltZXIgc3RhcnRlZC4gKi9cclxuICAgIHByb3RlY3RlZCBfc3RhcnRUaW1lPzogRGVjaW1hbDtcclxuXHJcbiAgICAvKiogR2V0cyB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgdGltZXIgdW50aWwgX25vd18uICovXHJcbiAgICBwdWJsaWMgZ2V0IGVsYXBzZWRUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsYXBzZWRUaW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldHMgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcgKGl0IHdhcyBbc3RhcnRlZF0oI3N0YXJ0KSBhbmQgbm90IHlldCBbc3RvcHBlZF0oI3N0b3ApKS4gKi9cclxuICAgIHB1YmxpYyBnZXQgaXNSdW5uaW5nKCkgeyByZXR1cm4gISF0aGlzLl9zdGFydFRpbWU7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcHJvdGVjdGVkIHByb3BlcnR5IHVzZWZ1bCB3aGVuIG92ZXJyaWRpbmcgdGhlIHRpbWVycyBpdCBjaGFuZ2VzIHRoZSBvdXRwdXQgb2ZcclxuICAgICAqIFt0aW1lciBlcnJvcnNdKF91dGlsc18udGltZXJlcnJvci5odG1sKSBpbiBvcmRlciB0byByZXByZXNlbnQgdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0IHRpbWVyRXJyb3JUeXBlKCkgeyByZXR1cm4gXCJ0aW1lclwiOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgW0Jhc2ljVGltZXJdKCMpIGNsYXNzLCBvcHRpb25hbGx5IGF1dG8tc3RhcnRpbmcgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF1dG9TdGFydFxyXG4gICAgICogICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRpbWVyIHdpbGwgaW1tZWRpYXRlbHkgc3RhcnQ7IGRlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihhdXRvU3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG5cclxuICAgICAgICBpZiAoYXV0b1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgdG8gY291bnQgdGltZSwgc2V0dGluZyB0aGUgW3N0YXJ0IHRpbWVdKCNzdGFydHRpbWUpIHRvIGEgdmFsdWUgZXF1aXZhbGVudCB0byBfbm93Xy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIFRpbWUgdGhhdCByZXByZXNlbnRzIF9ub3dfIChvciBiZXR0ZXIgeWV0LCB0aGUgbW9tZW50IHRoZSB0aW1lciBoYXMgc3RhcnRlZCkuXHJcbiAgICAgKiBAdGhyb3dzIFRpbWVyRXJyb3JcclxuICAgICAqICAgV2hlbiB0aGUgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhcnQoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgVGltZXJFcnJvci50aW1lckFscmVhZHlTdGFydGVkKHRoaXMudGltZXJFcnJvclR5cGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2V0UHJvY2Vzc1RpbWUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lIGFzIERlY2ltYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIHRoZSB0aW1lIGNvdW50aW5nLCByZXR1cm5pbmcgdGhlIHRvdGFsIGVsYXBzZWQgdGltZSBhbmQgcmVzZXR0aW5nIHRoZSBvYmplY3QgdG8gaXRzIGRlZmF1bHQgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHRpbWUgd2l0aCB0aGUgdG90YWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzIHNwZW50IGJldHdlZW4gW3N0YXJ0XSgjc3RhcnQpIGFuZCBfbm93Xy5cclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSB0aW1lciBoYXMgbm90IHlldCBzdGFydGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RvcCgpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgVGltZXJFcnJvci50aW1lck5vdFN0YXJ0ZWQodGhpcy50aW1lckVycm9yVHlwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXN1bHRUaW1lID0gbmV3IFRpbWUoZ2V0UHJvY2Vzc1RpbWUoKS5taW51cyh0aGlzLl9zdGFydFRpbWUpKTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdGVjdGVkIGFsaWFzIHRvIFtlbGFwc2VkVGltZV0oI2VsYXBzZWR0aW1lKS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldEVsYXBzZWRUaW1lKCkge1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpbWUoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRpbWUoZ2V0UHJvY2Vzc1RpbWUoKS5taW51cyh0aGlzLl9zdGFydFRpbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3RlY3RlZCBhbGlhcyB0byBbaXNSdW5uaW5nXSgjaXNSdW5uaW5nKS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldElzUnVubmluZygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9zdGFydFRpbWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHR5cGUgb2YgZnVuY3Rpb24gaXMgdXNlZCBieSBbc3RvcHdhdGNoZXNdKC4uL2NsYXNzZXMvX3V0aWxzXy5zdG9wd2F0Y2guaHRtbCkgdG8gcmV0dXJuIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogdG8gdGhlIGNhbGxlcnMgb2YgW3N0b3BdKC4uL2NsYXNzZXMvX3V0aWxzXy5zdG9wd2F0Y2guaHRtbCNzdG9wKVxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU3RvcFdhdGNoRGV0YWlsID0gKHBhcnRpYWxUaW1lczogVGltZVtdLCBlcnJvcjogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuLyoqXHJcbiAqIENvdW50cyB0aGUgZHVyYXRpb24gb2YgcnVudGltZSBvcGVyYXRpb25zLCB3aXRoIHBhdXNpbmcgY2FwYWJpbGl0aWVzLlxyXG4gKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiBbVGltZXJdKCMpIGlzIGFibGUgdG8gY291bnQgdGhlIGR1cmF0aW9uIGJldHdlZW4gaXRzIFtzdGFydF0oI3N0YXJ0KSBhbmQgW3N0b3BdKCNzdG9wKSwgYXMgd2VsbCBhc1xyXG4gKiBbcGF1c2luZ10oI3BhdXNlKSwgd2hpY2ggdGVtcG9yYXJpbHkgc3RvcHMgdGhlIHRpbWUgY291bnRpbmcuIEV2ZXJ5IHN0YXJ0LXN0b3AgY3ljbGUgcmVzZXRzIHRoZSBvYmplY3QgdG8gaXRzXHJcbiAqIGRlZmF1bHQgc3RhdGUuXHJcbiAqXHJcbiAqIFNlZSBbQmFzaWNUaW1lcl0oX3V0aWxzXy5iYXNpY3RpbWVyLmh0bWwpIGZvciBhIHNpbXBsZXIgdGltZXIgaW1wbGVudGF0aW9uIChsZXNzIG92ZXJoZWFkKSBhbmRcclxuICogW1N0b3BXYXRjaF0oX3V0aWxzXy5zdG9wd2F0Y2guaHRtbCkgZm9yIHRpbWUgc2VnbWVudGF0aW9uLlxyXG4gKlxyXG4gKiAtLS1cclxuICpcclxuICogW1tpbmNsdWRlOmV4YW1wbGVzL3RpbWVyLm1kXV1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUaW1lciBleHRlbmRzIEJhc2ljVGltZXIge1xyXG5cclxuICAgIC8qKiBQcm90ZWN0ZWQgZmllbGQgd2l0aCB0aGUgdGltZSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG1vbWVudCB0aGUgcGF1c2luZyBzdGFydGVkLiAqL1xyXG4gICAgcHJvdGVjdGVkIF9wYXVzZVN0YXJ0VGltZT86IERlY2ltYWw7XHJcblxyXG4gICAgLyoqIFByb3RlY3RlZCBmaWVsZCB3aXRoIHRoZSB0aW1lIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgc3VtIG9mIGFsbCBwcmV2aW91cyBwYXVzZSB0aW1lcy4gKi9cclxuICAgIHByb3RlY3RlZCBfcGF1c2VUaW1lU3VtID0gbmV3IERlY2ltYWwoMCk7XHJcblxyXG4gICAgLyoqIEdldHMgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgdGltZXIgd2FzIFtwYXVzZWRdKCNwYXVzZSkuICovXHJcbiAgICBwdWJsaWMgZ2V0IGVsYXBzZWRQYXVzZVRpbWUoKSB7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fcGF1c2VTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lKDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lKGdldFByb2Nlc3NUaW1lKCkubWludXModGhpcy5fcGF1c2VTdGFydFRpbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0cyB0aGUgdG90YWwgYW1vdW50IG9mIHRpbWUgdGhlIG9iamVjdCBzcGVudCBbcGF1c2VkXSgjcGF1c2UpIGR1cmluZyB0aGUgY3VycmVudCBzdGFydC1zdG9wIGN5Y2xlLiAqL1xyXG4gICAgcHVibGljIGdldCB0b3RhbFBhdXNlVGltZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGFwc2VkUGF1c2VUaW1lLmFkZCh0aGlzLl9wYXVzZVRpbWVTdW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgdGltZXIgdW50aWwgX25vd18uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHZhbHVlIG9mIHRoaXMgdGltZSB3aWxsIHJlbWFpbiB1bmNoYW5nZWQgd2hlbiB0aGUgdGltZXIgaXMgW3BhdXNlZF0oI3N0b3ApLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGVsYXBzZWRUaW1lKCkge1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpbWUoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0b3RhbEVsYXBzZWRUaW1lID0gc3VwZXIuZ2V0RWxhcHNlZFRpbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9wYXVzZVN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG90YWxFbGFwc2VkVGltZS5zdWJ0cmFjdCh0aGlzLl9wYXVzZVRpbWVTdW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgcGF1c2VkLCBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZWxhcHNlZCB0aW1lIGFuZCB0aGUgcGF1c2VkIHRpbWVcclxuICAgICAgICByZXR1cm4gdG90YWxFbGFwc2VkVGltZVxyXG4gICAgICAgICAgICAuYWRkKHRoaXMuX3N0YXJ0VGltZSlcclxuICAgICAgICAgICAgLnN1YnRyYWN0KHRoaXMuX3BhdXNlU3RhcnRUaW1lKVxyXG4gICAgICAgICAgICAuc3VidHJhY3QodGhpcy5fcGF1c2VUaW1lU3VtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0cyB3aGV0aGVyIHRoZSB0aW1lciBpcyBwYXVzZWQuICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzUGF1c2VkKCkgeyByZXR1cm4gISF0aGlzLl9wYXVzZVN0YXJ0VGltZTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZyAoaXQgd2FzIFtzdGFydGVkXSgjc3RhcnQpIGFuZCBub3QgeWV0IFtzdG9wcGVkXSgjc3RvcCkpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgKipub3QgaW5mbHVlbmNlZCBieSBbcGF1c2VzXSgjcGF1c2UpKiosIGkuZS4gaXQgd2lsbCByZXR1cm4gdHJ1ZSBldmVuIHdoZW4gcGF1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzUnVubmluZygpIHsgcmV0dXJuIHN1cGVyLmdldElzUnVubmluZygpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50cyB0aGUgb2JqZWN0IGZyb20gY291bnRpbmcgdGhlIHRpbWUgdW50aWwgaXQgaXMgW3Jlc3VtZWRdKCNyZXN1bWUpLlxyXG4gICAgICpcclxuICAgICAqIEJvdGggdGhlIFtlbGFwc2VkIHRpbWVdKCNlbGFwc2VkdGltZSkgYW5kIHRoZSB0aW1lIHJlc3VsdGluZyBmcm9tIFtzdG9wXSgjc3RvcCkgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGUgcGF1c2UsXHJcbiAgICAgKiBidXQgW3BhdXNlZFRpbWVdKCNwYXVzZWR0aW1lKSBhbmQgW3RvdGFsUGF1c2VUaW1lXSgjdG90YWxwYXVzZWR0aW1lKSB3aWxsLlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSB0aW1lciBoYXMgbm90IHlldCBzdGFydGVkIC1vci0gaXQgaXMgYWxyZWFkeSBwYXVzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwYXVzZSgpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBUaW1lckVycm9yLnRpbWVyTm90U3RhcnRlZCh0aGlzLnRpbWVyRXJyb3JUeXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9wYXVzZVN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBUaW1lckVycm9yLnRpbWVyQWxyZWFkeVBhdXNlZCh0aGlzLnRpbWVyRXJyb3JUeXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnRUaW1lID0gZ2V0UHJvY2Vzc1RpbWUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGF1c2VTdGFydFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN1bWVzIHRoZSB0aW1lIGNvdW50aW5nLCByZWNvdmVyaW5nIHRoZSBvYmplY3QgZnJvbSBhIFtwYXVzZWRdKCNwYXVzZSkgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBUaGUgYW1vdW50IG9mIHRpbWUgdGhlIHRpbWVyIHNwZW50IHBhdXNlZC5cclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSB0aW1lciBoYXMgbm90IHlldCBzdGFydGVkIC1vci0gaXQgaXMgbm90IHBhdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc3VtZSgpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBUaW1lckVycm9yLnRpbWVyTm90U3RhcnRlZCh0aGlzLnRpbWVyRXJyb3JUeXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fcGF1c2VTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgVGltZXJFcnJvci50aW1lck5vdFBhdXNlZCh0aGlzLnRpbWVyRXJyb3JUeXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhdXNlZFRpbWUgPSB0aGlzLmVsYXBzZWRQYXVzZVRpbWU7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydFRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VUaW1lU3VtID0gdGhpcy5fcGF1c2VUaW1lU3VtLmFkZChwYXVzZWRUaW1lLmJpZ1ZhbHVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lKHBhdXNlZFRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5kcyB0aGUgdGltZSBjb3VudGluZywgcmV0dXJuaW5nIHRoZSB0b3RhbCBlbGFwc2VkIHRpbWUgYW5kIHJlc2V0dGluZyB0aGUgb2JqZWN0IHRvIGl0cyBkZWZhdWx0IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSB0aW1lciBpcyBbcGF1c2VkXSgjcGF1c2UpLCB0aGVyZSAqKmlzIG5vIG5lZWQqKiB0byBbcmVzdW1lXSgjcmVzdW1lKSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIEEgdGltZSB3aXRoIHRoZSB0b3RhbCBhbW91bnQgb2YgbmFub3NlY29uZHMgc3BlbnQgYmV0d2VlbiBbc3RhcnRdKCNzdGFydCkgYW5kIF9ub3dfLlxyXG4gICAgICogQHRocm93cyBUaW1lckVycm9yXHJcbiAgICAgKiAgIFdoZW4gdGhlIHRpbWVyIGhhcyBub3QgeWV0IHN0YXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdG9wKCkge1xyXG5cclxuICAgICAgICBjb25zdCB0b3RhbFRpbWUgPSBzdXBlci5zdG9wKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9wYXVzZVN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdG90YWxQYXVzZVRpbWUgPSB0aGlzLl9wYXVzZVRpbWVTdW07XHJcbiAgICAgICAgdGhpcy5fcGF1c2VUaW1lU3VtID0gbmV3IERlY2ltYWwoMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0b3RhbFRpbWUuc3VidHJhY3QodG90YWxQYXVzZVRpbWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ291bnRzIHRoZSBkdXJhdGlvbiBvZiBydW50aW1lIG9wZXJhdGlvbnMsIHdpdGggcGF1c2luZyBjYXBhYmlsaXRpZXMgYW5kIHRpbWUgc2VnbWVudGF0aW9uIOKAlCB3aGljaCBhcmUgYXJiaXRyeVxyXG4gKiBkaXZpc2lvbnMgb2YgdGltZS5cclxuICpcclxuICogQW4gaW5zdGFuY2Ugb2YgW1N0b3BXYXRjaF0oIykgaXMgYWJsZSB0byBjb3VudCB0aGUgZHVyYXRpb24gYmV0d2VlbiBpdHMgW3N0YXJ0XSgjc3RhcnQpIGFuZCBbc3RvcF0oI3N0b3ApLFxyXG4gKiBbcGF1c2luZ10oI3BhdXNlKSwgd2hpY2ggdGVtcG9yYXJpbHkgc3RvcHMgdGhlIHRpbWUgY291bnRpbmcsIGFuZCBbY3JlYXRlIGxhcHNdKCNlbmRsYXApLCB3aGljaCBzcGxpdHMgdGhlXHJcbiAqIHN0b3B3YXRjaCAuIEV2ZXJ5IHN0YXJ0LXN0b3AgY3ljbGUgcmVzZXRzIHRoZSBvYmplY3QgdG8gaXRzIGRlZmF1bHQgc3RhdGUuXHJcbiAqXHJcbiAqIFNlZSBbQmFzaWNUaW1lcl0oX3V0aWxzXy5iYXNpY3RpbWVyLmh0bWwpIGFuZCBbVGltZXJdKF91dGlsc18udGltZXIuaHRtbCkgZm9yIHNpbXBsZXIgdGltZXIgaW1wbGVudGF0aW9ucyAobGVzc1xyXG4gKiBvdmVyaGVhZCkuXHJcbiAqXHJcbiAqIC0tLVxyXG4gKlxyXG4gKiBbW2luY2x1ZGU6ZXhhbXBsZXMvc3RvcHdhdGNoLm1kXV1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdG9wV2F0Y2ggZXh0ZW5kcyBUaW1lciB7XHJcblxyXG4gICAgLyoqIFByb3RlY3RlZCBmaWVsZCB3aXRoIHRoZSBhcnJheSBvZiBwYXJ0aWFsIGxhcCB0aW1lIHZhbHVlcy4gKi9cclxuICAgIHByb3RlY3RlZCBfbGFwUGFydGlhbFRpbWVzOiBEZWNpbWFsW10gPSBbXTtcclxuXHJcbiAgICAvKiogUHJvdGVjdGVkIGZpZWxkIHdpdGggdGhlIHRpbWUgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBtb21lbnQgdGhlIGxhcCBzdGFydGVkLiAqL1xyXG4gICAgcHJvdGVjdGVkIF9sYXBTdGFydFRpbWU/OiBEZWNpbWFsO1xyXG5cclxuICAgIC8qKiBHZXRzIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGxhcCB1bnRpbCBfbm93Xy4gKi9cclxuICAgIHB1YmxpYyBnZXQgY3VycmVudExhcEVsYXBzZWRUaW1lKCkge1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2xhcFN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpbWUoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFRpbWUoZ2V0UHJvY2Vzc1RpbWUoKS5taW51cyh0aGlzLl9sYXBTdGFydFRpbWUpLm1pbnVzKHRoaXMuX3BhdXNlU3RhcnRUaW1lIHx8IDApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbWUgcmVwcmVzZW50aW5nIHRoZSBtb21lbnQgdGhlIGN1cnJlbnQgbGFwIHN0YXJ0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gVW5uZWNlc3NhcnkgcHJvcGVydHkgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY3VycmVudExhcFN0YXJ0VGltZSgpIHsgcmV0dXJuIG5ldyBUaW1lKHRoaXMuX2xhcFN0YXJ0VGltZSB8fCAwKTsgfVxyXG5cclxuICAgIC8qKiBHZXRzIHRoZSBudW1iZXIgb2YgbGFwcyBjdXJyZW50bHkgc3RvcmVkIGF0IHRoZSBzdG9wd2F0Y2guICovXHJcbiAgICBwdWJsaWMgZ2V0IGxhcENvdW50KCkgeyByZXR1cm4gdGhpcy5wYXJ0aWFsVGltZXMubGVuZ3RoICsgMTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBhcnJheSB3aXRoIHRpbWUgcGFydGlhbHMgb2YgdGhlIGxhcHMgb2YgdGhlIHN0b3B3YXRjaCwgZXhjbHVkaW5nIHRoZSBbY3VycmVudF0oI2N1cnJlbnRsYXBlbGFwc2VkdGltZSkuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gSW4gZmF2b3Igb2YgYHBhcnRpYWxUaW1lc2AgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbGFwUGFydGlhbHMoKSB7IHJldHVybiB0aGlzLl9sYXBQYXJ0aWFsVGltZXMubWFwKHZhbHVlID0+IG5ldyBUaW1lKHZhbHVlKSk7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gYXJyYXkgd2l0aCB0aW1lIHBhcnRpYWxzIG9mIHRoZSBsYXBzIG9mIHRoZSBzdG9wd2F0Y2gsIGluY2x1ZGluZyB0aGUgW2N1cnJlbnRdKCNjdXJyZW50bGFwZWxhcHNlZHRpbWUpLlxyXG4gICAgICogVGhlIHN1bSBvZiB0aGVzZSB0aW1lcyBpcyBlcXVpdmFsZW50IHRvIHRoZSB0b3RhbCBlbGFwc2VkIHRpbWUgb2YgdGhlIHN0b3B3YXRjaC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwYXJ0aWFsVGltZXMoKSB7XHJcbiAgICAgICAgY29uc3QgcGFydGlhbFRpbWVzID0gdGhpcy5fbGFwUGFydGlhbFRpbWVzLm1hcCh2YWx1ZSA9PiBuZXcgVGltZSh2YWx1ZSkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGFwU3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsVGltZXMuY29uY2F0KHRoaXMuY3VycmVudExhcEVsYXBzZWRUaW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJ0aWFsVGltZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldHMgdGhlIG5hbWUgdXNlZCBvbiBzdG9wd2F0Y2ggZXJyb3JzLiAqL1xyXG4gICAgcHJvdGVjdGVkIGdldCB0aW1lckVycm9yVHlwZSgpIHsgcmV0dXJuIFwic3RvcHdhdGNoXCI7IH1cclxuXHJcbiAgICAvKiogQWxpYXMgdG8gW2VuZExhcF0oI2VuZGxhcCkuICovXHJcbiAgICBwdWJsaWMgY3JlYXRlVGltZVNlZ21lbnQoKSB7IHJldHVybiB0aGlzLmVuZExhcCgpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2hlcyB0aGUgY3VycmVudCBsYXAgYW5kIHN0YXJ0cyBhIG5ldyBvbmUuIFRoaXMgd2lsbCBhZGQgYSBuZXcgZW50cnkgdG8gW3BhcnRpYWwgdGltZXNdKCNwYXJ0aWFsdGltZXMpIGFuZFxyXG4gICAgICogc3RhcnQgY291bnRpbmcgdGltZSBmb3IgdGhlIG5ldyBsYXAuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoZSBmaXJzdCBsYXAgKiphbHdheXMqKiBzdGFydCBpbiBwYXJhbGxlbCB3aXRoIHRoZSBzdG9wd2F0Y2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBUaGUgcGFydGlhbCB0aW1lIG9mIHRoZSBmaW5pc2hlZCBsYXAgKGVsYXBzZWQgdGltZSBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGFwIHVudGlsIF9ub3dfKS5cclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSBzdG9wd2F0Y2ggaGFzIG5vdCB5ZXQgc3RhcnRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVuZExhcCgpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXBTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgVGltZXJFcnJvci50aW1lck5vdFN0YXJ0ZWQodGhpcy50aW1lckVycm9yVHlwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBub3cgPSBnZXRQcm9jZXNzVGltZSgpO1xyXG4gICAgICAgIGxldCB0b3RhbCA9IG5vdy5taW51cyh0aGlzLl9sYXBTdGFydFRpbWUpO1xyXG5cclxuICAgICAgICAvLyBBZGp1c3QgdGhlIHBhdXNlIHN0YXJ0IHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBsYXBcclxuICAgICAgICBpZiAodGhpcy5fcGF1c2VTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF1c2VUaW1lID0gbm93Lm1pbnVzKHRoaXMuX3BhdXNlU3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fcGF1c2VUaW1lU3VtID0gdGhpcy5fcGF1c2VUaW1lU3VtLmFkZChwYXVzZVRpbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0VGltZSA9IG5vdztcclxuXHJcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwubWludXMocGF1c2VUaW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xhcFN0YXJ0VGltZSA9IG5vdztcclxuICAgICAgICB0aGlzLl9sYXBQYXJ0aWFsVGltZXMucHVzaCh0b3RhbCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lKHRvdGFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyB0byBjb3VudCB0aW1lLCBzZXR0aW5nIHRoZSBbc3RhcnQgdGltZV0oI3N0YXJ0dGltZSkgdG8gYSB2YWx1ZSBlcXVpdmFsZW50IHRvIF9ub3dfLiBUaGlzIGFsc28gc3RhcnRzIHRoZVxyXG4gICAgICogZmlyc3QgbGFwIG9mIHRoZSBzdG9wd2F0Y2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBUaW1lIHRoYXQgcmVwcmVzZW50cyBfbm93XyAob3IgYmV0dGVyIHlldCwgdGhlIG1vbWVudCB0aGUgc3RvcHdhdGNoIGhhcyBzdGFydGVkKS5cclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSBzdG9wd2F0Y2ggaXMgYWxyZWFkeSBydW5uaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5fbGFwU3RhcnRUaW1lID0gc3VwZXIuc3RhcnQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGFwU3RhcnRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5kcyB0aGUgdGltZSBjb3VudGluZywgcmV0dXJuaW5nIHRoZSB0b3RhbCBlbGFwc2VkIHRpbWUgKHN1bSBvZiBhbGwgbGFwIHBhcnRpYWxzKSBhbmQgcmVzZXR0aW5nIHRoZSBvYmplY3QgdG9cclxuICAgICAqIGl0cyBkZWZhdWx0IHN0YXRlLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGxhc3QgY3JlYXRlZCBsYXAhXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHN0b3B3YXRjaCBpcyBbcGF1c2VkXSgjcGF1c2UpLCB0aGVyZSAqKmlzIG5vIG5lZWQqKiB0byBbcmVzdW1lXSgjcmVzdW1lKSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGV0YWlsXHJcbiAgICAgKiAgIEEgY2xvc3VyZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGFkZGl0aW9uYWwgZGF0YSBhYm91dCB0aGUgc3RvcHdhdGNoLiBUaGlzIGluZm9ybWF0aW9uIHdvdWxkIG90aGVyd2lzZSBiZVxyXG4gICAgICogICBsb3N0IGFmdGVyIHRoZSBtZXRob2QgaXMgY29tcGxldGVkLlxyXG4gICAgICogQHJldHVyblxyXG4gICAgICogICBBIHRpbWUgd2l0aCB0aGUgdG90YWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzIHNwZW50IGJldHdlZW4gW3N0YXJ0XSgjc3RhcnQpIGFuZCBfbm93Xy5cclxuICAgICAqIEB0aHJvd3MgVGltZXJFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSBzdG9wd2F0Y2ggaGFzIG5vdCB5ZXQgc3RhcnRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0b3AoZGV0YWlsPzogU3RvcFdhdGNoRGV0YWlsKSB7XHJcbiAgICAgICAgY29uc3QgcGFydGlhbHMgPSB0aGlzLnBhcnRpYWxUaW1lcztcclxuICAgICAgICBjb25zdCB0b3RhbFRpbWUgPSBzdXBlci5zdG9wKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhcFBhcnRpYWxUaW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xhcFN0YXJ0VGltZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKCFkZXRhaWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVGltZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdW0gPSBuZXcgRGVjaW1hbCgwKTtcclxuICAgICAgICBwYXJ0aWFscy5mb3JFYWNoKHBhcnRpYWwgPT4gc3VtID0gc3VtLmFkZChwYXJ0aWFsLmJpZ1ZhbHVlKSk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBlcnJvciBpcyBjYWxjdWxhdGVkIGJ5IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHN0b3AgdmFsdWUgYW5kIHRoZSBzdW0gb2YgcGFydGlhbCB0aW1lc1xyXG4gICAgICAgIGRldGFpbChwYXJ0aWFscywgc3VtLm1pbnVzKHRvdGFsVGltZS5iaWdWYWx1ZSkuYWJzKCkudG9OdW1iZXIoKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0b3RhbFRpbWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBvcGVyYXRpb24gb2YgW2Jhc2ljIHRpbWVyc10oLi4vY2xhc3Nlcy9faW5kZXhfLmJhc2ljdGltZXIuaHRtbCksXHJcbiAqIFt0aW1lcnNdKC4uL2NsYXNzZXMvX2luZGV4Xy50aW1lci5odG1sKSBhbmQgW3N0b3B3YXRjaGVzXSguLi9jbGFzc2VzL19pbmRleF8uc3RvcHdhdGNoLmh0bWwpLlxyXG4gKlxyXG4gKiBJdCBoYXMgc3RhdGljIG1ldGhvZHMgYWJsZSB0byBjcmVhdGUgW1RpbWVyRXJyb3JdKCMpIGluc3RhbmNlcyB3aXRoIGdlbmVyaWMgZXJyb3IgbWVzc2FnZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGltZXJFcnJvciBleHRlbmRzIEVycm9yIHtcclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBbVGltZXJFcnJvcl0oIykgaW5zdGFuY2UgZm9yIHdoZW4gdGhlIHRpbWVyIGlzIGFscmVhZHkgcGF1c2VkLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB0aW1lckFscmVhZHlQYXVzZWQodHlwZTogc3RyaW5nID0gXCJ0aW1lclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lckVycm9yKGBUaGUgJHt0eXBlfSBpcyBhbHJlYWR5IHBhdXNlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IFtUaW1lckVycm9yXSgjKSBpbnN0YW5jZSBmb3Igd2hlbiB0aGUgdGltZXIgaGFzIGFscmVhZHkgc3RhcnRlZC4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZXJBbHJlYWR5U3RhcnRlZCh0eXBlOiBzdHJpbmcgPSBcInRpbWVyXCIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyRXJyb3IoYFRoZSAke3R5cGV9IGhhcyBhbHJlYWR5IHN0YXJ0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBbVGltZXJFcnJvcl0oIykgaW5zdGFuY2UgZm9yIHdoZW4gdGhlIHRpbWVyIGlzIG5vdCBwYXVzZWQuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHRpbWVyTm90UGF1c2VkKHR5cGU6IHN0cmluZyA9IFwidGltZXJcIikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZXJFcnJvcihgVGhlICR7dHlwZX0gaXMgbm90IHBhdXNlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IFtUaW1lckVycm9yXSgjKSBpbnN0YW5jZSBmb3Igd2hlbiB0aGUgdGltZXIgaGFzIG5vdCB5ZXQgc3RhcnRlZC4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZXJOb3RTdGFydGVkKHR5cGU6IHN0cmluZyA9IFwidGltZXJcIikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZXJFcnJvcihgVGhlICR7dHlwZX0gaGFzIG5vdCB5ZXQgc3RhcnRlZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXRzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbVGltZXJFcnJvcl0oIykgY2xhc3MsIHVzZWQgYnkgdGhlIGJ1aWx0LWluIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC4gKi9cclxuICAgIHB1YmxpYyBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7IHJldHVybiBcIlRpbWVyRXJyb3JcIjsgfVxyXG59XHJcbiJdfQ=="}