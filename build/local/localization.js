"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*! ****************************************************************************
Copyright (c) 2017-2018 Pedro José Batista
MIT License

See the LICENSE file for more information.
***************************************************************************** */
/** [[include:localization.md]] */ /** */
const fs = require("fs");
const path = require("path");
/**
 * This class manages the internationalization of the module, altering the results synthesized by
 * [time writers](_index_.timewriter.html).
 *
 * Translations are stored in files located at `src/locales`. These files contain the transcription for time units and
 * linguistic configurations.
 *
 * ---
 *
 * See [Contributing: Translating](https://github.com/pjbatista/timecount/blob/master/CONTRIBUTING.md#translating) if
 * you wish to contribute with a new translation for timecount.
 */
class Locale {
    constructor() { throw new Error("Cannot initialize static class Locale"); }
    /**
     * Gets the current locale identifier.
     *
     * @deprecated Since v1.1.0 - In favor of `get` (will be removed in v2).
     */
    static get currentIdentifier() { return Locale._currentIdentifier; }
    /** Gets the configuration for the current locale which represents the translation file currently loaded. */
    static get settings() { return Locale._settings; }
    /**
     * Gets the current locale identifier (e.g.: "fr" represents French — the international translation for the language
     * as a whole; "fr-ca" is French (Canada) — represents a localized variation of the French language meant for
     * Canada).
     *
     * The default is "en-us", which represents English (United States), a language built into the module (doesn't
     * require any translation file).
     */
    static get() { return Locale._currentIdentifier; }
    /**
     * Gets whether the given locale identifier is available to `timecount`.
     *
     * @param localeIdentifier
     *   A language / region locale specifier (e.g. "en-au", "pt-br").
     * @return
     *   True if a valid locale was provided; false otherwise.
     */
    static isAvailable(localeIdentifier) {
        if (!Locale._availableIdentifiers) {
            Locale._initialize();
        }
        localeIdentifier = localeIdentifier.toLocaleLowerCase();
        return Locale.listAvailable().indexOf(localeIdentifier) > -1;
    }
    /**
     * Gets a list with all locale identifiers available to timecount.
     *
     * @return
     *   An array with all available locale identifiers.
     */
    static listAvailable() {
        if (!Locale._availableIdentifiers) {
            Locale._initialize();
        }
        const languages = Object.keys(this._availableLanguages);
        return Locale._availableIdentifiers.concat(["en", "en-us"], languages).sort();
    }
    /**
     * Sets the current timecount language using the specified locale identifier (e.g.: "pt" represents Portuguese — the
     * international translation for the language as a whole; "pt-br" is Portuguese (Brazilian) — represents a localized
     * variation of the Portuguese language meant for Brazil).
     *
     * @param localeIdentifier
     *   A string with a 2 letter language identifier ("en", "es", "pt", etc.) -or- a 5 letter language + region
     *   identifier ("en-ca", "pt-ao"). This parameter is case-insensitive. If empty, it will reset the locale to "en".
     * @throws Error
     *   When the locale identifier is invalid.
     */
    static set(localeIdentifier = "en") {
        localeIdentifier = localeIdentifier.toLocaleLowerCase();
        // English (US) is hardcoded; no translation file required
        if (localeIdentifier === "en" || localeIdentifier === "en-us") {
            Locale._currentIdentifier = "en-us";
            Locale._settings = {};
            return;
        }
        // isAvailable already calls _initialize
        if (!Locale.isAvailable(localeIdentifier)) {
            throw new Error("Invalid locale identifier");
        }
        if (localeIdentifier.length === 2 && Locale._availableLanguages.hasOwnProperty(localeIdentifier)) {
            localeIdentifier = Locale._availableLanguages[localeIdentifier];
        }
        const pathToLocaleFile = Locale._availableFiles[localeIdentifier];
        Locale._currentIdentifier = localeIdentifier;
        const settings = require(`./locales/${pathToLocaleFile}`).default;
        Locale._settings = settings;
        // Parsing deprecated properties
        settings.defaultTimeUnit = settings.defaultTimeUnit || settings.defaultOptions;
        if (!settings.timeUnits) {
            return;
        }
        // tslint:disable-next-line:curly
        for (const timeUnitName in settings.timeUnits)
            if (settings.timeUnits.hasOwnProperty(timeUnitName)) {
                // Fixes the plurals when translating: nulls are not parsed like undefineds
                const timeUnit = settings.timeUnits[timeUnitName];
                timeUnit.customPlural = timeUnit.customPlural || null;
            }
        return;
    }
    static _initialize() {
        const availableFiles = {};
        const availableIdentifiers = [];
        const availableLanguages = {};
        const localeFiles = fs.readdirSync(path.join(__dirname, "locales"));
        for (const localeFile of localeFiles) {
            const localeIdentifier = localeFile.toLocaleLowerCase();
            // Splits the file path into 3 groups: path, language and region (which is optional)
            const localeParser = /^([a-z]{2})-?(|[a-z]{2})\.ts/.exec(localeIdentifier);
            if (localeParser === null) {
                continue;
            }
            // Separating regionless languages and regionalizations
            const language = localeParser[1];
            const region = localeParser[2];
            const identifier = `${language}-${region.length === 2 ? region : ""}`;
            if (!availableLanguages.hasOwnProperty(language)) {
                availableLanguages[language] = identifier;
            }
            availableIdentifiers.push(identifier);
            availableFiles[identifier] = localeFile;
        }
        Locale._availableFiles = availableFiles;
        Locale._availableIdentifiers = availableIdentifiers;
        Locale._availableLanguages = availableLanguages;
    }
}
Locale._currentIdentifier = "en-us";
Locale._settings = {};
exports.Locale = Locale;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2NhbGl6YXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Z0ZBS2dGO0FBQ2hGLGtDQUFrQyxDQUFDLE1BQU07QUFDekMseUJBQTBCO0FBQzFCLDZCQUE4QjtBQWE5Qjs7Ozs7Ozs7Ozs7R0FXRztBQUNIO0lBeUpJLGdCQUF3QixNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBakpuRjs7OztPQUlHO0lBQ0ksTUFBTSxLQUFLLGlCQUFpQixLQUFLLE9BQU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUUzRSw0R0FBNEc7SUFDckcsTUFBTSxLQUFLLFFBQVEsS0FBSyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBRXpEOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsR0FBRyxLQUFLLE9BQU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUV6RDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBd0I7UUFFOUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRTtZQUMvQixNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDeEI7UUFFRCxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXhELE9BQU8sTUFBTSxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxhQUFhO1FBRXZCLElBQUksQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUU7WUFDL0IsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3hCO1FBRUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN4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QyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBRXRFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzlDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUM3QztZQUVELG9CQUFvQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0QyxjQUFjLENBQUMsVUFBVSxDQUFDLEdBQUcsVUFBVSxDQUFDO1NBQzNDO1FBRUQsTUFBTSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7UUFDeEMsTUFBTSxDQUFDLHFCQUFxQixHQUFHLG9CQUFvQixDQUFDO1FBQ3BELE1BQU0sQ0FBQyxtQkFBbUIsR0FBRyxrQkFBa0IsQ0FBQztJQUNwRCxDQUFDOztBQWxKYyx5QkFBa0IsR0FBRyxPQUFPLENBQUM7QUFDN0IsZ0JBQVMsR0FBbUIsRUFBRSxDQUFDO0FBTmxELHdCQTBKQyIsImZpbGUiOiJsb2NhbGl6YXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAxOCBQZWRybyBKb3PDqSBCYXRpc3RhXHJcbk1JVCBMaWNlbnNlXHJcblxyXG5TZWUgdGhlIExJQ0VOU0UgZmlsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyoqIFtbaW5jbHVkZTpsb2NhbGl6YXRpb24ubWRdXSAqLyAvKiogKi9cclxuaW1wb3J0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5pbXBvcnQgeyBCYXNlVGltZVVuaXQsIFRpbWVVbml0RGF0YWJhc2UsIFRpbWVXcml0ZXJTZXR0aW5ncyB9IGZyb20gXCIuXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgZGVzY3JpYmVzIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzIGJlbG9uZ2luZyB0byB0aGUgc3BlY2lmaWVkIHR5cGUgcGFyYW1ldGVyIGBUYC5cclxuICpcclxuICogQHR5cGVwYXJhbSBUXHJcbiAqICAgVHlwZSBvZiBlbGVtZW50IHN0b3JlZCBieSB0aGUgb2JqZWN0IChzdHJpbmcgYnkgZGVmYXVsdCkuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIERpY3Rpb25hcnk8VCA9IHN0cmluZz4ge1xyXG4gICAgW3Byb3BlcnR5TmFtZTogc3RyaW5nXTogVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyB0aGUgaW50ZXJuYXRpb25hbGl6YXRpb24gb2YgdGhlIG1vZHVsZSwgYWx0ZXJpbmcgdGhlIHJlc3VsdHMgc3ludGhlc2l6ZWQgYnlcclxuICogW3RpbWUgd3JpdGVyc10oX2luZGV4Xy50aW1ld3JpdGVyLmh0bWwpLlxyXG4gKlxyXG4gKiBUcmFuc2xhdGlvbnMgYXJlIHN0b3JlZCBpbiBmaWxlcyBsb2NhdGVkIGF0IGBzcmMvbG9jYWxlc2AuIFRoZXNlIGZpbGVzIGNvbnRhaW4gdGhlIHRyYW5zY3JpcHRpb24gZm9yIHRpbWUgdW5pdHMgYW5kXHJcbiAqIGxpbmd1aXN0aWMgY29uZmlndXJhdGlvbnMuXHJcbiAqXHJcbiAqIC0tLVxyXG4gKlxyXG4gKiBTZWUgW0NvbnRyaWJ1dGluZzogVHJhbnNsYXRpbmddKGh0dHBzOi8vZ2l0aHViLmNvbS9wamJhdGlzdGEvdGltZWNvdW50L2Jsb2IvbWFzdGVyL0NPTlRSSUJVVElORy5tZCN0cmFuc2xhdGluZykgaWZcclxuICogeW91IHdpc2ggdG8gY29udHJpYnV0ZSB3aXRoIGEgbmV3IHRyYW5zbGF0aW9uIGZvciB0aW1lY291bnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTG9jYWxlIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYXZhaWxhYmxlRmlsZXM6IERpY3Rpb25hcnk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYXZhaWxhYmxlSWRlbnRpZmllcnM6IHN0cmluZ1tdO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2F2YWlsYWJsZUxhbmd1YWdlczogRGljdGlvbmFyeTtcclxuICAgIHByaXZhdGUgc3RhdGljIF9jdXJyZW50SWRlbnRpZmllciA9IFwiZW4tdXNcIjtcclxuICAgIHByaXZhdGUgc3RhdGljIF9zZXR0aW5nczogTG9jYWxlU2V0dGluZ3MgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGlkZW50aWZpZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgU2luY2UgdjEuMS4wIC0gSW4gZmF2b3Igb2YgYGdldGAgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGN1cnJlbnRJZGVudGlmaWVyKCkgeyByZXR1cm4gTG9jYWxlLl9jdXJyZW50SWRlbnRpZmllcjsgfVxyXG5cclxuICAgIC8qKiBHZXRzIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudCBsb2NhbGUgd2hpY2ggcmVwcmVzZW50cyB0aGUgdHJhbnNsYXRpb24gZmlsZSBjdXJyZW50bHkgbG9hZGVkLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgc2V0dGluZ3MoKSB7IHJldHVybiBMb2NhbGUuX3NldHRpbmdzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBpZGVudGlmaWVyIChlLmcuOiBcImZyXCIgcmVwcmVzZW50cyBGcmVuY2gg4oCUIHRoZSBpbnRlcm5hdGlvbmFsIHRyYW5zbGF0aW9uIGZvciB0aGUgbGFuZ3VhZ2VcclxuICAgICAqIGFzIGEgd2hvbGU7IFwiZnItY2FcIiBpcyBGcmVuY2ggKENhbmFkYSkg4oCUIHJlcHJlc2VudHMgYSBsb2NhbGl6ZWQgdmFyaWF0aW9uIG9mIHRoZSBGcmVuY2ggbGFuZ3VhZ2UgbWVhbnQgZm9yXHJcbiAgICAgKiBDYW5hZGEpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFwiZW4tdXNcIiwgd2hpY2ggcmVwcmVzZW50cyBFbmdsaXNoIChVbml0ZWQgU3RhdGVzKSwgYSBsYW5ndWFnZSBidWlsdCBpbnRvIHRoZSBtb2R1bGUgKGRvZXNuJ3RcclxuICAgICAqIHJlcXVpcmUgYW55IHRyYW5zbGF0aW9uIGZpbGUpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCgpIHsgcmV0dXJuIExvY2FsZS5fY3VycmVudElkZW50aWZpZXI7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgZ2l2ZW4gbG9jYWxlIGlkZW50aWZpZXIgaXMgYXZhaWxhYmxlIHRvIGB0aW1lY291bnRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2NhbGVJZGVudGlmaWVyXHJcbiAgICAgKiAgIEEgbGFuZ3VhZ2UgLyByZWdpb24gbG9jYWxlIHNwZWNpZmllciAoZS5nLiBcImVuLWF1XCIsIFwicHQtYnJcIikuXHJcbiAgICAgKiBAcmV0dXJuXHJcbiAgICAgKiAgIFRydWUgaWYgYSB2YWxpZCBsb2NhbGUgd2FzIHByb3ZpZGVkOyBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNBdmFpbGFibGUobG9jYWxlSWRlbnRpZmllcjogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIGlmICghTG9jYWxlLl9hdmFpbGFibGVJZGVudGlmaWVycykge1xyXG4gICAgICAgICAgICBMb2NhbGUuX2luaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxvY2FsZUlkZW50aWZpZXIgPSBsb2NhbGVJZGVudGlmaWVyLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBMb2NhbGUubGlzdEF2YWlsYWJsZSgpLmluZGV4T2YobG9jYWxlSWRlbnRpZmllcikgPiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaXN0IHdpdGggYWxsIGxvY2FsZSBpZGVudGlmaWVycyBhdmFpbGFibGUgdG8gdGltZWNvdW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5cclxuICAgICAqICAgQW4gYXJyYXkgd2l0aCBhbGwgYXZhaWxhYmxlIGxvY2FsZSBpZGVudGlmaWVycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsaXN0QXZhaWxhYmxlKCkge1xyXG5cclxuICAgICAgICBpZiAoIUxvY2FsZS5fYXZhaWxhYmxlSWRlbnRpZmllcnMpIHtcclxuICAgICAgICAgICAgTG9jYWxlLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9hdmFpbGFibGVMYW5ndWFnZXMpO1xyXG4gICAgICAgIHJldHVybiBMb2NhbGUuX2F2YWlsYWJsZUlkZW50aWZpZXJzLmNvbmNhdChbXCJlblwiLCBcImVuLXVzXCJdLCBsYW5ndWFnZXMpLnNvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdGltZWNvdW50IGxhbmd1YWdlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbG9jYWxlIGlkZW50aWZpZXIgKGUuZy46IFwicHRcIiByZXByZXNlbnRzIFBvcnR1Z3Vlc2Ug4oCUIHRoZVxyXG4gICAgICogaW50ZXJuYXRpb25hbCB0cmFuc2xhdGlvbiBmb3IgdGhlIGxhbmd1YWdlIGFzIGEgd2hvbGU7IFwicHQtYnJcIiBpcyBQb3J0dWd1ZXNlIChCcmF6aWxpYW4pIOKAlCByZXByZXNlbnRzIGEgbG9jYWxpemVkXHJcbiAgICAgKiB2YXJpYXRpb24gb2YgdGhlIFBvcnR1Z3Vlc2UgbGFuZ3VhZ2UgbWVhbnQgZm9yIEJyYXppbCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvY2FsZUlkZW50aWZpZXJcclxuICAgICAqICAgQSBzdHJpbmcgd2l0aCBhIDIgbGV0dGVyIGxhbmd1YWdlIGlkZW50aWZpZXIgKFwiZW5cIiwgXCJlc1wiLCBcInB0XCIsIGV0Yy4pIC1vci0gYSA1IGxldHRlciBsYW5ndWFnZSArIHJlZ2lvblxyXG4gICAgICogICBpZGVudGlmaWVyIChcImVuLWNhXCIsIFwicHQtYW9cIikuIFRoaXMgcGFyYW1ldGVyIGlzIGNhc2UtaW5zZW5zaXRpdmUuIElmIGVtcHR5LCBpdCB3aWxsIHJlc2V0IHRoZSBsb2NhbGUgdG8gXCJlblwiLlxyXG4gICAgICogQHRocm93cyBFcnJvclxyXG4gICAgICogICBXaGVuIHRoZSBsb2NhbGUgaWRlbnRpZmllciBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldChsb2NhbGVJZGVudGlmaWVyOiBzdHJpbmcgPSBcImVuXCIpIHtcclxuXHJcbiAgICAgICAgbG9jYWxlSWRlbnRpZmllciA9IGxvY2FsZUlkZW50aWZpZXIudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gRW5nbGlzaCAoVVMpIGlzIGhhcmRjb2RlZDsgbm8gdHJhbnNsYXRpb24gZmlsZSByZXF1aXJlZFxyXG4gICAgICAgIGlmIChsb2NhbGVJZGVudGlmaWVyID09PSBcImVuXCIgfHwgbG9jYWxlSWRlbnRpZmllciA9PT0gXCJlbi11c1wiKSB7XHJcbiAgICAgICAgICAgIExvY2FsZS5fY3VycmVudElkZW50aWZpZXIgPSBcImVuLXVzXCI7XHJcbiAgICAgICAgICAgIExvY2FsZS5fc2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaXNBdmFpbGFibGUgYWxyZWFkeSBjYWxscyBfaW5pdGlhbGl6ZVxyXG4gICAgICAgIGlmICghTG9jYWxlLmlzQXZhaWxhYmxlKGxvY2FsZUlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9jYWxlIGlkZW50aWZpZXJcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobG9jYWxlSWRlbnRpZmllci5sZW5ndGggPT09IDIgJiYgTG9jYWxlLl9hdmFpbGFibGVMYW5ndWFnZXMuaGFzT3duUHJvcGVydHkobG9jYWxlSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgbG9jYWxlSWRlbnRpZmllciA9IExvY2FsZS5fYXZhaWxhYmxlTGFuZ3VhZ2VzW2xvY2FsZUlkZW50aWZpZXJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGF0aFRvTG9jYWxlRmlsZSA9IExvY2FsZS5fYXZhaWxhYmxlRmlsZXNbbG9jYWxlSWRlbnRpZmllcl07XHJcblxyXG4gICAgICAgIExvY2FsZS5fY3VycmVudElkZW50aWZpZXIgPSBsb2NhbGVJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzOiBMb2NhbGVTZXR0aW5ncyA9IHJlcXVpcmUoYC4vbG9jYWxlcy8ke3BhdGhUb0xvY2FsZUZpbGV9YCkuZGVmYXVsdDtcclxuICAgICAgICBMb2NhbGUuX3NldHRpbmdzID0gc2V0dGluZ3M7XHJcblxyXG4gICAgICAgIC8vIFBhcnNpbmcgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgc2V0dGluZ3MuZGVmYXVsdFRpbWVVbml0ID0gc2V0dGluZ3MuZGVmYXVsdFRpbWVVbml0IHx8IHNldHRpbmdzLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnRpbWVVbml0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y3VybHlcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVVbml0TmFtZSBpbiBzZXR0aW5ncy50aW1lVW5pdHMpIGlmIChzZXR0aW5ncy50aW1lVW5pdHMuaGFzT3duUHJvcGVydHkodGltZVVuaXROYW1lKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gRml4ZXMgdGhlIHBsdXJhbHMgd2hlbiB0cmFuc2xhdGluZzogbnVsbHMgYXJlIG5vdCBwYXJzZWQgbGlrZSB1bmRlZmluZWRzXHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVVbml0ID0gc2V0dGluZ3MudGltZVVuaXRzW3RpbWVVbml0TmFtZSBhcyBrZXlvZiBUaW1lVW5pdERhdGFiYXNlXTtcclxuICAgICAgICAgICAgdGltZVVuaXQuY3VzdG9tUGx1cmFsID0gdGltZVVuaXQuY3VzdG9tUGx1cmFsIHx8IG51bGwgYXMgYW55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9pbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZUZpbGVzOiBEaWN0aW9uYXJ5ID0ge307XHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlSWRlbnRpZmllcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VzOiBEaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IGxvY2FsZUZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgXCJsb2NhbGVzXCIpKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBsb2NhbGVGaWxlIG9mIGxvY2FsZUZpbGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZUlkZW50aWZpZXIgPSBsb2NhbGVGaWxlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdHMgdGhlIGZpbGUgcGF0aCBpbnRvIDMgZ3JvdXBzOiBwYXRoLCBsYW5ndWFnZSBhbmQgcmVnaW9uICh3aGljaCBpcyBvcHRpb25hbClcclxuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGFyc2VyID0gL14oW2Etel17Mn0pLT8ofFthLXpdezJ9KVxcLnRzLy5leGVjKGxvY2FsZUlkZW50aWZpZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvY2FsZVBhcnNlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXRpbmcgcmVnaW9ubGVzcyBsYW5ndWFnZXMgYW5kIHJlZ2lvbmFsaXphdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsb2NhbGVQYXJzZXJbMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IGxvY2FsZVBhcnNlclsyXTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGAke2xhbmd1YWdlfS0ke3JlZ2lvbi5sZW5ndGggPT09IDIgPyByZWdpb24gOiBcIlwifWA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWF2YWlsYWJsZUxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eShsYW5ndWFnZSkpIHtcclxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUxhbmd1YWdlc1tsYW5ndWFnZV0gPSBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhdmFpbGFibGVJZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBhdmFpbGFibGVGaWxlc1tpZGVudGlmaWVyXSA9IGxvY2FsZUZpbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMb2NhbGUuX2F2YWlsYWJsZUZpbGVzID0gYXZhaWxhYmxlRmlsZXM7XHJcbiAgICAgICAgTG9jYWxlLl9hdmFpbGFibGVJZGVudGlmaWVycyA9IGF2YWlsYWJsZUlkZW50aWZpZXJzO1xyXG4gICAgICAgIExvY2FsZS5fYXZhaWxhYmxlTGFuZ3VhZ2VzID0gYXZhaWxhYmxlTGFuZ3VhZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHN0YXRpYyBjbGFzcyBMb2NhbGVcIik7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgdGhlIGNvbmZpZ3VyYXRpb25zIG9mIHRyYW5zbGF0aW9uIGZpbGVzLlxyXG4gKlxyXG4gKiBBZnRlciBhIHRyYW5zbGF0aW9uIGhhcyBiZWVuIFtzZXRdKC4uL2NsYXNzZXMvX2xvY2FsaXphdGlvbl8ubG9jYWxlLmh0bWwjc2V0KSwgdGhlc2UgY29uZmlndXJhdGlvbnMgd2lsbCBiZSBhdmFpbGFibGVcclxuICogYXQgW0xvY2FsZS5zZXR0aW5nc10oLi4vY2xhc3Nlcy9fbG9jYWxpemF0aW9uXy5sb2NhbGUuaHRtbCNzZXR0aW5ncykgdG8gYmUgdXNlZCBieSBpbnRlcmVzdGVkIG9iamVjdHMgKHN1Y2ggYXNcclxuICogW3RpbWUgd3JpdGVyc10oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCkpLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVTZXR0aW5ncyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGVzZSBvcHRpb25zIGFsbG93IGZvciBkZWZhdWx0IGxpbmd1aXN0aWMgY29uZmlndXJhdGlvbiBmb3IgdGhlIHRpbWUgdW5pdHMgb2YgdGhlIGxvY2FsZS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBJbiBmYXZvciBvZiBgZGVmYXVsdFRpbWVVbml0YCAod2lsbCBiZSByZW1vdmVkIGluIHYyKS5cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBCYXNlVGltZVVuaXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgYWJsZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBsaW5ndWlzdGljIHBhcnNpbmcgb2YgdGltZSB1bml0cy5cclxuICAgICAqXHJcbiAgICAgKiBJdCBtYXkgYmUgdXNlZCB0byBzZXQgYSBbY3VzdG9tIHBsdXJhbCBmdW5jdGlvbl0oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNjdXN0b21wbHVyYWwpIG9yIHByZXZlbnQgdGltZSB1bml0c1xyXG4gICAgICogZnJvbSBiZWluZyBbcGx1cmFsaXplZF0oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNwbHVyYWxpemUpIGJ5IGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRUaW1lVW5pdD86IEJhc2VUaW1lVW5pdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERhdGFiYXNlIG9mIHRpbWUgdW5pdCB0cmFuc2xhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZXMgdGhlIGFiaWxpdHkgdG8gc2V0IFtyZWFkYWJsZSBuYW1lc10oX2luZGV4Xy5iYXNldGltZXVuaXQuaHRtbCNyZWFkYWJsZW5hbWUpIGFuZFxyXG4gICAgICogW3BsdXJhbHNdKF9pbmRleF8uYmFzZXRpbWV1bml0Lmh0bWwjY3VzdG9tcGx1cmFsKSBvZiB0cmFuc2xhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHRpbWVVbml0cz86IFRpbWVVbml0RGF0YWJhc2U8QmFzZVRpbWVVbml0PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyYXRpb25zIGFzc2lnbmVkIHRvIFt0aW1lIHdyaXRlcnNdKC4uL2NsYXNzZXMvX2luZGV4Xy50aW1ld3JpdGVyLmh0bWwpLlxyXG4gICAgICpcclxuICAgICAqIENvbnRhaW5zIGxpbmd1aXN0aWMgYW5kIG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzIGFwcGxpZWQgdG8gYWxsXHJcbiAgICAgKiBbY291bnRkb3duXSguLi9jbGFzc2VzL19pbmRleF8udGltZXdyaXRlci5odG1sI2NvdW50ZG93bikgYW5kIFt3cml0ZV0oLi4vY2xhc3Nlcy9faW5kZXhfLnRpbWV3cml0ZXIuaHRtbCN3cml0ZSlcclxuICAgICAqIGNhbGxzICh1bmxlc3Mgb3ZlcnJpZGVuIGJ5IHRoZSBvYmplY3Qgb3IgbWV0aG9kKS5cclxuICAgICAqL1xyXG4gICAgd3JpdGVyT3B0aW9ucz86IFRpbWVXcml0ZXJTZXR0aW5ncztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGV4dGVuZHMgZnJvbSBbQmFzZVRpbWVVbml0XShfaW5kZXhfLmJhc2V0aW1ldW5pdC5odG1sKSB3aXRoIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhhdCBpdCBlbmZvcmNlc1xyXG4gKiBpdHMgW3JlYWRhYmxlIG5hbWVdKCNyZWFkYWJsZW5hbWUpIHRvIGJlIG5vdC1vcHRpb25hbCwgaW4gb3JkZXIgdG8gYmV0dGVyIGNoYXJhY3Rlcml6ZSBhIHBhcnNlZCB0aW1lIHVuaXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xLjAgLSBVbm5lY2Vzc2FyeSBpbnRlcmZhY2UgKHdpbGwgYmUgcmVtb3ZlZCBpbiB2MikuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsaXplZFRpbWVVbml0IGV4dGVuZHMgQmFzZVRpbWVVbml0IHtcclxuXHJcbiAgICAvKiogVGhpcyB2ZXJzaW9uIG9mIHRoZSBwcm9wZXJ0eSBpcyBub3Qgb3B0aW9uYWwuICovXHJcbiAgICByZWFkb25seSByZWFkYWJsZU5hbWU6IHN0cmluZztcclxufVxyXG4iXX0=
